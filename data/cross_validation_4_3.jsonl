{"instruction": "- 回答中最后一句话以感叹号结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('！')", 1.0]], "cases": [["请确保最后一句话以感叹号结尾！", true], ["最后一句话是感叹号！\t", true], ["请确保最后一句话以感叹号结尾。", false], ["最后一句话是感叹号！\r\n", true], ["最后一句话是感叹号！ ", true], ["最后一句话是感叹号！\n", true], ["这是一个测试句子。", false], ["这是一个测试句子！", true]]}
{"instruction": "- 回答中最后一句话以省略号结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('...')", 1.0]], "cases": [["测试", false], ["测试...", true], ["这是一个测试。", false], ["请确保最后一句话以省略号结尾。", false], ["这是一个测试...", true], ["最后一句话以省略号结尾...", true], ["请检查这个回复是否正确", false], ["最后一句话以省略号结尾", false], ["请检查这个回复是否正确...", true], ["这是另一个测试...", true], ["请确保最后一句话以省略号结尾...", true], ["请确保最后一句话以省略号结尾", false]]}
{"instruction": "- 回答中最后一句话以问号结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('？')", 1.0]], "cases": [["这是一个测试", false], ["你喜欢编程吗？", true], ["这是一个问题。", false], ["请告诉我你的名字。", false], ["你今天过得怎么样？", true], ["这是一个问题吗？", true]]}
{"instruction": "- 回答中每个段落前加\"***\"。", "eval_func": [["def evaluate(response):\n    # 检查每个段落是否以'***'开头\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph.strip() and not paragraph.strip().startswith('***'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('***'):\n            return False\n    return True", 0.8181818181818182]], "cases": [["这是一个段落。\n***这是另一个段落。", false], ["这是唯一一段。", false], ["***这是一个段落。\n***这是另一个段落。", true], ["***这是第一段。\n***这是第二段。\n这是第三段。", false], ["***这是一个段落。\n\n\n***这是另一个段落。", true], ["***这是一个段落。\n\n***这是另一个段落。", true], ["***这是第一段。\n***这是第二段。\n***这是第三段。", true], ["***这是一个段落。\n这是另一个段落。", false], ["这是第一段。\n***这是第二段。\n***这是第三段。", false], ["***这是唯一一段。", true], ["***这是第一段。\n这是第二段。\n***这是第三段。", false]]}
{"instruction": "- 回答中每个段落前加\"+++\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('+++'):\n            return False\n    return True", 1.0]], "cases": [["+++这是第一段。\n+++这是第二段。", true], ["+++这是第一段。\n这是第二段。", false], ["+++这是第一段。\n\n+++这是第二段。", true], ["+++这是第一段。\n+++这是第二段。\n+++这是第三段。", true], ["这是第一段。\n+++这是第二段。", false]]}
{"instruction": "- 回答中每个段落前加\"|||\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('|||'):\n            return False\n    return True", 1.0]], "cases": [["这是第一段。\n|||这是第二段。\n|||这是第三段。", false], ["|||这是第一段。\n|||这是第二段。\n这是第三段。", false], ["|||这是唯一一段。", true], ["|||这是第一段。\n|||这是第二段。", true], ["|||这是第一段。\n这是第二段。\n|||这是第三段。", false], ["|||这是第一段。\n|||这是第二段。\n|||这是第三段。", true]]}
{"instruction": "- 回答中每个段落前加\"---\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('---'):\n            return False\n    return True", 1.0]], "cases": [["---这是第一段。\n---这是第二段。\n---这是第三段。", true], ["---这是第一段。\n这是第二段。\n---这是第三段。", false], ["这是第一段。\n---这是第二段。\n---这是第三段。", false], ["---这是第一段。\n---这是第二段。\n这是第三段。", false], ["---这是第一段。\n---这是第二段。\n---这是第三段。\n", true]]}
{"instruction": "- 回答字数不多于100个字。", "eval_func": [["def evaluate(response):\n    return len(response) <= 100", 1.0]], "cases": [["这是一个非常长的句子，目的是为了测试evaluate函数是否能够正确识别超过100个字的情况。我们需要继续添加更多的内容，确保这个字符串确实超过了100个字。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回False。", false], ["短句。", true], ["这是一个稍微长一点的句子，但仍然不超过100个字。我们可以通过这种方式来测试evaluate函数的准确性。", true], ["这是一个测试案例，字数不超过100个字。", true]]}
{"instruction": "- 回答字数不多于200个字。", "eval_func": [["def evaluate(response):\n    return len(response) <= 200", 1.0], ["def evaluate(response):\n    # 计算输入字符串的字数\n    word_count = len(response)\n    # 检查字数是否不多于200个字\n    return word_count <= 200", 1.0]], "cases": [["这是一个非常长的测试案例，字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达复杂的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，极大地提高了开发效率。总之，Python是一种非常优秀的编程语言，适合各种不同的应用场景。", false], ["简短的测试。", true], ["这是一个测试案例，字数不超过200个字。", true], ["这个测试案例的字数刚好是200个字。为了确保这个测试案例确实是200个字，我们需要精确地计算每一个字。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。", true], ["这是一个非常长的测试案例，字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常优秀的编程语言，适合各种类型的开发任务。", false], ["这个测试案例的字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常优秀的编程语言，适合各种类型的开发任务。", false]]}
{"instruction": "- 回答字数不少于50个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于50个字\n    if length >= 50:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这个字符串太短了。", false], ["短短的字符串。", false]]}
{"instruction": "- 回答字数不少于200个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 检查长度是否不少于200个字\n    if length >= 200:\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于200个字\n    if length >= 200:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个符合要求的测试案例。这个字符串的长度超过了200个字，因此应该返回True。为了确保字符串的长度足够长，我们可以添加一些额外的内容。比如说，我们可以描述一下Python语言的特点。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。它由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python语法简洁而清晰，具有丰富的库和强大的社区支持。Python广泛应用于Web开发、数据分析、人工智能、科学计算等领域。总之，这个字符串的长度已经超过了200个字，因此evaluate函数应该返回True。", true], ["这是一个测试案例，长度不足200个字。这个字符串的目的是为了测试evaluate函数是否能够正确识别不符合指令的情况。我们需要确保这个字符串的长度确实不足200个字，以便测试函数的准确性。", false]]}
{"instruction": "- 回答包含日期，格式为YYYY-MM-DD。", "eval_func": [["import re\n\ndef evaluate(response):\n    # 定义日期格式的正则表达式\n    date_pattern = re.compile(r'\\b\\d{4}-\\d{2}-\\d{2}\\b')\n    # 搜索是否存在符合格式的日期\n    match = date_pattern.search(response)\n    # 如果找到匹配的日期，返回True，否则返回False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配YYYY-MM-DD格式的日期\n    date_pattern = re.compile(r'\\b\\d{4}-\\d{2}-\\d{2}\\b')\n    # 查找所有匹配的日期\n    dates = date_pattern.findall(response)\n    # 如果找到至少一个匹配的日期，返回True，否则返回False\n    return bool(dates)", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配YYYY-MM-DD格式的日期\n    pattern = r'\\b\\d{4}-\\d{2}-\\d{2}\\b'\n    match = re.search(pattern, response)\n    return bool(match)", 1.0]], "cases": [["日期格式不正确：2023.10.05。", false], ["会议安排在2023/11/15。", false], ["今天是2023年10月5日。", false], ["明天是2023年10月6日。", false], ["日期格式不正确：2023.08.30。", false], ["日期格式应该是2023/10/05。", false], ["请确认2023/12/01的时间。", false], ["2023-10-5是错误的格式。", false]]}
{"instruction": "- 回答包含“大模型”这个词。", "eval_func": [["def evaluate(response):\n    return '大模型' in response", 1.0]], "cases": [["我们需要讨论更多的细节。", false], ["这个回答包含大模型这个词。", true], ["大模型是一个非常重要的概念。", true], ["在机器学习中，大模型有很多应用。", true], ["我们需要讨论一些其他的技术。", false], ["这个回答没有包含指定的词。", false]]}
{"instruction": "- 回答包含“我是AI大模型”这个词。", "eval_func": [["def evaluate(response):\n    return \"我是AI大模型\" in response", 1.0]], "cases": [["你好，我是AI大模型，可以帮助你解决问题。", true], ["AI大模型在很多领域都有应用。", false], ["我是AI大模型，欢迎向我提问。", true], ["我是AI大模型，我可以帮助你解决问题。", true], ["AI大模型在这里。", false], ["你好，我是一个AI模型，可以帮助你解决问题。", false], ["我是AI模型。", false], ["请问你是AI大模型吗？", false], ["我是AI大模型，可以为你提供帮助。", true], ["你好，我是一个AI模型。", false], ["我是AI大模型，可以回答你的问题。", true]]}
{"instruction": "- 回答包含“温馨提示”这个词。", "eval_func": [["def evaluate(response):\n    return '温馨提示' in response", 1.0], ["def evaluate(response):\n    return \"温馨提示\" in response", 1.0]], "cases": [["温馨提示：请保持安静。", true], ["请注意，这里有一些重要信息。", false], ["提示：请保持安静。", false], ["温馨提示：今天的天气很好。", true], ["温馨提示：今天的会议取消了。", true], ["这是一个温馨提示，请注意。", true], ["提示：请遵守规则。", false]]}
{"instruction": "- 回答以“谢谢！”结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('谢谢！')", 1.0]], "cases": [["谢谢！这是一个测试。", false], ["这是一个测试。", false], ["谢谢！ ", true], ["这是一个测试。谢谢！ ", true], ["谢谢！", true], ["这是一个测试。谢谢！", true], ["这是一个测试。谢谢", false]]}
{"instruction": "- 回答以“你还有什么问题吗？”结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('你还有什么问题吗？')", 0.8], ["def evaluate(response):\n    return response.strip().endswith('你还有什么问题吗？')", 1.0]], "cases": [["好的，我明白了。你还有什么问题吗？", true], ["请问还有其他问题吗？你还有什么问题吗？", true], ["这是一个测试。", false], ["这是一个测试。你还有什么问题吗？", true], ["这是一个测试。你还有什么问题吗", false], ["你还有什么问题吗？ ", true], ["这是一个测试。你还有什么问题吗？ ", true], ["你还有什么问题吗？", true], ["你还有什么问题吗？谢谢。", false], ["好的，我明白了。", false]]}
{"instruction": "- 回答以“这就是我的回答。”结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('这就是我的回答。')", 1.0]], "cases": [["这是一个测试。这不是我的回答。", false], ["这不是我的回答。这就是我的回答", false], ["这就是我的回答。 ", false], ["回答：这就是我的回答。", true], ["这就是我的回答。", true], ["回答以“这就是我的回答。”结尾。这就是我的回答。", true], ["这是一个测试。这就是我的回答。", true], ["这是另一个测试。这不是我的回答。", false]]}
{"instruction": "- 回答以“你觉得呢？”结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('你觉得呢？')", 1.0]], "cases": [["你觉得呢？ ", true], ["这是一个测试，你觉得呢？", true], ["这是一个测试", false], ["你觉得呢", false], ["这是一个测试。", false], ["这是一个测试，你觉得呢", false], ["你觉得呢？\r\n", true], ["你觉得呢？\t", true], ["这是一个测试，你觉得呢？ ", true], ["你觉得呢？\n", true], ["你觉得呢？这是一个测试", false], ["你觉得呢？", true]]}
{"instruction": "- 回答以“我回答好了！”结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('我回答好了！')", 1.0]], "cases": [["这是一个测试。我回答好了", false], ["这是一个测试。", false], ["我回答好了！", true], ["我回答好了！这是一个测试。", false], ["这是一个测试。我回答好了！", true], ["这是另一个测试。", false], ["这是一个测试。我回答好了！ ", false]]}
{"instruction": "- 用数字编号的方式回答，每个段落用逗号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    if not re.match(r'^\\d+\\.\\s', response):\n        return False\n    # 检查每个段落是否用逗号隔开\n    paragraphs = response.split(',')\n    for paragraph in paragraphs:\n        if not re.match(r'^\\d+\\.\\s', paragraph.strip()):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    numbered_pattern = re.compile(r'^(\\d+\\.\\s).*')\n    # 检查是否每个段落用逗号隔开\n    comma_separated_pattern = re.compile(r'\\d+\\.\\s[^,]+(,\\s\\d+\\.\\s[^,]+)*$')\n    if not numbered_pattern.match(response):\n        return False\n    if not comma_separated_pattern.match(response):\n        return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    if not re.match(r'^\\d+\\.', response):\n        return False\n    # 检查每个段落是否用逗号隔开\n    paragraphs = response.split(',')\n    for paragraph in paragraphs:\n        if not re.match(r'^\\d+\\.', paragraph.strip()):\n            return False\n    return True", 1.0]], "cases": [["1. 这是第一段, 2. 这是第二段, 3. 这是第三段", true], ["1. 这是第一段, 2. 这是第二段, 3. 这是第三段, 4. 这是第四段", true], ["1. 这是第一段,2. 这是第二段,这是第三段", false], ["这是第一段,2. 这是第二段,3. 这是第三段", false], ["1. 这是第一段,2. 这是第二段,3. 这是第三段", true], ["1. 这是第一段, 2. 这是第二段, 这是第三段", false]]}
{"instruction": "- 用字母编号的方式回答，每个段落用分号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以字母编号的方式回答\n    pattern = r'^[a-zA-Z]\\. .+?(; [a-zA-Z]\\. .+?)*;$'\n    match = re.match(pattern, response)\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # 检查是否以字母编号的方式回答\n    pattern = re.compile(r'^[a-zA-Z]\\. .+?(; [a-zA-Z]\\. .+?)*;$')\n    return bool(pattern.match(response))", 1.0]], "cases": [["1. 这是第一段; 2. 这是第二段;", false], ["a. 这是第一段; b. 这是第二段", false], ["a. 这是第一段; b. 这是第二段; c. 这是第三段; d. 这是第四段;", true], ["a. 这是第一段; b. 这是第二段;", true], ["a. 这是第一段; b. 这是第二段; c. 这是第三段;", true], ["1. 这是第一段; 2. 这是第二段; 3. 这是第三段;", false], ["a. 这是第一段; b. 这是第二段; c. 这是第三段", false]]}
{"instruction": "- 用大写字母编号的方式回答，每个项目用逗号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 正则表达式匹配模式\n    pattern = r'^[A-Z]+\\. .+(, [A-Z]+\\. .+)*$'\n    # 使用正则表达式进行匹配\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配模式\n    pattern = r'^[A-Z]+\\. .+(, [A-Z]+\\. .+)*$'\n    # 去除首尾空格\n    response = response.strip()\n    # 匹配模式\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配模式\n    pattern = r'^[A-Z]+\\. .+(, [A-Z]+\\. .+)*$'\n    # 使用正则表达式匹配输入字符串\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["A. 项目一, B. 项目二, C. 项目三", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四, E. 项目五", true]]}
{"instruction": "- 用罗马数字编号的方式回答，每个项目用分号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 正则表达式匹配罗马数字编号的项目\n    pattern = re.compile(r'^(I|II|III|IV|V|VI|VII|VIII|IX|X)(; (I|II|III|IV|V|VI|VII|VIII|IX|X))*$')\n    # 检查是否匹配\n    return bool(pattern.match(response))", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配罗马数字编号的项目\n    pattern = r'^(I|II|III|IV|V|VI|VII|VIII|IX|X)(; (I|II|III|IV|V|VI|VII|VIII|IX|X))*$'\n    # 去除首尾空格\n    response = response.strip()\n    # 检查是否匹配模式\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["I; II; III; IV; V", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;XI", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI", false], ["I; II; III; IV; V; VI; VII; VIII; IX", true], ["I; II; III; IV;", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; ", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII", false], ["I; II; III; IV", true], ["I; II; III; IV; V; VI", true], ["I; II; III; IV; V; VI; VII; VIII; IX; XI", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV", false]]}
{"instruction": "- 以JSON格式输出。", "eval_func": [["def evaluate(response):\n    import json\n    try:\n        json.loads(response)\n        return True\n    except ValueError:\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        import json\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则返回False\n        return False", 1.0]], "cases": [["{\"name\": \"张三\", \"age\": 25}", true], ["{\"name\": \"王五\", \"age\": 30,}", false], ["{\"name\": \"李四\", \"age\": \"二十五\"}", true], ["name: \"张三\", age: 25", false], ["{\"name\": \"赵六\", \"age\": 30}", true], ["{name: \"张三\", age: 25}", false]]}
{"instruction": "- 以JSON格式输出。", "eval_func": [["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        import json\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则说明不是有效的JSON格式\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则说明不是有效的JSON格式\n        return False", 1.0]], "cases": [["{\"name\": \"张三\", \"age\": 25}", true], ["{\"name\": \"王五\", \"age\": 30,}", false], ["{\"name\": \"李四\", \"age\": \"二十五\"}", true], ["{\"name\": \"赵六\", \"age\": 30}", true], ["{name: \"张三\", age: 25}", false]]}
{"instruction": "- 以XML格式输出。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n    try:\n        ET.fromstring(response)\n        return True\n    except ET.ParseError:\n        return False", 1.0]], "cases": [["这不是XML格式的内容", false], ["<root><child 属性=\"值\">内容</child></root>", true], ["<root><child 属性='值'>内容</child></root>", true], ["<root><child>内容</child></root><extra>多余的内容</extra>", false], ["<root><child>内容</child>", false], ["<root><child>内容</child></root>", true]]}
{"instruction": "- 以XML格式输出。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n    try:\n        ET.fromstring(response)\n        return True\n    except ET.ParseError:\n        return False", 1.0]], "cases": [["这不是XML格式的内容", false], ["<root><child 属性=\"值\">内容</child></root>", true], ["<root><child>内容</child></root><extra>多余的内容</extra>", false], ["<root><child>内容</child>", false], ["<root><child>内容</child></root>", true]]}
{"instruction": "- 以XML格式输出。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n    try:\n        ET.fromstring(response)\n        return True\n    except ET.ParseError:\n        return False", 1.0]], "cases": [["这不是XML格式的内容", false], ["<root><child>内容</child><child2>更多内容</child2></root>", true], ["<root><child 属性=\"值\">内容</child></root>", true], ["<root><child>内容</child></root><extra>多余的内容</extra>", false], ["<root><child>内容</child>", false], ["<root><child>内容</child></root>", true]]}
{"instruction": "- 以CSV格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否每行有相同数量的逗号\n    lines = response.split('\\n')\n    num_commas = lines[0].count(',')\n    for line in lines:\n        if line.count(',') != num_commas:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否以CSV格式输出\n    lines = response.split('\\n')\n    for line in lines:\n        if ',' not in line:\n            return False\n    return True", 1.0]], "cases": [["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\\nCharlie,35,Chicago", true], ["name;age;city\nAlice;30;New York\nBob;25;Los Angeles", false], ["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles", true], ["name;age;city\\nAlice;30;New York\\nBob;25;Los Angeles", false]]}
{"instruction": "- 以CSV格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否每行有相同数量的逗号\n    lines = response.split('\\n')\n    num_commas = lines[0].count(',')\n    for line in lines:\n        if line.count(',') != num_commas:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否以CSV格式输出\n    lines = response.split('\\n')\n    for line in lines:\n        if ',' not in line:\n            return False\n    return True", 1.0]], "cases": [["name;age;city\nAlice;30;New York\nBob;25;Los Angeles", false], ["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\\n", true], ["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles", true], ["name;age;city\\nAlice;30;New York\\nBob;25;Los Angeles", false]]}
{"instruction": "- 以YAML格式输出。", "eval_func": [["import yaml\n\ndef evaluate(response: str) -> bool:\n    try:\n        yaml.safe_load(response)\n        return True\n    except yaml.YAMLError:\n        return False", 1.0]], "cases": [["name: 张三\nage: 25\naddress: 北京市", true], ["name: 王五\nage: 40\naddress: 广州市\nextra: [1, 2, 3]", true], ["name: 赵六\nage: 22\naddress: 成都市\nextra: value", true], ["name: 李四\nage: 30\naddress: 上海市", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1\n- item2", false], ["name: 李四\nage: 25\naddress: 上海市", true], ["name: 张三\nage: 30\naddress: 北京市", true], ["name: 张三\nage: 30\naddress: 北京市\n- item1\n- item2", false], ["name: 王五\nage: 28\naddress: 广州市\n", true], ["name: 王五\nage: 40\naddress: 广州市\nchildren:\n  - name: 小王\n    age: 10", true]]}
{"instruction": "- 以YAML格式输出。", "eval_func": [["import yaml\n\ndef evaluate(response: str) -> bool:\n    try:\n        yaml.safe_load(response)\n        return True\n    except yaml.YAMLError:\n        return False", 1.0]], "cases": [["name: John Doe\nage: thirty\n", true], ["name: 张三\nage: 25\naddress: 北京市", true], ["name: 张三\nage: 25\naddress: 北京市\ninvalid_yaml: [1, 2, 3", false], ["name: 赵六\nage: 22\naddress: 成都市\nextra: {key: value}", true], ["name: 李四\nage: 30\naddress: 上海市", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1\n- item2", false], ["name: 王五\nage: 28\naddress: 广州市\nextra: [1, 2, 3]", true], ["name: John Doe\nage: 30\n", true], ["name: 王五\nage: 28\naddress: 广州市\n", true], ["name: 赵六\nage: 22\naddress: 成都市\nextra: [1, 2, 3]", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1: value1\n- item2: value2", false], ["name: John Doe\nage: 30\naddress: 123 Main St\n- item1\n- item2\n", false], ["name: John Doe\nage: 30\naddress: 123 Main St\n", true]]}
{"instruction": "- 以YAML格式输出。", "eval_func": [["import yaml\n\ndef evaluate(response: str) -> bool:\n    try:\n        yaml.safe_load(response)\n        return True\n    except yaml.YAMLError:\n        return False", 1.0]], "cases": [["name: 张三\nage: 25\naddress: 北京市", true], ["name: 李四\nage: 30\naddress: 上海市", true], ["name: 王五\nage: 28\naddress: 广州市", true], ["name: 赵六\nage: 22\naddress: 成都市", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1\n- item2", false], ["name: 张三\nage: 30\naddress: 北京市", true], ["name: 李四\nage: 25\naddress: 上海市\n", true]]}
{"instruction": "- 以HTML表格格式输出。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以<table>开头并以</table>结尾\n    if not response.strip().startswith('<table>') or not response.strip().endswith('</table>'):\n        return False\n    # 检查是否包含<tr>和<td>标签\n    if not re.search(r'<tr>.*?</tr>', response, re.DOTALL) or not re.search(r'<td>.*?</td>', response, re.DOTALL):\n        return False\n    return True", 0.9], ["def evaluate(response):\n    import re\n    # 检查是否以 <table> 开始并以 </table> 结束\n    if re.match(r'^<table>.*</table>$', response, re.DOTALL):\n        return True\n    return False", 0.9]], "cases": [["<table><tr><td>内容</td></tr></table><p>其他内容</p>", false], ["<table><tr><td>内容</td></tr>", false], ["<div>这是一个div，不是表格</div>", false], ["<table><tr><td>内容</td></tr></table>", true], ["表格内容<table><tr><td>内容</td></tr></table>", false], ["这不是一个HTML表格", false], ["<table><tr><td>内容</td></tr></table><p>这是一个段落</p>", true], ["<div><table><tr><td>内容</td></tr></table></div>", false], ["<table><tr><td>内容</td></tr></table>其他内容", false], ["<div><tr><td>内容</td></tr></div>", false]]}
{"instruction": "- 以HTML表格格式输出。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以<table>开头并以</table>结尾\n    if not response.strip().startswith('<table>') or not response.strip().endswith('</table>'):\n        return False\n    # 检查是否包含<tr>和<td>标签\n    if not re.search(r'<tr>.*?</tr>', response, re.DOTALL) or not re.search(r'<td>.*?</td>', response, re.DOTALL):\n        return False\n    return True", 0.9285714285714286], ["def evaluate(response):\n    import re\n    # 定义一个简单的正则表达式来检查HTML表格的基本结构\n    pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 使用正则表达式匹配输入字符串\n    match = pattern.search(response)\n    # 如果匹配成功且整个字符串都在表格标签内，则返回True\n    if match and match.group(0) == response:\n        return True\n    return False", 0.9285714285714286]], "cases": [["<table><tr><td>测试</td></tr></table>", true], ["前置内容<table><tr><td>内容</td></tr></table>", false], ["<table><tr><td>内容</td></tr></table><p>其他内容</p>", false], ["<table><tr><td>内容</td></tr>", false], ["<table><tr><td>内容</td></tr></table><table><tr><td>更多内容</td></tr></table>", false], ["其他内容<table><tr><td>测试</td></tr></table>", false], ["<table><tr><td>内容</td></tr></table>", true], ["<table><tr><td>测试</td></tr></table>其他内容", false], ["<div>内容</div>", false], ["<div>测试</div>", false], ["<table><tr><td>测试</td></tr>", false], ["<table><tr>内容</tr></table>", false], ["<table><tr><td>内容</td></tr></table>其他内容", false], ["<div><tr><td>内容</td></tr></div>", false]]}
{"instruction": "- 以HTML表格格式输出。", "eval_func": [["def evaluate(response):\n    import re\n    # 定义一个简单的正则表达式来检查HTML表格结构\n    table_pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 检查输入字符串是否匹配HTML表格结构\n    if table_pattern.search(response):\n        return True\n    return False", 0.8], ["def evaluate(response):\n    import re\n    # 定义一个简单的正则表达式来检查HTML表格的基本结构\n    pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 检查response是否匹配该模式\n    if pattern.search(response):\n        return True\n    else:\n        return False", 0.8]], "cases": [["<table><tr><td>数据1</td><td>数据2</td></tr>", false], ["这是一个普通文本，不是HTML表格。", false], ["<div>不是表格</div>", false], ["前置内容<table><tr><td>内容</td></tr></table>", false], ["<table><tr><td>数据1</td><td>数据2</td></tr></table>", true], ["<table><tr><td>数据1</td></tr><tr><td>数据2</td></tr></table>", true], ["<table><tr><td>数据1</td><td>数据2</td></tr></table><div>这是表格外的div</div>", true], ["<div>这是一个div，不是表格</div>", false], ["<table><tr><td>数据1</td><td>数据2</td></tr></table>这是表格外的文本", true], ["<table><tr><td>内容</td></tr></table>这是额外的文本。", true], ["<table><tr><td>内容</td></tr></table><table><tr><td>更多内容</td></tr></table>", false], ["<table><tr><td>内容</td></tr></table>", true], ["<table><tr><td>内容</td></tr></table><table><tr><td>另一个表格</td></tr></table>", true], ["<table><tr><td>内容</td></tr></table>额外内容", false], ["<div>这是一个div，不是表格。</div>", false]]}
{"instruction": "- 以Markdown表格格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔符行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 0.9090909090909091]], "cases": [["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2", false], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 | 数据3 |", false], ["| 头1 | 头2 |\n| --- | --- |\n数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |\n", true], ["头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2\n数据3 | 数据4", false]]}
{"instruction": "- 以Markdown表格格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔符行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if '|' not in header or '|' not in separator:\n        return False\n    # 检查分隔符行是否有效\n    for char in separator:\n        if char != '|' and char != '-' and char != ' ':\n            return False\n    # 检查每一行是否包含相同数量的列\n    num_columns = header.count('|')\n    for line in lines[1:]:\n        if line.count('|') != num_columns:\n            return False\n    return True", 0.9]], "cases": [["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4", false], ["头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2", false], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |\n", true], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4", false], ["| 头1 | 头2 |\n| --- | --- |\n数据1 | 数据2 |\n| 数据3 | 数据4 |", false]]}
{"instruction": "- 以Markdown表格格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔符行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 1.0]], "cases": [["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", true], ["列1 | 列2\n--- | ---\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4", false], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2\n| 数据3 | 数据4 |", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2\n数据3 | 数据4", false]]}
{"instruction": "回答必须以问句形式结束，并用半角问号“？”。", "eval_func": [["def evaluate(response):\n    return response.endswith(\"？\") and any(char.isalnum() for char in response)", 1.0]], "cases": [["这个表达式结束吗?", false], ["这应该没有以问号结束。", false], ["正确的例子？", true], ["这句话不是以半角问号结尾。", false], ["这是一个问题吗？", true]], "back_instruction": ["回答必须是一个疑问句，并且至少包含一个字母或数字。"], "nli_scores": ["entailment"]}
{"instruction": "回答需要包含至少三个用中文括号包裹的数字序列号，如（一）、（二）、（三）。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the regular expression pattern to match sequences of Chinese numerals in parentheses\n    pattern = re.compile('（[一二三四五六七八九十百千万]+）')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'（[一二三四五六七八九十百千万]+）')\n    matches = pattern.findall(response)\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    # 匹配至少三个用中文括号包裹的数字序列号\n    pattern = re.compile(r'（[一-龥]）')\n    matches = pattern.findall(response)\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0], ["import re\n\ndef evaluate(response):\n    # Define the pattern to match Chinese-bracketed sequences\n    pattern = re.compile(r'（[一二三四五六七八九十]+）')\n\n    # Find all matches in the response\n    matches = pattern.findall(response)\n\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0]], "cases": [["仅有两个序列号（一）和（二），不够。", false], ["这里有四个数字序号（一）、（二）、（三）、（四），超出要求。", true], ["这是一个例子（一）、（二）和（三），它符合要求。", true]], "back_instruction": ["回答中必须包含至少三组用中文括号括起来的中文数字。", "回答中必须包含至少三组用中文括号括起来的中文数字。", "回答中必须包含至少三个用中文括号包裹的中文字符。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "在回答中使用至少有三项的复选框列表，用markdown格式表示，如 `- [ ] 项1`。", "eval_func": [["def evaluate(response):\n    # split the string by lines to process them individually\n    lines = response.split('\\n')\n    checklist_count = 0 # Variable to count the number of checklist items\n    for line in lines:\n        # Check if the line starts with the markdown for a checkbox\n        if line.startswith('- [ ] '):\n            checklist_count += 1\n    # Return True only if there are at least three checklist items\n    return checklist_count >= 3", 1.0], ["def evaluate(response):\n    # Check if there are at least three checkbox items in markdown format\n    lines = response.strip().split('\\n')\n    checkbox_count = 0\n\n    # Iterate through each line to count markdown checkboxes\n    for line in lines:\n        if line.startswith('- [ ] '):\n            checkbox_count += 1\n\n    # Evaluate if there are at least three checkboxes\n    return checkbox_count >= 3", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    checkbox_count = 0\n    for line in lines:\n        if line.strip().startswith('- [ ] '):\n            checkbox_count += 1\n    return checkbox_count >= 3", 1.0], ["def evaluate(response):\n    required_prefix = '- [ ] '\n    lines = response.split('\\n')\n    checkbox_count = 0\n    for line in lines:\n        if line.startswith(required_prefix):\n            checkbox_count += 1\n    return checkbox_count >= 3", 1.0], ["def evaluate(response):\n    checkbox_lines = response.strip().split('\\n')\n    checkbox_count = 0\n    for line in checkbox_lines:\n        if line.startswith('- [ ] '):\n            checkbox_count += 1\n    return checkbox_count >= 3", 1.0]], "cases": [["- [ ] 项目1\n- [ ] 项目2\n- [ ] 项目3", true], ["- [ ] 项目1\n- [ ] 项目2", false]], "back_instruction": ["提供至少三个需要勾选的清单项目。", "提供至少三个使用markdown格式的待勾选清单项。", "确保回答中至少包含三个格式正确的待勾选清单项。"], "nli_scores": ["entailment", "entailment", "neutral"]}
{"instruction": "回答回答中的URL必须用尖括号包裹，如<http://example.com>。", "eval_func": [["def evaluate(response):\n    import re\n    # This regular expression matches URLs enclosed in angle brackets\n    # The pattern will match a string that starts with <http:// or <https://\n    # followed by any characters (non-greedy), and then ends with >\n    pattern = re.compile(r'<https?://.*?>')\n    # Find all the matches in the input string\n    matches = pattern.findall(response)\n    # Removing all matches from the response to see if any URLs are left without brackets\n    for match in matches:\n        response = response.replace(match, '')\n    # Check if there are any URLs left in the response\n    # This pattern checks for URLs not enclosed in angle brackets\n    leftover_urls = re.compile(r'https?://')\n    if leftover_urls.search(response):\n        return False\n    return all(match.startswith('<http') and match.endswith('>') for match in matches)", 1.0]], "cases": [["全部正确的范例：<http://example.com>和<https://example.org>。", true], ["这个回答中的URL没有用尖括号包裹 http://example.com 应该返回False。", false], ["这是一个规范的回答<http://example.com>，完全符合要求。", true]], "back_instruction": ["答案中包含的URL必须用尖括号括起来。例如，应该是<http://example.com>这样的格式，而且保证文本中不包含未用尖括号括起来的URL。"], "nli_scores": ["entailment"]}
{"instruction": "回答必须包含至少一个用等号 = 表示的数学表达式。", "eval_func": [["def evaluate(response):\n    return '=' in response and any(char.isdigit() for char in response.split('=')[0]) and any(char.isdigit() for char in response.split('=')[1])", 1.0], ["def evaluate(response: str) -> bool:\n    return '=' in response and any(char.isdigit() for char in response.split('=')[0]) and any(char.isdigit() for char in response.split('=')[1])", 1.0]], "cases": [["这并不含等号的表达式。", false], ["这是一个数学表达式 5 = 5。", true], ["等号在这里=，但是两边没有数字。", false]], "back_instruction": ["在您的回答中至少包含一个等号'='，且等号两边各至少有一个数字。", "在您的答案中，请确保至少有一个等号'='，并且等号前后各至少有一个数字。"], "nli_scores": ["neutral", "entailment"]}
{"instruction": "回答的最后需要附上一个以“致谢：”开头的段落。", "eval_func": [["def evaluate(response):\n    if not response.endswith('\\n'):\n        response += '\\n'\n    sections = response.split('\\n')\n    for i in range(len(sections)-1, -1, -1):\n        if sections[i].strip():\n            return sections[i].startswith('致谢：')\n    return False", 1.0]], "cases": [["花了一个小时才找到这个终于得到了解决方案。\n致谢：感恩大家", true], ["您好，请您查看我的回复。\n致谢：", true], ["感谢您的回复，我已经修改了那个错误。致谢：这里没有换行", false]], "back_instruction": ["请以'致谢：'开头的方式，回答问题，并确保这是回答中的最后一部分内容。"], "nli_scores": ["entailment"]}
{"instruction": "回答中的每个段落开头必须使用四个空格进行缩进。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(paragraph.startswith('    ') for paragraph in paragraphs if paragraph.strip())", 1.0]], "cases": [["    这是正文第一段。\n这是正文第二段，但是没有进行缩进。", false], ["    这是正文第一段。\n    这是正文第二段，也遵循了规则。", true], ["这是正文第一段没有缩进。\n    这是正文第二段，但未全部遵循规则。", false]], "back_instruction": ["请确保您的回答中，每个段落都以四个空格开头。", "请确保您的回答中，只要段落包含非空白字符，它就应以四个空格开头。"], "nli_scores": ["entailment", "entailment"]}
{"instruction": "在回答的结尾列出“参考资料：”并用星号 * 表示列表项。", "eval_func": [["def evaluate(response):\n    if not response.endswith('参考资料：'):\n        return False\n\n    lines = response.split('\\n')\n    references_index = -1\n    for i, line in enumerate(lines):\n        if '参考资料：' in line:\n            references_index = i\n            break\n\n    if references_index == -1:\n        return False\n\n    for line in lines[references_index+1:]:\n        if not line.startswith('* '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if '参考资料：' in response and response.strip().endswith('参考资料：'):\n        lines = response.split('\\n')\n        if len(lines) > 1 and all(line.strip().startswith('*') for line in lines if '参考资料：' not in line):\n            return True\n        else:\n            return False\n    return False", 1.0], ["def evaluate(response):\n    # Check if the response ends with a reference list following the pattern\n    if response.endswith('\\n'):\n        response = response[:-1]\n    ref_section = response.split('\\n')[-1]\n    # Check if the reference section starts with the correct prefix\n    if not ref_section.startswith('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):\n        return False\n    # Check if each item in the reference list starts with an asterisk followed by a space\n    ref_items = ref_section[len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):].split('\\n')\n    for item in ref_items:\n        if not item.startswith('* '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if not response.strip().endswith('参考资料：'):\n        return False\n    last_line_index = response.rfind('\\n')\n    if last_line_index == -1:\n        return False\n    reference_header = response[last_line_index + 1:].strip()\n    if reference_header != '参考资料：':\n        return False\n    list_items = response[:last_line_index].strip().split('\\n')\n    list_items = [item for item in list_items if item.strip() != '']\n    if not all(item.strip().startswith('*') for item in list_items):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Check if '参考资料：' exists at the end of the string before any lists\n    reference_index = response.rfind('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A')\n    if reference_index == -1 or reference_index + len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A') != len(response.strip()) - 1:\n        return False\n\n    # Verify if the lines after '参考资料：' are formatted as list items with asterisks\n    list_items = response[reference_index + len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):].strip().split('\\n')\n    for item in list_items:\n        if not item.startswith('* '):\n            return False\n    return True", 1.0]], "cases": [["正确的回答但没有参考资料。", false], ["这是另一个回答。\n参考资料：\n* 参考文献1\n错误格式的参考文献", false]], "back_instruction": ["在回答的末尾包含参考资料列表，并确保参考资料每一项都以'* '开头。", "在回答中如果包含参考资料，请确保在文本末尾，并且除了'参考资料：'本身外，每一行都以'*'开头。", "确保回答的最后部分是参考资料列表，并且每一条参考资料都以'* '开头。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答必须用圆括号包含所有出现的英文单词，例如（example）。", "eval_func": [["import re\n\ndef evaluate(response):\n    # Check if all English words are enclosed in parentheses\n    words = re.findall(r'[a-zA-Z]+', response)\n    for word in words:\n        if f'（{word}）' not in response:\n            return False\n    return True", 1.0]], "cases": [["这个函数都会（return）（True）如果所有的单词都被正确地（enclosed）。", true], ["每一个（English）（word）（is）（bracketed）。", true], ["如果这个句子有 words not in parentheses, 返回（False）。", false]], "back_instruction": ["请确保回答中所有英文单词都用圆括号括起来。"], "nli_scores": ["entailment"]}
{"instruction": "回答中包含 3 个用 markdown 的无序列表符号表示的要点，每个要点用 “-” 开头。", "eval_func": [["def evaluate(response):\n    try:\n        # Split into lines\n        lines = response.strip().split('\\n')\n\n        # Count the bullet points\n        bullet_points = [line for line in lines if line.startswith('- ')]\n\n        # Check if there are exactly 3 bullet points\n        if len(bullet_points) != 3:\n            return False\n\n        # Ensure that the bullet points are not empty and are formatted correctly\n        for point in bullet_points:\n            if len(point) <= 2 or not point[2:].strip():\n                # If the point is empty or just a dash and space, it's not valid\n                return False\n\n        # If all checks are passed, the response is correctly formatted\n        return True\n    except Exception as e:\n        # In case of any unexpected error, we consider the response not correctly formatted\n        return False", 1.0], ["def evaluate(response):\n    import re\n\n    # The regex looks for three separate list items,\n    # each starting with a dash and a space, possibly\n    # with leading and trailing whitespace.\n    bullet_points_pattern = r'^\\s*-\\s+[^\\n]+\\n(\\s*-\\s+[^\\n]+\\n){2}$'\n    match = re.match(bullet_points_pattern, response, re.MULTILINE)\n\n    # If the pattern is found, we return True, otherwise False.\n    if match:\n        return True\n    else:\n        return False", 0.8333333333333334], ["def evaluate(response):\n    # Split lines and strip whitespace\n    lines = [line.strip() for line in response.split('\\n')]\n\n    # Count the number of bullet points with '-'\n    bullet_points = sum(1 for line in lines if line.startswith('-'))\n\n    # Check if there are exactly 3 bullet points\n    return bullet_points == 3", 0.8333333333333334], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    bullet_points = [line for line in lines if line.startswith('- ')]\n    return len(bullet_points) == 3", 1.0], ["def evaluate(response):\n    # Count how many bullet points are in the response\n    bullet_points = response.strip().split('\\n')\n    count = 0\n    for item in bullet_points:\n        # Check the start of each line for a hyphen\n        if item.startswith('- '):\n            count += 1\n    return count == 3", 1.0]], "cases": [["-First point\n-Second point\n-Third point\n", false], ["- First point\n* Second point\n- Third point\n", false], ["- First point\n- Second point\n- Third point\n", true], ["- First point\n- Second point\n- Third point\n- Fourth point", false], ["- First point\n* Second point using wrong bullet\n- Third point", false], ["- First point\n- Second point\n- Third point", true]], "back_instruction": ["请以恰当的格式回答，具体要求如下：请列出恰好3个带有短横线（-）开头的项目点，确保每个项目点后均跟有内容，且不只是短横线和空格。每个项目点应占一行。", "请列出恰好3个项目点，具体格式要求如下：每个项目点以一个短横线（-）和至少一个空格开头，并且项目点之间有换行。项目点前后可以有空白字符，但项目点本身不得为空。", "请以简要的形式回答，需包含恰好3个以短横线（-）开头的项目点。请确保格式正确，每个项目点单独占一行。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答的每个部分以“主旨X”开头，并以“。”结束。", "eval_func": [["def evaluate(response):\n    parts = response.split('。')\n    # Remove empty strings if a split occurred right at the end\n    parts = [part for part in parts if part]\n    for part in parts:\n        if not part.startswith('主旨X'):\n            return False\n    return True if response.endswith('。') else False", 0.8333333333333334]], "cases": [["主旨X这是符合规则的句子。主旨X这句也是符合要求的。", false], ["环境保护很重要。主旨X我们要采取有效措施。", false], ["主旨X经济发展要与生态平衡并重。", true], ["主旨X开头但并未以句号结束", false], ["主旨X正确开头。主旨X也正确结束。", true], ["主旨X我们必须保护环境。主旨X减少资源浪费是每个人的责任。", true]], "back_instruction": ["回答时，请确保每个句子都以'主旨X'开头，并且以句号结尾。"], "nli_scores": ["neutral"]}
{"instruction": "以箭头符号“→”开始每个回答的段落。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(paragraph.startswith('→') for paragraph in paragraphs if paragraph.strip())", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('→'):\n            return False\n    return True if paragraphs else False", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('→'):\n            return False\n    return True", 1.0]], "cases": [["→ 这是遵循指示的一个段落。\n→ 这是另一个遵循指示的段落。", true], ["这个段落不以箭头开始。\n→ 但这个段落是。", false], ["→ 所有的段落都应该以箭头开始。", true]], "back_instruction": ["请用'→'作为每一段的开头。", "请以'→'作为开头，确保所有段落都遵守这个规则。", "请确保每一段都以'→'开头。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "回答中应包含至少两个用反引号\"`\"包裹的术语。", "eval_func": [["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i].strip():\n            count += 1\n    return count >= 2", 1.0], ["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i]:  # Check if the term is not just empty string\n            count += 1\n    return count >= 2", 1.0], ["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i]:\n            count += 1\n        if count >= 2:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    count = 0\n    tokens = response.split('`')\n    for i in range(1, len(tokens), 2):\n        if tokens[i]:\n            count += 1\n    return count >= 2", 1.0]], "cases": [["在Python中，`list`和`dict`是常用的数据结构。", true], ["在Python中，list和dict是常用的数据结构。", false], ["正确的回答应该有两个术语, 像这样: `术语一`和`术语二`。", true], ["这个应答包含`术语一`但是只有一个。", false], ["使用`map()`函数可以对`iterables`进行操作。", true], ["这是一个包含`术语一`和`术语二`的合格回答。", true]], "back_instruction": ["请在回答中至少使用两个非空的由反引号 (`) 分隔的项。", "请确保您的回答中有至少两个由反引号 (`) 分隔开，且非空的项。", "请在您的回答中包含至少两个非空的项，这些项需要使用反引号 (`) 分隔。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答中的每个列表项都必须以一个顺序数字和点“1.”开头。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for idx, line in enumerate(lines, 1):\n        if not line.startswith(f'{idx}.'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    for i, line in enumerate(response_lines, 1):\n        prefix = '{}.'.format(i)\n        if not line.startswith(prefix):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # first, split the response into lines\n    items = response.strip().split('\\n')\n    # check if each item follows the pattern\n    for i, item in enumerate(items):\n        # trim leading and trailing whitespace\n        item = item.strip()\n        # generate expected prefix e.g., '1.', '2.', '3.', ...\n        expected_prefix = f'{i+1}.'\n        # check if the item starts with the expected prefix\n        if not item.startswith(expected_prefix):\n            return False\n    # if all items start with the correct prefix, return True\n    return True if items else False", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    items = response.strip().split('\\n')\n\n    # Define a variable to keep track of the expected starting number\n    number = 1\n\n    # Iterate over each line in the items\n    for item in items:\n        # Check if the line starts with the expected number and a dot\n        if not item.startswith(f'{number}.'):\n            return False\n\n        # Increment the number for the next expected item\n        number += 1\n\n    return True", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for index, item in enumerate(items, start=1):\n        if not item.startswith(f\"{index}.\"):\n            return False\n    return True", 1.0]], "cases": [["1.这是第一个列表项\n2.这是第二个列表项\n3.这是第三个列表项", true], ["1. 第一项\n2. 第二项\n4.跳过数字3", false], ["1. 第一项\n2. 第二项\n3. 第三项", true], ["第一个项目没有编号\n2.这是第二个项目，但第一个没有编号", false], ["1.第一个项目开始得对\n2.第二个项目也对\n4.但是这个项目的编号错了", false], ["0. 开始错误\n1. 第一项\n2. 第二项", false]], "back_instruction": ["请以数字和句号（例如'1.'）开始每一行，行号应该从1连续递增。", "请确保每一段文字都是以一个数字加句号开头的，比如'1.'，并且这些数字是从1开始连续的。", "请以连续的数字和句号作为开头（比如'1.'，接着是'2.'，等等），请输入每行文字，并确保每行的开头都符合这个格式。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答包含一组步骤，每个步骤用 markdown 的引用格式表示，每步用“>”开头。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    if not response_lines:\n        return False\n    for line in response_lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    steps = response.strip().split('\\n')\n    for step in steps:\n        # Check if each step starts with > and is not just the > character\n        if not step.startswith('> ') or step == '> ':\n            return False\n    return True if steps else False", 1.0]], "cases": [["> Step 1\n> Step 2\n> Step 3", true], ["> Step 1\n> Step 2\n\n> Step 3", false], ["Step 1\n> Step 2\n> Step 3", false]], "back_instruction": ["回答时，请确保每行都以'> '开始，不得不带有此前缀的行。", "回答时，请确保每行都以'> '作为开头，不得出现不带这个前缀的行，并且不得只包含空格或者为空。", "回答时，请确保每一行均以'> '作为行首，不得有行不带此前缀，且回答不得为空。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "必须在回答中至少使用 3 个不同颜色的文字，用 html 标签表示，例如 `<span style=\"color:red;\">红色文字</span>`。", "eval_func": [["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class ColorCounterHTMLParser(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style' and 'color:' in attr[1]:\n                        color_value = attr[1].split(':')[1].strip().replace(';', '')\n                        self.colors.add(color_value)\n\n    parser = ColorCounterHTMLParser()\n    parser.feed(response)\n    return len(parser.colors) >= 3", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n    class ColorCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style':\n                        color_info = attr[1].split(':')\n                        if len(color_info) == 2 and color_info[0].strip() == 'color':\n                            self.colors.add(color_info[1].strip())\n\n    # Create an instance of the ColorCounter\n    parser = ColorCounter()\n    parser.feed(response)\n\n    # Check if there are at least 3 distinct colors\n    return len(parser.colors) >= 3", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n    \n    class ColorCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n            \n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style' and 'color:' in attr[1]:\n                        color_value = attr[1].split('color:')[-1].split(';')[0].strip()\n                        self.colors.add(color_value)\n                        \n    parser = ColorCounter()\n    parser.feed(response)\n    return len(parser.colors) >= 3", 1.0]], "cases": [["<span style=\"color:red;\">红色文字</span>普通文字<span style=\"color:red;\">红色文字</span>", false], ["<p><span style=\"color:red;\">Red text</span> and a <span style=\"color:green;\">green one</span> without tags</p>", false], ["<p><span style=\"color:red;\">红色文字</span><span style=\"color:red;\">还是红色</span><span style=\"color:blue;\">蓝色文字</span></p>", false], ["<span style=\"color:red;\">红色文字</span><span style=\"color:green;\">绿色文字</span><span style=\"color:blue;\">蓝色文字</span>", true], ["只有普通文字没有颜色标签", false], ["<p><span style=\"color:red;\">红色文字</span><span style=\"color:green;\">绿色文字</span><span style=\"color:blue;\">蓝色文字</span></p>", true]], "back_instruction": ["提供含有至少三种颜色的 HTML span标签样式信息。", "提供含有至少三种颜色的 HTML span标签样式信息。", "提供含有至少三种颜色的 HTML span标签样式信息。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答必须以“回答内容如下：”作为正文开始的第一句话。", "eval_func": [["def evaluate(response):\n    return response.startswith(u'回答内容如下：')", 1.0], ["def evaluate(response):\n    prefix = '回答内容如下：'\n    return response.startswith(prefix)", 1.0], ["def evaluate(response):\n    return response.startswith('\\u56de\\u7b54\\u5185\\u5bb9\\u5982\\u4e0b\\uff1a')", 1.0]], "cases": [["回答内容如下：\n详细内容在这个部分。", true], ["我的回答是：回答内容如下：这里有一些消息。", false], ["回答内容如下：这是正确赋予的回答。", true]], "back_instruction": ["您的答案应该以'回答内容如下：'作为开头。", "您的答案应该以'回答内容如下：'作为开头。", "您的答案应该以'回答内容如下：'作为开头。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中必须包含 3 个以 markdown 删除线格式表示的单词或短语，例如“~~删除线文本~~”。", "eval_func": [["def evaluate(response):\n    # Check for markdown strikethroughs\n    strikethroughs = response.count('~~')\n\n    # Each strikethrough phrase has two '~~', so we expect strikethroughs to be 6\n    if strikethroughs != 6:\n        return False\n\n    # Splitting the response to find individual strikethrough phrases\n    parts = response.split('~~')\n\n    # Counting how many valid strikethrough phrases are there\n    count_strikethrough_phrases = sum(1 for i, part in enumerate(parts) if i % 2 == 1 and part.strip())\n\n    # Return True if exactly 3 strikethrough phrases are present\n    return count_strikethrough_phrases == 3", 1.0], ["def evaluate(response):\n    import re\n    \n    # Define a regex pattern to find markdown strikethrough text\n    pattern = r'~~(.*?)~~'\n    \n    # Find all strikethrough texts in the response\n    strikethrough_texts = re.findall(pattern, response)\n    \n    # Check if there are exactly 3 strikethrough texts\n    if len(strikethrough_texts) == 3:\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    # Import regex module\n    import re\n    \n    # Define pattern to find markdown strikethrough text\n    pattern = r'~~(.*?)~~'\n    \n    # Find all strikethrough occurrences\n    strikethrough_texts = re.findall(pattern, response)\n    \n    # Check if there are exactly three strikethrough phrases\n    return len(strikethrough_texts) == 3", 1.0], ["def evaluate(response):\n    import re\n    # Count the number of markdown strikethroughs using a regular expression\n    strikethroughs = re.findall(r'~~(.*?)~~', response)\n    # Check if there are exactly three strikethrough phrases\n    return len(strikethroughs) == 3", 1.0], ["def evaluate(response):\n    import re\n\n    # Regex pattern to find markdown strikethrough text (~~text~~)\n    pattern = r'~~[^~]+~~'\n\n    # Find all occurrences of markdown strikethrough in the response\n    strikethrough_matches = re.findall(pattern, response)\n\n    # Check if there are exactly three strikethrough phrases\n    return len(strikethrough_matches) == 3", 1.0]], "cases": [["这个回答有超过三个的删除线文本：~~一~~, ~~二~~, ~~三~~, ~~四~~。", false], ["此~~回答应包含~~三个删除线格式,但它只有两个~~例子~~。", false], ["这是一个包含~~删除线文本~~的回答, 这里还有一个~~第二个例子~~以及~~第三个例子~~。", true]], "back_instruction": ["使用三个带有删除线的短语回答，每个短语需使用'~~'标记且不应包含多余的空格或其他字符。", "使用正好三个被删除线标记的短语回答，每个短语之间用'~~'符号包围。", "回答中需包含恰好三段使用'~~'标记的删除线文本。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答责备必须每个句子结束后跟一个不同的特殊字符，如“†”、“‡”、“•”等。", "eval_func": [["def evaluate(response):\n    special_chars = set(['†', '‡', '•'])\n    sentences = response.split()\n    prev_char = ''\n    for sentence in sentences:\n        if len(sentence) < 2 or sentence[-1] not in special_chars:\n            return False\n        if sentence[-1] == prev_char:\n            return False\n        prev_char = sentence[-1]\n    return True", 1.0]], "cases": [["没有特殊符号结束。这是不符合要求。", false], ["这是一个句子。†另一个句子。‡最后的句子。•", true], ["符号不正确结束句子。*", false]], "back_instruction": ["回答中的每个单词应当使用特殊字符结束，这些特殊字符包括'†', '‡', '•'，并且相邻单词不能使用相同的结束字符。"], "nli_scores": ["entailment"]}
{"instruction": "回答中的日期必须按照“YYYY-MM-DD”的格式书写。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\b(\\d{4})-(\\d{2})-(\\d{2})\\b'\n    match = re.search(pattern, response)\n\n    if match:\n        year, month, day = match.groups()\n        if int(year) > 0 and 1 <= int(month) <= 12 and 1 <= int(day) <= 31:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = '^\\d{4}-\\d{2}-\\d{2}$'\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile('^(\\d{4}-\\d{2}-\\d{2})$')\n    return bool(pattern.match(response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n    if pattern.match(response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["March 25, 2023", false], ["2023/03/25", false], ["2023-03-25", true]], "back_instruction": ["回答中包含一个符合格式的日期（格式为YYYY-MM-DD，年份必须大于0，月份在1到12之间，日期在1到31之间）。", "回答必须严格符合日期格式YYYY-MM-DD，不能包含其他字符。", "回答必须严格是一个符合格式的日期（YYYY-MM-DD）。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "每个要点需用圆括号括起来并加粗，如**(要点)**。", "eval_func": [["def evaluate(response: str) -> bool:\n    import re\n    # Regular expression to match bold parentheses pattern\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Split the response by the bold parentheses, if the split result doesn't\n    # have empty strings (or only contains the bold parentheses patterns),\n    # then the response didn't strictly follow the instruction.\n    split_response = pattern.split(response)\n    if any(not pattern.match(part) and len(part.strip()) > 0 for part in split_response):\n        return False\n    # Check if all the bold patterns are strictly (要点)\n    for match in pattern.findall(response):\n        if match != '**(要点)**':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern to find all instances that match the instruction\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Replace the matches to see if any text remains unformatted\n    unformatted_parts = pattern.sub('', response).strip()\n    # The response follows the instruction if all text is wrapped as specified and nothing remains unformatted\n    return all('(' in match and ')' in match for match in matches) and not unformatted_parts", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to check the instruction\n    pattern = r'\\*\\*\\([^\\)]+\\)\\*\\*'\n    items = re.findall(pattern, response)\n\n    # Split the string by the found items\n    split_parts = re.split(pattern, response)\n\n    # Check if all parts that are split out do not contain any unformatted key point\n    # This assumes that key points are all in Chinese characters, though it may match other characters in a similar range.\n    all_parts_valid = all(not re.search(r'[\\u4e00-\\u9fff]+', part) for part in split_parts)\n\n    # True if all the found items are strictly following the instructions and all other parts are valid\n    return bool(items) and all_parts_valid", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern to match the instruction\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Find all occurrences that match the pattern\n    matches = pattern.findall(response)\n    # Extract text between '**(' and ')**'\n    contents = [m[3:-3] for m in matches]\n    # Check for any non-matching parts of the response\n    split_response = pattern.split(response)\n    for part in split_response:\n        if part.strip():  # Checks if there is any text outside the bold parenthesis\n            return False\n    # Check if all required parts are within the bold parenthesis\n    return all('**(' in response and ')**' in response for point in contents)", 1.0]], "cases": [["**(要点)** 及另一点", false], ["**(要点)** 和 **( )**", false]], "back_instruction": ["在答案中只使用用双星号加括号强调的要点。举例来说，您的回答应该只包含这样的内容：**（要点）**。", "在答案中全部使用双星号加括号的方式来强调您的要点。举例：回答里的文字都应该被这样格式化**（要点）**，而且之外不能有其他未按此方式格式化的文本。", "确保您的回答中，所有的要点都使用了双星号加括号的格式来强调，比如**（要点）**。此外，文本中不包含任何未经格式化的要点。"], "nli_scores": ["entailment", "neutral", "neutral"]}
{"instruction": "回答必须在结尾包含签名“敬上”，最后一行。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    return lines[-1].strip() == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    return lines[-1] == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    last_line = lines[-1].strip()\n    return last_line == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    return lines[-1].strip() == '敬上'", 1.0]], "cases": [["这里是我的回答。\n敬上", true], ["这是另一个回答但不符合要求。", false], ["敬上\n本来应该在最后一行，但规则未被遵循。", false]], "back_instruction": ["请确保您的回答以'敬上'结尾，且'敬上'前没有多余的空格。", "请确保您的回答以'敬上'结尾。", "请在回答中包括至少一行内容，并确保最后一行是'敬上'，且'敬上'前没有多余的空格。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中需要包含至少2个内链，格式为[链接文字](URL)。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find markdown links\n    pattern = re.compile(r'\\[[^\\]]+\\]\\([^)]+\\)')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Check if there are at least two links\n    return len(matches) >= 2", 1.0], ["def evaluate(response):\n    import re\n    # Define a regex pattern to find markdown links\n    pattern = r'\\[([^\\]]+)\\]\\((https?:\\/\\/[a-zA-Z0-9./]+)\\)'\n    # Use re.findall to get all the links in a list\n    links = re.findall(pattern, response)\n    # Check if there are at least 2 links\n    return len(links) >= 2", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\[([^\\]]+)\\]\\((https?://[^\\)]+)\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 2", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r'\\[.*?\\]\\(http?s://.*?\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 2", 1.0]], "cases": [["只有一个内链[链接文字](https://example.com)是不足够的", false], ["这是第一个内链[链接文字](https://example.com)和第二个内链[另一个链接](https://example.org)", true], ["多个内链但不符合格式如此: 链接文字(https://example.com), [链接文字]https://example.com", false]], "back_instruction": ["在答案中至少包含两个Markdown格式的链接。", "在答案中至少包含两个Markdown格式的链接。", "在答案中至少包含两个Markdown格式的链接。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答的每个要点前必须使用单破折号，如“- 要点内容”。", "eval_func": [["def evaluate(response):\n    points = response.strip().split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True if points else False", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = [point.strip() for point in response.split('\\n') if point]\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 0.8333333333333334]], "cases": [["- 要点一\n- 要点二\n-要点三", false], ["-要点一\n- 要点二\n - 要点三", false], ["第一个要点\n- 第二个要点\n- 第三个要点", false], ["- 要点一\n- 要点二\n- 要点三", true], ["- 第一个要点\n - 第二个要点\n- 第三个要点", false], ["- 第一个要点\n- 第二个要点\n- 第三个要点", true]], "back_instruction": ["回答时请使用项目列表格式，每个观点用短横线“-”开头。", "请使用项目列表格式回答，如果没有内容则视为错误。", "请确保你的回答是项目列表格式，每个项目都要以短横线“-”开头。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答中的每段开头需要使用四个空格缩进。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    return all(line.startswith('    ') or line == '' for line in lines)", 1.0], ["def evaluate(response):\n    # Split the response by newlines to handle each paragraph\n    paragraphs = response.split('\\n')\n    # Check if each paragraph begins with four spaces\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '): # Checks for four spaces\n            return False\n    return True", 1.0]], "cases": [["This is not correctly indented.\n    This one is correct.", false], ["    Only the first line is correct.\nNot this one.", false], ["    This is a correctly indented paragraph.\n    This one is correct as well.", true]], "back_instruction": ["回答时，请确保每一段的开头都是四个空格。", "回答时，请确保每一行要么以四个空格开头，要么为空行。", "回答时，请确保每一段的开头都是四个空格。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "回答的每个主要部分下面都必须有一个以半角分号结尾的小结，如“这是小结；”。", "eval_func": [["def evaluate(response):\n    # split the response into major parts using a full-stop followed by a newline character\n    parts = response.split('\\n')\n    # check that each major part has a semicolon-terminated summary\n    for part in parts:\n        if not part.strip().endswith(';'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sections = response.split('\\n')\n    for section in sections:\n        parts = section.split('；')\n        if len(parts) < 2 or parts[-1].strip() != '':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into sections\n    sections = response.split('、') # U+3001 is the codepoint for the Chinese comma used to separate sections\n    for section in sections:\n        # Check if the section ends with a semicolon\n        if not section.strip().endswith(';'):\n            return False\n\n    # If all sections have a semicolon at the end, the instruction is followed\n    return True", 1.0], ["def evaluate(response):\n    sections = response.split('、')\n    if not sections or '' in sections:\n        return False\n    return all(section.strip().endswith(';') for section in sections)", 1.0]], "cases": [["这是第一部分的内容。\n这是小结；\n这是第二部分的内容\n这是小结；", false], ["这是第一部分的内容。\n这是小结。\n这是第二部分的内容。\n这是小结；", false]], "back_instruction": ["请以句号加换行符分隔回答的各个主要部分，并确保每个部分的末尾都有分号终结。", "请用中文顿号分隔您的回答，每个部分后应没有多余的内容。", "请用中文顿号分隔您的回答的各个部分，并确保每个部分的末尾都有分号终结。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中不得包含任何形式的加粗格式。", "eval_func": [["def evaluate(response):\n    if '**' in response or '__' in response:\n        return False\n    return True", 1.0], ["def evaluate(response):\n    return '**' not in response and '__' not in response", 1.0]], "cases": [["这是一个没有加粗文字的回答", true], ["这是一个有__加粗__格式的例子", false], ["这是一个有**加粗**文字的回答", false]], "back_instruction": ["在回答中不要使用包含两个连续星号或两个连续下划线的词语。", "确保你的回答中没有含有连续两个星号或连续两个下划线的词语。"], "nli_scores": ["neutral", "neutral"]}
{"instruction": "回答必须以问句结束，且用斜体书写，例如“*这是否解决了您的问题？*”。", "eval_func": [["def evaluate(response):\n    if not response.endswith('？*'):\n        return False\n    if not response.startswith('*'):\n        return False\n    if not ('*' in response[1:-2]) and not response[-3].isdigit():\n        return True\n    return False", 1.0]], "cases": [["*这真的能够帮到您吗？*", true], ["这是否解决了您的问题？", false], ["*这是否解决了您的问题？*", true]], "back_instruction": ["回答必須以星號開頭和以'？*'結尾，且在開頭的星號與結尾的'？*'之間不含有星號並且倒數第三個字符不是數字。"], "nli_scores": ["entailment"]}
{"instruction": "每段回答中必须包含并突出显示一个主要名词，使用 markdown 加粗语法，例如“**主要名词**”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define a regular expression pattern for markdown bold syntax\n    pattern = re.compile(r'\\*\\*(.*?)\\*\\*')\n    # Find all occurrences of the markdown bold syntax in the response\n    bold_phrases = pattern.findall(response)\n    # Check if there is exactly one bold phrase and it is a noun\n    if len(bold_phrases) == 1:\n        # Simplified check: Assume any single word in bold is a noun\n        return True if re.match(r'^[一-龥]+$', bold_phrases[0]) else False\n    return False", 1.0]], "cases": [["重要的概念需要用粗体标注，例如我们可以使用**Concept**来突出。", false], ["一般来说，我们可以在句子中找到名词。", false], ["在这篇文章中，我们重点关注了**名词**的使用。", true]], "back_instruction": ["在回答中使用粗体标记（用两个星号包裹）准确标出一个名词。"], "nli_scores": ["entailment"]}
{"instruction": "回答中包括三个二级标题，使用 markdown 语法编写，格式为 `## 标题`。", "eval_func": [["def evaluate(response):\n    try:\n        # Split the response into lines\n        lines = response.strip().split('\\n')\n        # Check if there are three lines that start with '## ' (markdown for secondary heading)\n        secondary_headings = [line for line in lines if line.startswith('## ')]\n        # Return True if there are exactly three secondary headings; Otherwise return False\n        return len(secondary_headings) == 3\n    except Exception as e:\n        return False", 1.0], ["def evaluate(response):\n    # Count the number of level-2 headings in the response using markdown syntax\n    count_headings = response.count('## ')\n\n    # Check if there are exactly three level-2 headings\n    return count_headings == 3", 1.0], ["def evaluate(response):\n    subheading_lines = [line.strip() for line in response.split('\\n') if line.strip().startswith('## ')]\n    if len(subheading_lines) != 3:\n        return False\n    for line in subheading_lines:\n        if len(line) < 4 or line[2] != ' ':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # This will match two hashtags followed by a space and then any character except a newline\n    pattern = r'## .+'\n    # Find all occurrences of the pattern\n    matches = re.findall(pattern, response)\n    # Check if there are exactly three matches\n    return len(matches) == 3\n\nimport re", 1.0], ["def evaluate(response):\n    subheadings = response.split('\\n')\n    subheading_count = 0\n    for line in subheadings:\n        if line.startswith('## '):\n            subheading_count += 1\n    return subheading_count == 3", 1.0]], "cases": [["Here is some text.\n\n## First Heading\nMore text.\n## Second Heading\nEven more text.\n## Third Heading\nEnd of text.", true], ["## First Heading\nSome text.\n## Second Heading\nSome more text.\nLast text without heading.", false], ["## 1. First Heading\nContent under the first heading.\n\n## 2. Second Heading\nContent under the second heading.\n\n## 3. Third Heading\nContent under the third heading.", true]], "back_instruction": ["请在您的回答中正确使用 Markdown 语法添加三个二级标题。", "请确保您的回答中恰好包含三个使用 Markdown 语法格式化的二级标题。", "请在您的回答中使用 Markdown 语法格式化，并确保有三个格式正确的二级标题。"], "nli_scores": ["neutral", "neutral", "entailment"]}
{"instruction": "回答中每个段落的首字母必须为大写。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # Skip empty paragraphs\n            continue\n        if not paragraph[0].isupper():  # Check the first character\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # empty paragraph, skip or consider it valid\n            continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph: continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0]], "cases": [["this should fail.\nBecause the first paragraph does not start with an uppercase letter.", false], ["First paragraph is fine.\nsecond paragraph starts with lowercase.", false], ["this starts with a lowercase letter.\\nThis one starts with uppercase.", false], ["this is the first paragraph without uppercase.\nThis is the second paragraph.", false], ["This is a test.\nEvery paragraph starts with an uppercase letter.\nDoes it follow the rule?", true], ["This is the first paragraph.\nAnd this is the second one.\nFinally, this is the third paragraph.", true], ["This is a test.\\nEach paragraph starts with a capital letter.\\nAll rules followed.", true]], "back_instruction": ["回答时，请确保每个段落的首字母都是大写的。", "回答时，请确保每个段落的首字母都是大写的。", "回答时，请确保每个段落的首字母都是大写的。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "如果回答含有代码，每一行代码需要有相应的缩进，采用四个空格表示。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        # Skip empty lines or lines not starting with code\n        if not line or line.lstrip() == line:\n            continue\n        # Check if the line starts with four spaces for indentation\n        if not line.startswith('    '):\n            return False\n        # Check if rest of the code (if any) after the initial indent doesn't have any bad indentation\n        code_after_indent = line[4:]\n        if code_after_indent.startswith(' '):\n            return False\n    return True", 0.8]], "cases": [["这里有非法的缩进：\n  只有两个空格", false], ["这是一行代码。\n这是没有缩进的代码行，应该返回False。", false], ["这是一段文本。\n    这是一行代码。\n    还有一行代码。", true], ["    这行正确，但下面的不行：\n\t使用了Tab而非空格", false], ["这是一条指令：\n    正确的缩进代码行\n    又一行正确缩进的代码", true]], "back_instruction": ["回答时，请确保每一行代码都应该使用四个空格缩进，而且在缩进之后的代码不应该有不正确的缩进。"], "nli_scores": ["entailment"]}
{"instruction": "回答中引用的所有链接必须采用 markdown 内联链接的格式 `[链接文本](链接地址)`。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find markdown links\n    pattern = r'\\[.*?\\]\\(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\\)'\n    # Find all markdown links in the response\n    markdown_links = re.findall(pattern, response)\n\n    # Split response into segments outside of markdown links\n    segments = re.split(pattern, response)\n\n    # Check segments that are not markdown links for the presence of URLs\n    url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n    for segment in segments:\n        if re.search(url_pattern, segment):\n            # If a URL is found outside a markdown link, return False\n            return False\n\n    # If no URLs found outside markdown links, return True\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    # Regular expression for markdown links\n    markdown_link_pattern = re.compile(r'\\[([^\\]]+)\\]\\((http[s]?://[^\\)]+)\\)')\n\n    # Find all markdown links in the response\n    markdown_links = markdown_link_pattern.findall(response)\n\n    # Find all href links in the response\n    href_links_pattern = re.compile(r'<a href=\"[^\"]+\">[^<]+</a>')\n    href_links = href_links_pattern.findall(response)\n\n    # The response is valid only if there are no href links\n    # and if all links are in markdown format\n    return not href_links and len(markdown_links) == response.count('http')", 1.0]], "cases": [["沒有使用任何链接的文本。", true], ["這是一個正確格式的範例：[Google](http://www.google.com)。", true], ["This is a correct link: [Google](http://google.com).", true], ["This is an incorrect link format: <a href=\"http://google.com\">Google</a>.", false], ["Multiple links can be included like [Bing](http://bing.com) and [Yahoo](http://yahoo.com), as long as they are correct.", true], ["這是一個錯誤格式的範例：[Google]http://www.google.com。", false]], "back_instruction": ["在回答中可以插入Markdown链接，但请确保文本中没有Markdown链接格式之外的URL。", "您的回答只应当包含Markdown格式的链接，并且不应当包含任何HTML的超链接标签（a标签）。"], "nli_scores": ["entailment", "neutral"]}
{"instruction": "每个数据点或实例在回答中必须有单独的一段解释，解释前用 `>>` 标明。", "eval_func": [["def evaluate(response):\n    segments = response.strip().split('\\n')\n    if not all(segment.startswith('>>') for segment in segments):\n        return False\n    explanation_segments = [seg[2:].strip() for seg in segments if seg.startswith('>>')]\n    if not all(explanation_segments):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by newlines\n    parts = response.strip().split('\\n')\n    \n    for part in parts:\n        # Check if each part starts with '>>'\n        if not part.startswith('>>'):\n            return False\n        # Check if there's an explanation after '>>'\n        explanation = part[2:].strip()\n        if not explanation:\n            return False\n    \n    # Check if there's at least one data point or instance with an explanation\n    return bool(parts)", 1.0]], "cases": [[">> 第一个数据点的解释\n>> 第二个数据点的解释\n第三个数据点的解释", false], [">>第一个数据点的解释\n\n>> 第二个数据点的解释\n\n>> 第三个数据点的解释", false], [">> 第一个数据点的解释\n>> 第二个数据点的解释\n>> 第三个数据点的解释", true]], "back_instruction": ["回答时请以双大于号 '>>' 开头，并确保每一行都以 '>>' 开始，且 '>>' 之后应紧跟解释文字，不能只有 '>>' 而没有解释内容。", "回答时每一部分的开头都需要是两个大于号 '>>'，并确保在 '>>' 后有相应的解释内容，且整个回答至少包含一组带有解释的数据点或实例。"], "nli_scores": ["entailment", "entailment"]}
{"instruction": "回答需要用markdown的分割线表示法在两处区分不同内容，即使用三个或以上连续的减号(---)。", "eval_func": [["def evaluate(response):\n    parts = response.split('---')\n    clean_parts = [part for part in parts if part.strip() != '']\n    return len(clean_parts) >= 3", 1.0]], "cases": [["We have two separators here, but one is not proper.\\n------\\nThis is okay.\\n- - -\\nThis is not.", false], ["Only one separator is not enough.\\n---\\nBut we need two separators.", false], ["This is the first part.\\n---\\nThis is the second part.\\n---\\nThis is the third part.", true]], "back_instruction": ["请在回答中至少使用三个由 '---' 分隔的部分，并且每个部分之间不应该只包含空格。"], "nli_scores": ["entailment"]}
{"instruction": "回答中引用语言需要用markdown的引用格式，即在每行引用的前面加上“> ”。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line and not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line.strip() == '':\n            continue\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line.strip() and not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    lines = response.split('\\n')\n    # Check each line for markdown quote format\n    for line in lines:\n        # Skip empty lines\n        if not line.strip():\n            continue\n        # Check if the line starts with '> '\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Check each line to see if it starts with \"> \" if it is non-empty\n    for line in response.split('\\n'):\n        if line and not line.startswith('> '):\n            return False\n    return True", 1.0]], "cases": [["> This is a quoted line.\n> This is another quoted line.\n\n> This is yet another quoted line.", true], ["> 引用格式正确的第一行\n\n> 引用格式正确的第二行，前面有空行", true], ["> 这是一行引用的文本。\n> 这是另一行引用的文本。", true], ["这是一行未使用正确引用格式的文本。\n> 这是一行正确引用的文本。", false], ["This line does not have the markdown.\n> This line does.", false], ["> This is a quoted line.\nThis should be quoted but is not.", false], ["> All lines are quoted correctly.\n> Even this one.\n> And this one.", true], ["> This is a line with proper markdown quote.\n> This is another properly formatted line.", true]], "back_instruction": ["请以引用块的格式（每行以'> '开头）回答，不含纯文本行。", "请以引用块的格式回答（每行以'> '开头），空行除外。", "请用引用块格式回答（每行以'> '开头），忽略空行和未加引用的行。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中出现的数字列表需要交替使用圆点和短横线，首个使用圆点。", "eval_func": [["def evaluate(response):\n    numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    pattern = [True, False]  # True for circle, False for hyphen\n    idx = 0\n\n    for char in response:\n        if char in numbers:\n            expected_pattern = pattern[idx % 2]\n            preceding_char = response[response.index(char) - 1] if response.index(char) > 0 else ''\n            if expected_pattern and preceding_char != '●':  # Circle not found where expected\n                return False\n            if not expected_pattern and preceding_char != '-':  # Hyphen not found where expected\n                return False\n            idx += 1\n\n    return True if idx % 2 == 0 else False", 1.0], ["def evaluate(response):\n    import re\n    # Define a regex pattern for alternating bullet and dash sequences\n    pattern = r'(?<!\\d)(\\d+\\u2022(\\d+-)?)+(\\d+)?(?=\\D|$)'\n    # Find all occurrences of the pattern\n    all_matches = re.findall(pattern, response)\n    # Flatten the matches and filter out empty strings\n    matches = [item for sublist in all_matches for item in sublist if item != '']\n    # Split the response into segments by non-digit, non-bullet, non-dash characters\n    segments = re.split(r'[^0-9\\u2022-]+', response)\n    # Filter out empty segments\n    segments = [segment for segment in segments if segment]\n\n    # Check if the segments match the matches exactly\n    return matches == segments", 1.0], ["def evaluate(response):\n    symbols = iter(['\\u2022', '-'])\n    current_symbol = next(symbols)\n    previous_was_digit = False\n    for char in response:\n        if char.isdigit():\n            if previous_was_digit:\n                continue\n            previous_was_digit = True\n        else:\n            if previous_was_digit:\n                if char != current_symbol:\n                    return False\n                current_symbol = next(symbols, None) if current_symbol else '\\u2022'\n            previous_was_digit = False\n    return True", 1.0]], "cases": [["请参考以下数列：8- 7• 6- 5• 4-", false], ["1.2-3.4-5.6", false], ["14-15.16.17-18", false], ["数字序列：0• 1- 2• 3- 不符合要求", false]], "back_instruction": ["回答中的数字后必须严格按照圆圈和连字符的交替模式出现，圆圈用'●'表示，连字符用'-'表示。例如，数字1后面应该跟一个'●'，然后是另一个数字，然后是一个'-'，以此类推。不符合这一模式的回答将视为错误。", "回答中数字与圆圈和连字符的序列必须严格交替出现，且必须满足特定的正则表达式模式。圆圈用'●'表示，连字符用'-'表示。序列外的其他字符（非数字、非圆圈、非连字符）会分割这些序列。只有当序列与模式完全匹配时，回答才算正确。", "在回答中，数字必须与圆圈'●'和连字符'-'交替出现。每当一个数字出现后，它后面必须紧跟指定的符号。第一个数字后面应该是圆圈，然后是下一个数字，随后是连字符，以此类推。如果在数字后没有正确的符号，则回答视为错误。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答应包含至少三个带下划线的单词或短语，如“_例子_”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\b_+[^_]+_\\b'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 3", 1.0]], "cases": [["这只有两个带下划线的词，比如_示例_和_测试_。", false], ["我的答案是：_1_，_2_，_3_。", true], ["这个回答只有_two_个带下划线的词。", false], ["在句子中使用下划线，例如 _这个_、_示例_ 以及 _单词_ 是正确的。", true]], "back_instruction": ["在回答中至少使用三个由下划线（_）包围的词。"], "nli_scores": ["entailment"]}
{"instruction": "回答要求末尾加上版权声明，格式：“版权所有，未经许可不得转载。”。", "eval_func": [["def evaluate(response):\n    copyright_statement = \"版权所有，未经许可不得转载。\"\n    return response.endswith(copyright_statement)", 1.0], ["def evaluate(response):\n    copyright_notice = '版权所有，未经许可不得转载。'\n    return response.endswith(copyright_notice)", 1.0], ["def evaluate(response):\n    copyright_statement = '\\u7248\\u6743\\u6240\\u6709\\uff0c\\u672a\\u7ecf\\u8bb8\\u53ef\\u4e0d\\u5f97\\u8f6c\\u8f7d\\u3002'\n    return response.endswith(copyright_statement)", 1.0]], "cases": [["版权所有，未经许可不得转载。这是我的回答。", false], ["这是我的回答。版权所有，未经许可不得转载。", true]], "back_instruction": ["回答必须以'版权所有，未经许可不得转载。'结尾。", "回答必须以'版权所有，未经许可不得转载。'结尾。", "回答必须以'版权所有，未经许可不得转载。'结尾。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "在回答的末尾添加一个带有日期和时间戳的行，格式为“回答生成时间：YYYY-MM-DD HH:MM”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the pattern for the timestamp at the end of the response\n    pattern = r'\\u56DE\\u7B54\\u751F\\u6210\\u65F6\\u95F4\\uFF1A\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern at the end of the response\n    match = re.search(pattern, response)\n    if match and match.end() == len(response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\n\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    if re.search(pattern, response):\n        return True\n    else:\n        return False", 0.8888888888888888], ["def evaluate(response):\n    import re\n    # Define the regex pattern to match the date-time stamp at the end of the response\n    pattern = r'\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern in the response\n    match = re.search(pattern, response)\n    # Check if there is a match and if it is placed at the end\n    if match and match.span()[1] == len(response):\n        return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    # Define the regular expression pattern to check for the timestamp\n    pattern = r'\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern at the end of the response\n    if re.search(pattern, response):\n        # Split the response into lines\n        lines = response.split('\\n')\n        # Check if the last line matches the pattern\n        if re.match(pattern, lines[-1]):\n            return True\n    return False", 0.8888888888888888]], "cases": [["这是一个回答的例子。回答生成时间：2023-03-30 12:45", true], ["这是一个回答示例。\n回答生成时间：2023-03-15 12:45", true], ["这是另一个回答样本，但没有时间戳。", false], ["这个答案没有包含正确的日期时间戳。回答生成时间：2022/03/30 12:45", false], ["这是不符合要求的回答，因为它没有时间戳。", false], ["这是一个回答示例。\n回答生成时间：2023-03-25 14:50", true], ["正确格式的答案末尾需要有一个时间戳。\n回答生成时间：2023/03/25 14:50", false], ["这是一个回答示例，但是它的时间戳不在末尾。\n回答生成时间：2023-03-15 12:45\n这是多余的文字。", false], ["答案和时间戳都正确，但是时间戳不是在最末尾。回答生成时间：2023-03-30 12:45 在这里还有文本。", false]], "back_instruction": ["请确保您的回答结尾包含格式正确的时间戳，格式为：“回答生成时间：YYYY-MM-DD HH:MM”。", "请在您的回答结尾附上时间戳，并确保其格式为：“回答生成时间：YYYY-MM-DD HH:MM”。", "请在回答末尾附上时间戳，确保它的格式正确无误，应为：“回答生成时间：YYYY-MM-DD HH:MM”，并且位于回答的最后。"], "nli_scores": ["entailment", "entailment", "neutral"]}
{"instruction": "若回答中出现专有名词或缩写，必须首次出现时在括号内标明全称，如“CPU（Central Processing Unit）”。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Regular expression pattern to find acronyms and their expansions\n    pattern = re.compile(r'([A-Za-z]+)\\s*\\(([^)]+)\\)')\n\n    # This dictionary will map acronyms to their full forms\n    acronym_dict = {}\n\n    # Find all matches of the pattern\n    matches = pattern.findall(response)\n    for acronym, full_form in matches:\n        acronym_dict[acronym] = full_form\n\n    # Split the response into words\n    words = response.split()\n\n    # Check for acronyms and their expansions\n    for word in words:\n        # Strip punctuation\n        clean_word = re.sub(r'\\W', '', word)\n        # If the word is an acronym\n        if clean_word in acronym_dict:\n            # Find the acronym's index\n            index = response.find(clean_word)\n            prev_text = response[:index]\n            # Check if the acronym has appeared before without its full form\n            if clean_word in prev_text and not acronym_dict[clean_word] in prev_text:\n                return False\n    return True", 1.0]], "cases": [["现代计算机通常包括CPU、RAM（Random Access Memory）和HDD（Hard Disk Drive）。", true], ["操作系统（OS，Operating System）是控制计算机硬件与软件资源的程序。", true], ["在CPU和GPU（Graphics Processing Unit）之间进行选择时，你需要考虑你的计算需求。", true], ["在讨论CPU时，我们应该指出CPU（Central Processing Unit）是计算机的核心。", true], ["在计算机中，CPU（Central Processing Unit）是负责解释计算机指令以及处理计算机软件中的数据。", true], ["我们需要一个有强大CPU（Central Processing Unit）的计算机。", true]], "back_instruction": ["在回答中使用缩写词时，请确保每个缩写词在首次出现时都已提供完整形式，并且缩写词不在其完整形式出现之前使用。"], "nli_scores": ["entailment"]}
{"instruction": "回答中的每个例子之前加上“例子X：”，其中X是从1开始的连续数字。", "eval_func": [["def evaluate(response: str) -> bool:\n    # Split into potential examples based on the pattern\n    examples = response.split('例子')  # This is the character sequence for '例子'\n    consecutive_number = 1\n    for example in examples[1:]:  # skip the first split as it is before any '例子'\n        # Check if the string starts with the correct consecutive number followed by '：'\n        if not example.startswith(str(consecutive_number) + '：'):  # '：' is the full-width colon\n            return False\n        consecutive_number += 1\n    return True if consecutive_number > 1 else False", 0.8], ["def evaluate(response):\n    examples = response.split('\\u4F8B\\u5B50')  # Split on the Chinese characters for 'example'\n    if not examples[0].strip():  # The string before the first '例子' should be empty\n        examples = examples[1:]  # Ignore the empty string before the first '例子'\n\n    count = 1\n    for example in examples:\n        num_and_text = example.split('：')  # Split on the Chinese character for ':'\n        if len(num_and_text) != 2:  # Each example should be split into 2 parts\n            return False\n        num, text = num_and_text\n        if not num.strip().isdigit() or int(num.strip()) != count:  # Check if the number is a digit and in sequence\n            return False\n\n        if not text.strip():  # Each example should contain text after the number and ':'\n            return False\n\n        count += 1\n\n    return True", 0.8], ["def evaluate(response):\n    examples = response.split('\\u3000')  # Split by the full-width space character\n    counter = 1\n    for example in examples:\n        prefix = f'\\u4F8B\\u5B50{counter}\\uFF1A'  # '例子X：' where X is the counter\n        if not example.startswith(prefix):\n            return False\n        counter += 1\n    return True", 0.8]], "cases": [["例子1：吃的就是坏吃的、例子2：睡的就是腰舀的", true], ["这是没有加例子前缀的话。", false], ["例子1：有趣的一点、例子2：非常有含量、例子3：玩弄有新意", true], ["例子1：状态不错、快乐样子、例子2：曲折木术路", false], ["例子１：这是第一个例子。例子３：缺少了一个例子。", false]], "back_instruction": ["请按照序号提供例子，每个例子前都使用`例子`加序号并以全角冒号`：`结束。例如：“例子1：XXXXX 例子2：XXXXX”，序号必须是连续的。", "答案须包含示例(用中文“例子”表示)，并以序号顺序排列，每个“例子”之前的部分应为空。每个示例都必须包含序号和文字，并且序号应该是连续的数字。", "在您的回答中，请使用全角空格`　`来分割每个带有“例子X：”前缀的示例，其中X是连续递增的数字。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答中的每一个列表项都需要使用圆点符号“• ”开始。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not line.startswith('• '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for item in items:\n        if not item.startswith('• '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by newline to get individual lines\n    lines = response.strip().split('\\n')\n    # Check if each line starts with the bullet point\n    for line in lines:\n        if not line.startswith('• '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for item in items:\n        if not item.startswith('• '):\n            return False\n    return True if items else False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.strip().startswith('• '):\n            return False\n    return True", 1.0]], "cases": [["• 第一项\n第二项开始没有圆点符号\n• 第三项", false], ["• Item 1\nItem 2\n• Item 3", false], ["• Item 1\n•Item 2\n• Item 3", false], ["• First item\n•Second item\n• Third item", false], ["• 第一项\n• 第二项\n• 第三项", true], ["Item 1\n• Item 2\n• Item 3", false], ["", false], ["• Item 1\n• Item 2\n• Item 3", true], ["第一项\n• 第二项\n• 第三项", false], ["First item\n• Second item\n• Third item", false], ["• First item\n• Second item\n• Third item", true], ["• 第一项\n• 第二项\n- 第三项", false]], "back_instruction": ["回答时每一行都应该以圆点符号“• ”开头。", "用列表回答，每一个条目都要以圆点符号“• ”开头。", "回答时，请确保每一行文本都以圆点符号“• ”作为开头。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答的结尾必须加上一句话“本回答已完毕。”。", "eval_func": [["def evaluate(response):\n    return response.endswith('\\u672c\\u56de\\u7b54\\u5df2\\u5b8c\\u6bd5\\u3002')", 1.0], ["def evaluate(response):\n    return response.strip().endswith('本回答已完毕。')", 1.0], ["def evaluate(response: str) -> bool:\n    # This is the required ending sentence according to the instruction\n    required_ending = '本回答已完毕。'\n    # Check if response ends with the required sentence\n    return response.endswith(required_ending)", 1.0], ["def evaluate(response):\n    return response.endswith('本回答已完毕。')", 1.0]], "cases": [["这是一个符合规定的回答。本回答已完毕。", true], ["看似遵守了，但实际上最后一句话并不符合。本回答已经完毕。", false], ["这个回答没有加上指定的结尾", false], ["本回答已完毕。但是我还有其他话要说。", false], ["本回答已完毕。但是这句话在开头。", false], ["这是一个回答的例子。本回答已完毕。", true], ["这是一个回答。本回答已完毕。", true], ["没有经过任何灰庄，那也成不上真正的勇士。本回答已完毕。", true], ["这是一个遵循指导的回答。本回答已完毕。", true], ["这个回答没有遵守指令", false], ["这个回答没有按照要求结束。", false], ["本回答已完毕。确实这样结束了。", false]], "back_instruction": ["回答必须以'本回答已完毕。'结尾。", "回答需要在去除前后空白字符后以'本回答已完毕。'结尾。", "请确保你的回答以'本回答已完毕。'作为结尾。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中必须包含至少一个由大括号{}包裹的表达式，比如{表达式}。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find at least one occurrence of expression within {}\n    pattern = re.compile(r'{[^{}]*}')\n    # Search the pattern in the response\n    match = pattern.search(response)\n    # Return True if a match is found, else return False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'{[^{}]*}'\n    matches = re.findall(pattern, response)\n    return bool(matches)", 1.0], ["def evaluate(response):\n    import re\n    # Use regex to find expressions within {}\n    pattern = re.compile(r'{[^{}]*}')\n    # Search for the pattern in the response\n    match = pattern.search(response)\n    # Check if at least one expression is found\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # The pattern checks for at least one occurrence of {expression}\n    # where 'expression' is any sequence of characters except for {} itself\n    pattern = re.compile(r'{[^{}]*}')\n    # Search for the pattern in the response\n    match = pattern.search(response)\n    # Return True if a match is found, otherwise return False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\{.*?\\}'\n    return bool(re.search(pattern, response))", 1.0]], "cases": [["这是一个包含{特定表达式}的答案。", true], ["这个回答{包含一部分}符合要求。", true]], "back_instruction": ["使用花括号{}包含的表达式至少出现一次。", "回答中必须至少出现一次使用花括号{}包裹的表达式。", "确保你的回答至少包含一个用花括号{}包裹的表达式。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中必须包含一个有顺序的列表，且使用英文字母进行编号，比如“A. XXXX； B. XXX；”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = '^((?:[A-Z]\\.\\s.*?；\\s*)+)$'\n    match = re.match(pattern, response)\n    if not match:\n        return False\n\n    items = match.group(0).split('；')\n    items = [item.strip() for item in items if item.strip() != '']\n\n    prev_ord = None\n    for item in items:\n        current_ord = ord(item[0])\n        if prev_ord is not None and current_ord != prev_ord + 1:\n            return False\n        prev_ord = current_ord\n\n    return True", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # Define the regex pattern for the sequence with English letters\n    pattern = re.compile(r'^(?:(?:(?:[A-Z]\\.[^;]+; )|(?:[A-Z]\\.[^;]+;)))+$')\n\n    # Match the pattern to the input string\n    if pattern.match(response.strip()):\n        return True\n    else:\n        return False", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    # Define a regex pattern for an ordered list with English letters and items\n    pattern = re.compile(r'^\\s*(?:[A-Z]\\.\\s*.+\\s*;\\s*)+$')\n    # Check if the response matches the pattern\n    match = pattern.match(response)\n    # Return True if a match is found, False otherwise\n    return bool(match)", 0.8333333333333334]], "cases": [["A. Apple pie; B. Banana bread; C. Carrot cake;", true], ["A. First Item； B. Second Item； C. Third Item；", true], ["1. This is incorrect; 2. It does not use letters;", false], ["1. First Item； 2. Second Item； 3. Third Item；", false], ["A. First Item B. Second Item C. Third Item", false], ["A. This is correct but there is no semicolon at the end", false]], "back_instruction": ["按照英文字母顺序提供以大写字母开始并以分号结束的句子，每个句子开头的字母必须比前一个句子开头的字母顺序增加1。", "以英文大写字母顺序提供条目，每条以分号结束；不需要按字母顺序排列。", "以英文字母大写开头的句子组成的列表，每个句子后均以分号结束。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答必须严格遵守问答格式，即每个问题后跟着答案，格式为“Q:问题？A:回答。”。", "eval_func": [["def evaluate(response):\n    import re\n    # Regex to match the strict QA format\n    pattern = r'(Q:.*?\\uFF1F\\s*A:.*?\\u3002)(Q:.*?\\uFF1F\\s*A:.*?\\u3002)*'\n    # Check if the whole response matches the format\n    return bool(re.fullmatch(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n\n    # Define the pattern for the Q&A format\n    pattern = r'(Q:.+?\\uff1fA:.+?\\u3002)'\n\n    # Split the response into segments based on the Q&A pattern\n    segments = re.findall(pattern, response)\n\n    # Join segments and compare with original response\n    return ''.join(segments) == response", 1.0]], "cases": [["Q:第二个问题？回答是这样。", false], ["Q:这是问题1？A:这是回答1。", true], ["Q:问题3？A:正确的回答例子。Q:问题4？A:又一个正确的答案。", true]], "back_instruction": ["请以严格的问答格式回答，每对问答回答应该遵循'问：...？ 答：...'的格式，并以中文问号结束问题、以中文句号结束回答。", "请确保你的答案遵守问答格式，每个问答对应该是'问：...？答：...'，且使用中文问号和句号。"], "nli_scores": ["neutral", "neutral"]}
{"instruction": "回答需要包括具体的日期，日期格式为“YYYY年MM月DD日”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\d{4}年\\d{2}月\\d{2}日'\n    match = re.search(pattern, response)\n    if match:\n        return True\n    else:\n        return False", 1.0]], "cases": [["今天是2023年03月25日。", true], ["记得2023年12月01日那天的大雨。", true], ["日期为03/25/2023。", false]], "back_instruction": ["回答中必须包含符合格式的日期，格式为'年(四位数字)月(两位数字)日(两位数字)'。"], "nli_scores": ["entailment"]}
{"instruction": "在回答的开头和结尾，分别加上 “<回答开始>” 和 “<回答结束>” 标记。", "eval_func": [["def evaluate(response):\n    return response.startswith('<回答开始>') and response.endswith('<回答结束>')", 1.0], ["def evaluate(response):\n    if not response.startswith('<回答开始>') or not response.endswith('<回答结束>'):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    start_tag = \"<回答开始>\"\n    end_tag = \"<回答结束>\"\n    if response.startswith(start_tag) and response.endswith(end_tag):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    if response.startswith('<回答开始>') and response.endswith('<回答结束>'):\n        return True\n    else:\n        return False", 1.0]], "cases": [["<回答开始>这是符合指示的回答。<回答结束>", true], ["这是不符合指示的回答。<回答结束>", false], ["<回答开始>这是不符合指示的回答。", false]], "back_instruction": ["请以'<回答开始>'开头，并以'<回答结束>'结尾回答。", "回答时请确保以'<回答开始>'作为开始，并以'<回答结束>'作为结束。", "回答必须以'<回答开始>'为起始标签，并以'<回答结束>'为结束标签。"], "nli_scores": ["entailment", "entailment", "neutral"]}
{"instruction": "回答中提及的数字必须用中文数字表示，而不能用阿拉伯数字。", "eval_func": [["def evaluate(response):\n    import re\n    # Define a function to check if there are Arabic numerals in the response\n    def has_arabic_numerals(input_string):\n        return bool(re.search(r'\\d', input_string))\n    # Define a function to check if a text includes Chinese numerals\n    def has_chinese_numerals(input_string):\n        # List of Chinese numerals for 0 to 9\n        chinese_numerals = '零一二三四五六七八九'\n        return any(char in chinese_numerals for char in input_string)\n    # Check response for Arabic numerals, which are not allowed\n    if has_arabic_numerals(response):\n        return False\n\n    # While an absence of any numerals is fine, presence of Chinese numerals would mean\n    # the instruction is satisfied, so no explicit check for their presence is needed.\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Check if the response contains Arabic numerals\n    if re.search(r'\\d', response):\n        return False\n    # Define the list of Chinese numerals\n    chinese_numerals = '零一二三四五六七八九十百千万亿兆'\n    # Check if all the numerals in the response are Chinese\n    for char in re.findall(r'\\b\\d+\\b', response):\n        if not all(num in chinese_numerals for num in char):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n\n    # Define a pattern that matches Arabic numerals (0-9)\n    # If an Arabic numeral is found, it violates the instruction\n    arabic_numeral_pattern = re.compile(r'\\d')\n\n    # Search for Arabic numerals within the response\n    if arabic_numeral_pattern.search(response):\n        # There are Arabic numerals, so it violates the instruction\n        return False\n\n    # No Arabic numerals found, it follows the instruction\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to find Arabic numbers\n    arabic_numbers_pattern = r'\\d+'\n    # Check if there are any Arabic numbers in response\n    return re.search(arabic_numbers_pattern, response) is None", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to match any Arabic numerals\n    arabic_numerals = r'\\d+'\n    # Search for Arabic numerals in the response\n    if re.search(arabic_numerals, response):\n        return False\n    # It is assumed that all Chinese numerals in the response are correct\n    # as the function only checks for the presence of Arabic numerals\n    return True", 1.0]], "cases": [["八百八十八是一个幸运数字", true], ["这个问题的答案是三", true], ["结果为42", false]], "back_instruction": ["请用不含阿拉伯数字的方式作答。", "请使用中文数字而不是阿拉伯数字回答问题，但如果回答中完全没有数字，也是可以的。", "作答时请不要使用包含阿拉伯数字的内容。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "回答包括一份清单，每个项目下面需要标注“- 完成”或“- 未完成”。", "eval_func": [["def evaluate(response):\n    response_lines = response.split('\\n')\n    if not response_lines:\n        return False\n    for line in response_lines:\n        if not line.strip():\n            continue  # Skip empty lines\n        if not (line.endswith('- 完成') or line.endswith('- 未完成')):\n            return False\n    return True", 1.0], ["def evaluate(response: str) -> bool:\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not (line.endswith('- 完成') or line.endswith('- 未完成')):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    if not lines: # Should not be empty\n        return False\n    for line in lines:\n        if not line.endswith(' - 完成') and not line.endswith(' - 未完成'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n    items = response.split('\\n')\n    if len(items) < 2:\n        return False\n    for item in items:\n        if not item.endswith('- 完成') and not item.endswith('- 未完成'):\n            return False\n    return True", 1.0]], "cases": [["项目一 - 已完成\n项目二 - 完成\n项目三 - 未完成", false], ["项目一 - 完成\n项目二 - 未完成\n项目三 - 完成", true], ["清单项目一 - 完成\n清单项目二 - 未完成\n清单项目三 - 完成", true], ["清单项目一 - 完成\n清单项目二\n清单项目三 - 未完成", false], ["项目一 - 完成\n项目二\n项目三 - 完成", false]], "back_instruction": ["回答时请确保每一行以'- 完成'或'- 未完成'结尾，并且不包含空行。", "确保您的回答中每一行都严格以'- 完成'或者'- 未完成'结尾，不要有空行。", "您的答案需包括多行，且每行结尾必须为' - 完成'或' - 未完成'，并确保没有空行。"], "nli_scores": ["entailment", "entailment", "neutral"]}
{"instruction": "如果回答中提到某个数字，数字必须用括号包围，例如“(123)”。", "eval_func": [["def evaluate(response):\n    import re\n    # Check if there are numbers not enclosed in parentheses\n    pattern = r'([^()]\\d+[^()])|(^\\d+[^()])|([^()]\\d+$)'\n    if re.search(pattern, response):\n        return False\n\n    # Confirm that all numbers are enclosed correctly\n    enclosed_numbers = re.findall(r'\\((\\d+)\\)', response)\n    for num in enclosed_numbers:\n        if not num.isdigit():\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Compiles a regular expression to find numeric characters not enclosed in parentheses\n    non_enclosed_numbers = re.compile(r'(?<!\\()\\d+(?!\\))')\n    # Find all instances where a number isn't enclosed properly\n    non_enclosed = non_enclosed_numbers.findall(response)\n    # If there are any instances, the input does not follow the instructions\n    if non_enclosed:\n        return False\n    # To ensure that numbers are correctly enclosed, all numbers must be within parentheses\n    # The following regular expression matches numbers enclosed in parentheses\n    properly_enclosed_numbers = re.compile(r'\\(\\d+\\)')\n    # Finds all properly enclosed numbers\n    properly_enclosed = properly_enclosed_numbers.findall(response)\n    # Having other characters within parentheses containing number is not allowed\n    improperly_enclosed_characters = re.compile(r'\\([^\\d]+\\d+[^\\d]+\\)')\n    improperly_enclosed = improperly_enclosed_characters.findall(response)\n    # No improperly enclosed sequences should be found\n    return len(improperly_enclosed) == 0", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression pattern to match a properly bracketed number\n    pattern = r'\\([^\\d]*(\\d+)[^\\d]*\\)'\n    # Find all occurrences of pattern\n    matches = re.findall(pattern, response)\n    # Split the response to analyze parts between matches\n    split_response = re.split(pattern, response)\n    for part in split_response:\n        # Check if any digits are found outside the matches\n        if any(char.isdigit() for char in part):\n            return False\n    return True", 0.8]], "cases": [["没有使用数字时，它(应该)返回True。", true], ["这是一个合法的回答(42)，它正确地遵守了指示。", true], ["这个回答违反了规则因为123没有被括号包围。", false], ["这个例子(123是错误的。", false], ["(1234)是被正确包围的，但这个没有(5678是错的。", false]], "back_instruction": ["回答时，请确保文中的所有数字都被正确地用一对圆括号括起来，而括号之外不得有数字。", "回答时，所有数字必须被一对圆括号所封闭。请确保圆括号中只包含数字，不要有其他字符与数字一起被圆括号所封闭。", "在回答时，所有数字符号必须位于正确的括号内。请确保回答中的每一部分，如果不是括号内的内容，则不包含任何数字。"], "nli_scores": ["entailment", "neutral", "neutral"]}
{"instruction": "在回答中每次谈到新的观点时，都要在句前加上“新观点：”作为引导。", "eval_func": [["def evaluate(response):\n    # Split the response by periods to check individual sentences\n    sentences = response.split('。')\n    for sentence in sentences:\n        # Strip whitespace and newlines for more robust checking\n        sentence = sentence.strip()\n        # Check if the sentence contains '新观点：'\n        if sentence and not sentence.startswith('新观点：'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = response.split('新观点：')\n    if len(points) < 2:\n        return False\n    if points[0].strip() != '':\n        return False\n    for point in points[1:]:\n        if '\\n' in point.splitlines()[0]:\n            return False\n        if not point.strip() or '新观点：' in point:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if point:\n            if not point.startswith('新观点：'):\n                return False\n    return True", 1.0]], "cases": [["今天天气不错。新观点：我们应该去户外活动。", false], ["新观点：今天天气不错。\n新观点：我们应该去户外活动。\n新观点：晚餐吃火锅怎么样？", true], ["新观点：今天天气不错。新观点：我们应该去户外活动。", true]], "back_instruction": ["您的答案应该只包含以'新观点：'开头的句子。", "您的答案应该以'新观点：'开头，后面跟着至少一点内容，且每一个新观点前都不能有其他文字。", "您的答案中，每个被换行符分隔的部分都应该以'新观点：'开头。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "回答中的统计图或者表格需要用markdown的图片格式表示，即![](图片链接)。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = re.compile(r'!\\[.*?]\\(.*?\\)')\n    matches = pattern.findall(response)\n    if not matches:\n        return False\n    for match in matches:\n        if not re.match(r'!\\[.*?]\\(https?://.*?\\)', match):\n            return False\n    return True", 0.8333333333333334]], "cases": [["这是我的统计图![](http://example.com/myimage.png)，可以看到详细信息。", true], ["根据最新数据，我们这里有一幅统计图展示结果，如下所示：![](http://example.com/chart.png)。", true], ["统计结果可以在下面的表格中找到：统计图![](http://example.com/myimage.png)。", false], ["如图所示，通过我们的分析![](http://example.com/graph.png)，可以看出趋势。", true], ["尽管我们尝试了不同的方法，但是统计图![](不是一个链接)表现不佳。", false], ["请查看我添加的图片![](http://example.com/myimage.png)来获取数据的视觉表示。", true]], "back_instruction": ["回答中必须包含至少一处有效的Markdown图片链接格式，且链接必须以'http://'或'https://'开头。"], "nli_scores": ["neutral"]}
