{"instruction": "- 回答中最后一句话以感叹号结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('！')", 1.0]], "cases": [["请确保最后一句话以感叹号结尾！", true], ["最后一句话是感叹号！\t", true], ["请确保最后一句话以感叹号结尾。", false], ["最后一句话是感叹号！\r\n", true], ["最后一句话是感叹号！ ", true], ["最后一句话是感叹号！\n", true], ["这是一个测试句子。", false], ["这是一个测试句子！", true]]}
{"instruction": "- 回答中最后一句话以省略号结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('...')", 1.0]], "cases": [["测试", false], ["测试...", true], ["这是一个测试。", false], ["请确保最后一句话以省略号结尾。", false], ["这是一个测试...", true], ["最后一句话以省略号结尾...", true], ["请检查这个回复是否正确", false], ["最后一句话以省略号结尾", false], ["请检查这个回复是否正确...", true], ["这是另一个测试...", true], ["请确保最后一句话以省略号结尾...", true], ["请确保最后一句话以省略号结尾", false]]}
{"instruction": "- 回答中最后一句话以问号结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('？')", 1.0]], "cases": [["这是一个测试", false], ["你喜欢编程吗？", true], ["这是一个问题。", false], ["请告诉我你的名字。", false], ["你今天过得怎么样？", true], ["这是一个问题吗？", true]]}
{"instruction": "- 回答中每个段落前加\"***\"。", "eval_func": [["def evaluate(response):\n    # 检查每个段落是否以'***'开头\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph.strip() and not paragraph.strip().startswith('***'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('***'):\n            return False\n    return True", 0.8181818181818182]], "cases": [["这是一个段落。\n***这是另一个段落。", false], ["这是唯一一段。", false], ["***这是一个段落。\n***这是另一个段落。", true], ["***这是第一段。\n***这是第二段。\n这是第三段。", false], ["***这是一个段落。\n\n\n***这是另一个段落。", true], ["***这是一个段落。\n\n***这是另一个段落。", true], ["***这是第一段。\n***这是第二段。\n***这是第三段。", true], ["***这是一个段落。\n这是另一个段落。", false], ["这是第一段。\n***这是第二段。\n***这是第三段。", false], ["***这是唯一一段。", true], ["***这是第一段。\n这是第二段。\n***这是第三段。", false]]}
{"instruction": "- 回答中每个段落前加\"+++\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('+++'):\n            return False\n    return True", 1.0]], "cases": [["+++这是第一段。\n+++这是第二段。", true], ["+++这是第一段。\n这是第二段。", false], ["+++这是第一段。\n\n+++这是第二段。", true], ["+++这是第一段。\n+++这是第二段。\n+++这是第三段。", true], ["这是第一段。\n+++这是第二段。", false]]}
{"instruction": "- 回答中每个段落前加\"|||\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('|||'):\n            return False\n    return True", 1.0]], "cases": [["这是第一段。\n|||这是第二段。\n|||这是第三段。", false], ["|||这是第一段。\n|||这是第二段。\n这是第三段。", false], ["|||这是唯一一段。", true], ["|||这是第一段。\n|||这是第二段。", true], ["|||这是第一段。\n这是第二段。\n|||这是第三段。", false], ["|||这是第一段。\n|||这是第二段。\n|||这是第三段。", true]]}
{"instruction": "- 回答中每个段落前加\"---\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('---'):\n            return False\n    return True", 1.0]], "cases": [["---这是第一段。\n---这是第二段。\n---这是第三段。", true], ["---这是第一段。\n这是第二段。\n---这是第三段。", false], ["这是第一段。\n---这是第二段。\n---这是第三段。", false], ["---这是第一段。\n---这是第二段。\n这是第三段。", false], ["---这是第一段。\n---这是第二段。\n---这是第三段。\n", true]]}
{"instruction": "- 回答字数不多于100个字。", "eval_func": [["def evaluate(response):\n    return len(response) <= 100", 1.0]], "cases": [["这是一个非常长的句子，目的是为了测试evaluate函数是否能够正确识别超过100个字的情况。我们需要继续添加更多的内容，确保这个字符串确实超过了100个字。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回False。", false], ["短句。", true], ["这是一个稍微长一点的句子，但仍然不超过100个字。我们可以通过这种方式来测试evaluate函数的准确性。", true], ["这是一个测试案例，字数不超过100个字。", true]]}
{"instruction": "- 回答字数不多于200个字。", "eval_func": [["def evaluate(response):\n    return len(response) <= 200", 1.0], ["def evaluate(response):\n    # 计算输入字符串的字数\n    word_count = len(response)\n    # 检查字数是否不多于200个字\n    return word_count <= 200", 1.0]], "cases": [["这是一个非常长的测试案例，字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达复杂的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，极大地提高了开发效率。总之，Python是一种非常优秀的编程语言，适合各种不同的应用场景。", false], ["简短的测试。", true], ["这是一个测试案例，字数不超过200个字。", true], ["这个测试案例的字数刚好是200个字。为了确保这个测试案例确实是200个字，我们需要精确地计算每一个字。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。", true], ["这是一个非常长的测试案例，字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常优秀的编程语言，适合各种类型的开发任务。", false], ["这个测试案例的字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常优秀的编程语言，适合各种类型的开发任务。", false]]}
{"instruction": "- 回答字数不少于50个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于50个字\n    if length >= 50:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这个字符串太短了。", false], ["短短的字符串。", false]]}
{"instruction": "- 回答字数不少于200个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 检查长度是否不少于200个字\n    if length >= 200:\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于200个字\n    if length >= 200:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个符合要求的测试案例。这个字符串的长度超过了200个字，因此应该返回True。为了确保字符串的长度足够长，我们可以添加一些额外的内容。比如说，我们可以描述一下Python语言的特点。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。它由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python语法简洁而清晰，具有丰富的库和强大的社区支持。Python广泛应用于Web开发、数据分析、人工智能、科学计算等领域。总之，这个字符串的长度已经超过了200个字，因此evaluate函数应该返回True。", true], ["这是一个测试案例，长度不足200个字。这个字符串的目的是为了测试evaluate函数是否能够正确识别不符合指令的情况。我们需要确保这个字符串的长度确实不足200个字，以便测试函数的准确性。", false]]}
{"instruction": "- 回答包含日期，格式为YYYY-MM-DD。", "eval_func": [["import re\n\ndef evaluate(response):\n    # 定义日期格式的正则表达式\n    date_pattern = re.compile(r'\\b\\d{4}-\\d{2}-\\d{2}\\b')\n    # 搜索是否存在符合格式的日期\n    match = date_pattern.search(response)\n    # 如果找到匹配的日期，返回True，否则返回False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配YYYY-MM-DD格式的日期\n    date_pattern = re.compile(r'\\b\\d{4}-\\d{2}-\\d{2}\\b')\n    # 查找所有匹配的日期\n    dates = date_pattern.findall(response)\n    # 如果找到至少一个匹配的日期，返回True，否则返回False\n    return bool(dates)", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配YYYY-MM-DD格式的日期\n    pattern = r'\\b\\d{4}-\\d{2}-\\d{2}\\b'\n    match = re.search(pattern, response)\n    return bool(match)", 1.0]], "cases": [["日期格式不正确：2023.10.05。", false], ["会议安排在2023/11/15。", false], ["今天是2023年10月5日。", false], ["明天是2023年10月6日。", false], ["日期格式不正确：2023.08.30。", false], ["日期格式应该是2023/10/05。", false], ["请确认2023/12/01的时间。", false], ["2023-10-5是错误的格式。", false]]}
{"instruction": "- 回答包含“大模型”这个词。", "eval_func": [["def evaluate(response):\n    return '大模型' in response", 1.0]], "cases": [["我们需要讨论更多的细节。", false], ["这个回答包含大模型这个词。", true], ["大模型是一个非常重要的概念。", true], ["在机器学习中，大模型有很多应用。", true], ["我们需要讨论一些其他的技术。", false], ["这个回答没有包含指定的词。", false]]}
{"instruction": "- 回答包含“我是AI大模型”这个词。", "eval_func": [["def evaluate(response):\n    return \"我是AI大模型\" in response", 1.0]], "cases": [["你好，我是AI大模型，可以帮助你解决问题。", true], ["AI大模型在很多领域都有应用。", false], ["我是AI大模型，欢迎向我提问。", true], ["我是AI大模型，我可以帮助你解决问题。", true], ["AI大模型在这里。", false], ["你好，我是一个AI模型，可以帮助你解决问题。", false], ["我是AI模型。", false], ["请问你是AI大模型吗？", false], ["我是AI大模型，可以为你提供帮助。", true], ["你好，我是一个AI模型。", false], ["我是AI大模型，可以回答你的问题。", true]]}
{"instruction": "- 回答包含“温馨提示”这个词。", "eval_func": [["def evaluate(response):\n    return '温馨提示' in response", 1.0], ["def evaluate(response):\n    return \"温馨提示\" in response", 1.0]], "cases": [["温馨提示：请保持安静。", true], ["请注意，这里有一些重要信息。", false], ["提示：请保持安静。", false], ["温馨提示：今天的天气很好。", true], ["温馨提示：今天的会议取消了。", true], ["这是一个温馨提示，请注意。", true], ["提示：请遵守规则。", false]]}
{"instruction": "- 回答以“谢谢！”结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('谢谢！')", 1.0]], "cases": [["谢谢！这是一个测试。", false], ["这是一个测试。", false], ["谢谢！ ", true], ["这是一个测试。谢谢！ ", true], ["谢谢！", true], ["这是一个测试。谢谢！", true], ["这是一个测试。谢谢", false]]}
{"instruction": "- 回答以“你还有什么问题吗？”结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('你还有什么问题吗？')", 0.8], ["def evaluate(response):\n    return response.strip().endswith('你还有什么问题吗？')", 1.0]], "cases": [["好的，我明白了。你还有什么问题吗？", true], ["请问还有其他问题吗？你还有什么问题吗？", true], ["这是一个测试。", false], ["这是一个测试。你还有什么问题吗？", true], ["这是一个测试。你还有什么问题吗", false], ["你还有什么问题吗？ ", true], ["这是一个测试。你还有什么问题吗？ ", true], ["你还有什么问题吗？", true], ["你还有什么问题吗？谢谢。", false], ["好的，我明白了。", false]]}
{"instruction": "- 回答以“这就是我的回答。”结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('这就是我的回答。')", 1.0]], "cases": [["这是一个测试。这不是我的回答。", false], ["这不是我的回答。这就是我的回答", false], ["这就是我的回答。 ", false], ["回答：这就是我的回答。", true], ["这就是我的回答。", true], ["回答以“这就是我的回答。”结尾。这就是我的回答。", true], ["这是一个测试。这就是我的回答。", true], ["这是另一个测试。这不是我的回答。", false]]}
{"instruction": "- 回答以“你觉得呢？”结尾。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('你觉得呢？')", 1.0]], "cases": [["你觉得呢？ ", true], ["这是一个测试，你觉得呢？", true], ["这是一个测试", false], ["你觉得呢", false], ["这是一个测试。", false], ["这是一个测试，你觉得呢", false], ["你觉得呢？\r\n", true], ["你觉得呢？\t", true], ["这是一个测试，你觉得呢？ ", true], ["你觉得呢？\n", true], ["你觉得呢？这是一个测试", false], ["你觉得呢？", true]]}
{"instruction": "- 回答以“我回答好了！”结尾。", "eval_func": [["def evaluate(response):\n    return response.endswith('我回答好了！')", 1.0]], "cases": [["这是一个测试。我回答好了", false], ["这是一个测试。", false], ["我回答好了！", true], ["我回答好了！这是一个测试。", false], ["这是一个测试。我回答好了！", true], ["这是另一个测试。", false], ["这是一个测试。我回答好了！ ", false]]}
{"instruction": "- 用数字编号的方式回答，每个段落用逗号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    if not re.match(r'^\\d+\\.\\s', response):\n        return False\n    # 检查每个段落是否用逗号隔开\n    paragraphs = response.split(',')\n    for paragraph in paragraphs:\n        if not re.match(r'^\\d+\\.\\s', paragraph.strip()):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    numbered_pattern = re.compile(r'^(\\d+\\.\\s).*')\n    # 检查是否每个段落用逗号隔开\n    comma_separated_pattern = re.compile(r'\\d+\\.\\s[^,]+(,\\s\\d+\\.\\s[^,]+)*$')\n    if not numbered_pattern.match(response):\n        return False\n    if not comma_separated_pattern.match(response):\n        return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    if not re.match(r'^\\d+\\.', response):\n        return False\n    # 检查每个段落是否用逗号隔开\n    paragraphs = response.split(',')\n    for paragraph in paragraphs:\n        if not re.match(r'^\\d+\\.', paragraph.strip()):\n            return False\n    return True", 1.0]], "cases": [["1. 这是第一段, 2. 这是第二段, 3. 这是第三段", true], ["1. 这是第一段, 2. 这是第二段, 3. 这是第三段, 4. 这是第四段", true], ["1. 这是第一段,2. 这是第二段,这是第三段", false], ["这是第一段,2. 这是第二段,3. 这是第三段", false], ["1. 这是第一段,2. 这是第二段,3. 这是第三段", true], ["1. 这是第一段, 2. 这是第二段, 这是第三段", false]]}
{"instruction": "- 用字母编号的方式回答，每个段落用分号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以字母编号的方式回答\n    pattern = r'^[a-zA-Z]\\. .+?(; [a-zA-Z]\\. .+?)*;$'\n    match = re.match(pattern, response)\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # 检查是否以字母编号的方式回答\n    pattern = re.compile(r'^[a-zA-Z]\\. .+?(; [a-zA-Z]\\. .+?)*;$')\n    return bool(pattern.match(response))", 1.0]], "cases": [["1. 这是第一段; 2. 这是第二段;", false], ["a. 这是第一段; b. 这是第二段", false], ["a. 这是第一段; b. 这是第二段; c. 这是第三段; d. 这是第四段;", true], ["a. 这是第一段; b. 这是第二段;", true], ["a. 这是第一段; b. 这是第二段; c. 这是第三段;", true], ["1. 这是第一段; 2. 这是第二段; 3. 这是第三段;", false], ["a. 这是第一段; b. 这是第二段; c. 这是第三段", false]]}
{"instruction": "- 用大写字母编号的方式回答，每个项目用逗号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 正则表达式匹配模式\n    pattern = r'^[A-Z]+\\. .+(, [A-Z]+\\. .+)*$'\n    # 使用正则表达式进行匹配\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配模式\n    pattern = r'^[A-Z]+\\. .+(, [A-Z]+\\. .+)*$'\n    # 去除首尾空格\n    response = response.strip()\n    # 匹配模式\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配模式\n    pattern = r'^[A-Z]+\\. .+(, [A-Z]+\\. .+)*$'\n    # 使用正则表达式匹配输入字符串\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["A. 项目一, B. 项目二, C. 项目三", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四, E. 项目五", true]]}
{"instruction": "- 用罗马数字编号的方式回答，每个项目用分号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 正则表达式匹配罗马数字编号的项目\n    pattern = re.compile(r'^(I|II|III|IV|V|VI|VII|VIII|IX|X)(; (I|II|III|IV|V|VI|VII|VIII|IX|X))*$')\n    # 检查是否匹配\n    return bool(pattern.match(response))", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配罗马数字编号的项目\n    pattern = r'^(I|II|III|IV|V|VI|VII|VIII|IX|X)(; (I|II|III|IV|V|VI|VII|VIII|IX|X))*$'\n    # 去除首尾空格\n    response = response.strip()\n    # 检查是否匹配模式\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["I; II; III; IV; V", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;XI", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI", false], ["I; II; III; IV; V; VI; VII; VIII; IX", true], ["I; II; III; IV;", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; ", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII", false], ["I; II; III; IV", true], ["I; II; III; IV; V; VI", true], ["I; II; III; IV; V; VI; VII; VIII; IX; XI", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV", false]]}
{"instruction": "- 仅使用声母为“d”或“t”的汉字。", "eval_func": [["import re\n\ndef evaluate(response):\n    # 定义一个正则表达式，匹配所有声母为d或t的汉字\n    pattern = re.compile(r'^[dt][一-龥]$')\n    # 遍历输入字符串中的每个字符\n    for char in response:\n        # 如果字符不匹配正则表达式，则返回False\n        if not pattern.match(char):\n            return False\n    # 如果所有字符都匹配正则表达式，则返回True\n    return True", 1.0]], "cases": [["测试", false], ["你好", false]]}
{"instruction": "- 仅使用声母为“h”或“f”的汉字。", "eval_func": [["import re\n\ndef evaluate(response):\n    # 定义一个正则表达式，匹配所有声母为“h”或“f”的汉字\n    pattern = re.compile(r'^[一-龥]*$')\n    # 遍历每个字符，检查是否符合要求\n    for char in response:\n        if not pattern.match(char):\n            return False\n        if char[0] not in ['h', 'f']:\n            return False\n    return True", 1.0]], "cases": [["花费时间", false], ["哈哈发发非非飞飞风风好", false], ["飞黄腾达，努力奋斗", false], ["哈哈发发非非好", false]]}
{"instruction": "- 仅使用声母为“l”或“r”的汉字。", "eval_func": [["import re\n\ndef evaluate(response):\n    # 定义一个正则表达式，匹配所有声母为“l”或“r”的汉字\n    pattern = re.compile(r'^[一-龥]*$')\n    # 遍历每个字符，检查是否符合要求\n    for char in response:\n        if not pattern.match(char):\n            return False\n        if not (char.startswith('l') or char.startswith('r')):\n            return False\n    return True", 1.0]], "cases": [["你好", false], ["苹果", false]]}
{"instruction": "- 以JSON格式输出。", "eval_func": [["def evaluate(response):\n    import json\n    try:\n        json.loads(response)\n        return True\n    except ValueError:\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        import json\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则返回False\n        return False", 1.0]], "cases": [["{\"name\": \"张三\", \"age\": 25}", true], ["{\"name\": \"王五\", \"age\": 30,}", false], ["{\"name\": \"李四\", \"age\": \"二十五\"}", true], ["name: \"张三\", age: 25", false], ["{\"name\": \"赵六\", \"age\": 30}", true], ["{name: \"张三\", age: 25}", false]]}
{"instruction": "- 以JSON格式输出。", "eval_func": [["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        import json\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则说明不是有效的JSON格式\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则说明不是有效的JSON格式\n        return False", 1.0]], "cases": [["{\"name\": \"张三\", \"age\": 25}", true], ["{\"name\": \"王五\", \"age\": 30,}", false], ["{\"name\": \"李四\", \"age\": \"二十五\"}", true], ["{\"name\": \"赵六\", \"age\": 30}", true], ["{name: \"张三\", age: 25}", false]]}
{"instruction": "- 以XML格式输出。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n    try:\n        ET.fromstring(response)\n        return True\n    except ET.ParseError:\n        return False", 1.0]], "cases": [["这不是XML格式的内容", false], ["<root><child 属性=\"值\">内容</child></root>", true], ["<root><child 属性='值'>内容</child></root>", true], ["<root><child>内容</child></root><extra>多余的内容</extra>", false], ["<root><child>内容</child>", false], ["<root><child>内容</child></root>", true]]}
{"instruction": "- 以XML格式输出。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n    try:\n        ET.fromstring(response)\n        return True\n    except ET.ParseError:\n        return False", 1.0]], "cases": [["这不是XML格式的内容", false], ["<root><child 属性=\"值\">内容</child></root>", true], ["<root><child>内容</child></root><extra>多余的内容</extra>", false], ["<root><child>内容</child>", false], ["<root><child>内容</child></root>", true]]}
{"instruction": "- 以XML格式输出。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n    try:\n        ET.fromstring(response)\n        return True\n    except ET.ParseError:\n        return False", 1.0]], "cases": [["这不是XML格式的内容", false], ["<root><child>内容</child><child2>更多内容</child2></root>", true], ["<root><child 属性=\"值\">内容</child></root>", true], ["<root><child>内容</child></root><extra>多余的内容</extra>", false], ["<root><child>内容</child>", false], ["<root><child>内容</child></root>", true]]}
{"instruction": "- 以CSV格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否每行有相同数量的逗号\n    lines = response.split('\\n')\n    num_commas = lines[0].count(',')\n    for line in lines:\n        if line.count(',') != num_commas:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否以CSV格式输出\n    lines = response.split('\\n')\n    for line in lines:\n        if ',' not in line:\n            return False\n    return True", 1.0]], "cases": [["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\\nCharlie,35,Chicago", true], ["name;age;city\nAlice;30;New York\nBob;25;Los Angeles", false], ["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles", true], ["name;age;city\\nAlice;30;New York\\nBob;25;Los Angeles", false]]}
{"instruction": "- 以CSV格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否每行有相同数量的逗号\n    lines = response.split('\\n')\n    num_commas = lines[0].count(',')\n    for line in lines:\n        if line.count(',') != num_commas:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否包含换行符\n    if '\\n' in response:\n        return False\n    # 检查是否包含逗号\n    if ',' not in response:\n        return False\n    # 检查是否以CSV格式输出\n    lines = response.split('\\n')\n    for line in lines:\n        if ',' not in line:\n            return False\n    return True", 1.0]], "cases": [["name;age;city\nAlice;30;New York\nBob;25;Los Angeles", false], ["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles\\n", true], ["name,age,city\\nAlice,30,New York\\nBob,25,Los Angeles", true], ["name;age;city\\nAlice;30;New York\\nBob;25;Los Angeles", false]]}
{"instruction": "- 以YAML格式输出。", "eval_func": [["import yaml\n\ndef evaluate(response: str) -> bool:\n    try:\n        yaml.safe_load(response)\n        return True\n    except yaml.YAMLError:\n        return False", 1.0]], "cases": [["name: 张三\nage: 25\naddress: 北京市", true], ["name: 王五\nage: 40\naddress: 广州市\nextra: [1, 2, 3]", true], ["name: 赵六\nage: 22\naddress: 成都市\nextra: value", true], ["name: 李四\nage: 30\naddress: 上海市", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1\n- item2", false], ["name: 李四\nage: 25\naddress: 上海市", true], ["name: 张三\nage: 30\naddress: 北京市", true], ["name: 张三\nage: 30\naddress: 北京市\n- item1\n- item2", false], ["name: 王五\nage: 28\naddress: 广州市\n", true], ["name: 王五\nage: 40\naddress: 广州市\nchildren:\n  - name: 小王\n    age: 10", true]]}
{"instruction": "- 以YAML格式输出。", "eval_func": [["import yaml\n\ndef evaluate(response: str) -> bool:\n    try:\n        yaml.safe_load(response)\n        return True\n    except yaml.YAMLError:\n        return False", 1.0]], "cases": [["name: John Doe\nage: thirty\n", true], ["name: 张三\nage: 25\naddress: 北京市", true], ["name: 张三\nage: 25\naddress: 北京市\ninvalid_yaml: [1, 2, 3", false], ["name: 赵六\nage: 22\naddress: 成都市\nextra: {key: value}", true], ["name: 李四\nage: 30\naddress: 上海市", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1\n- item2", false], ["name: 王五\nage: 28\naddress: 广州市\nextra: [1, 2, 3]", true], ["name: John Doe\nage: 30\n", true], ["name: 王五\nage: 28\naddress: 广州市\n", true], ["name: 赵六\nage: 22\naddress: 成都市\nextra: [1, 2, 3]", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1: value1\n- item2: value2", false], ["name: John Doe\nage: 30\naddress: 123 Main St\n- item1\n- item2\n", false], ["name: John Doe\nage: 30\naddress: 123 Main St\n", true]]}
{"instruction": "- 以YAML格式输出。", "eval_func": [["import yaml\n\ndef evaluate(response: str) -> bool:\n    try:\n        yaml.safe_load(response)\n        return True\n    except yaml.YAMLError:\n        return False", 1.0]], "cases": [["name: 张三\nage: 25\naddress: 北京市", true], ["name: 李四\nage: 30\naddress: 上海市", true], ["name: 王五\nage: 28\naddress: 广州市", true], ["name: 赵六\nage: 22\naddress: 成都市", true], ["name: 张三\nage: 25\naddress: 北京市\n- item1\n- item2", false], ["name: 张三\nage: 30\naddress: 北京市", true], ["name: 李四\nage: 25\naddress: 上海市\n", true]]}
{"instruction": "- 以HTML表格格式输出。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以<table>开头并以</table>结尾\n    if not response.strip().startswith('<table>') or not response.strip().endswith('</table>'):\n        return False\n    # 检查是否包含<tr>和<td>标签\n    if not re.search(r'<tr>.*?</tr>', response, re.DOTALL) or not re.search(r'<td>.*?</td>', response, re.DOTALL):\n        return False\n    return True", 0.9], ["def evaluate(response):\n    import re\n    # 检查是否以 <table> 开始并以 </table> 结束\n    if re.match(r'^<table>.*</table>$', response, re.DOTALL):\n        return True\n    return False", 0.9]], "cases": [["<table><tr><td>内容</td></tr></table><p>其他内容</p>", false], ["<table><tr><td>内容</td></tr>", false], ["<div>这是一个div，不是表格</div>", false], ["<table><tr><td>内容</td></tr></table>", true], ["表格内容<table><tr><td>内容</td></tr></table>", false], ["这不是一个HTML表格", false], ["<table><tr><td>内容</td></tr></table><p>这是一个段落</p>", true], ["<div><table><tr><td>内容</td></tr></table></div>", false], ["<table><tr><td>内容</td></tr></table>其他内容", false], ["<div><tr><td>内容</td></tr></div>", false]]}
{"instruction": "- 以HTML表格格式输出。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以<table>开头并以</table>结尾\n    if not response.strip().startswith('<table>') or not response.strip().endswith('</table>'):\n        return False\n    # 检查是否包含<tr>和<td>标签\n    if not re.search(r'<tr>.*?</tr>', response, re.DOTALL) or not re.search(r'<td>.*?</td>', response, re.DOTALL):\n        return False\n    return True", 0.9285714285714286], ["def evaluate(response):\n    import re\n    # 定义一个简单的正则表达式来检查HTML表格的基本结构\n    pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 使用正则表达式匹配输入字符串\n    match = pattern.search(response)\n    # 如果匹配成功且整个字符串都在表格标签内，则返回True\n    if match and match.group(0) == response:\n        return True\n    return False", 0.9285714285714286]], "cases": [["<table><tr><td>测试</td></tr></table>", true], ["前置内容<table><tr><td>内容</td></tr></table>", false], ["<table><tr><td>内容</td></tr></table><p>其他内容</p>", false], ["<table><tr><td>内容</td></tr>", false], ["<table><tr><td>内容</td></tr></table><table><tr><td>更多内容</td></tr></table>", false], ["其他内容<table><tr><td>测试</td></tr></table>", false], ["<table><tr><td>内容</td></tr></table>", true], ["<table><tr><td>测试</td></tr></table>其他内容", false], ["<div>内容</div>", false], ["<div>测试</div>", false], ["<table><tr><td>测试</td></tr>", false], ["<table><tr>内容</tr></table>", false], ["<table><tr><td>内容</td></tr></table>其他内容", false], ["<div><tr><td>内容</td></tr></div>", false]]}
{"instruction": "- 以HTML表格格式输出。", "eval_func": [["def evaluate(response):\n    import re\n    # 定义一个简单的正则表达式来检查HTML表格结构\n    table_pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 检查输入字符串是否匹配HTML表格结构\n    if table_pattern.search(response):\n        return True\n    return False", 0.8], ["def evaluate(response):\n    import re\n    # 定义一个简单的正则表达式来检查HTML表格的基本结构\n    pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 检查response是否匹配该模式\n    if pattern.search(response):\n        return True\n    else:\n        return False", 0.8]], "cases": [["<table><tr><td>数据1</td><td>数据2</td></tr>", false], ["这是一个普通文本，不是HTML表格。", false], ["<div>不是表格</div>", false], ["前置内容<table><tr><td>内容</td></tr></table>", false], ["<table><tr><td>数据1</td><td>数据2</td></tr></table>", true], ["<table><tr><td>数据1</td></tr><tr><td>数据2</td></tr></table>", true], ["<table><tr><td>数据1</td><td>数据2</td></tr></table><div>这是表格外的div</div>", true], ["<div>这是一个div，不是表格</div>", false], ["<table><tr><td>数据1</td><td>数据2</td></tr></table>这是表格外的文本", true], ["<table><tr><td>内容</td></tr></table>这是额外的文本。", true], ["<table><tr><td>内容</td></tr></table><table><tr><td>更多内容</td></tr></table>", false], ["<table><tr><td>内容</td></tr></table>", true], ["<table><tr><td>内容</td></tr></table><table><tr><td>另一个表格</td></tr></table>", true], ["<table><tr><td>内容</td></tr></table>额外内容", false], ["<div>这是一个div，不是表格。</div>", false]]}
{"instruction": "- 以Markdown表格格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔符行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 0.9090909090909091], ["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 0.9090909090909091]], "cases": [["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2", false], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 | 数据3 |", false], ["| 头1 | 头2 |\n| --- | --- |\n数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |\n", true], ["头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2\n数据3 | 数据4", false]]}
{"instruction": "- 以Markdown表格格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔符行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if '|' not in header or '|' not in separator:\n        return False\n    # 检查分隔符行是否有效\n    for char in separator:\n        if char != '|' and char != '-' and char != ' ':\n            return False\n    # 检查每一行是否包含相同数量的列\n    num_columns = header.count('|')\n    for line in lines[1:]:\n        if line.count('|') != num_columns:\n            return False\n    return True", 0.9]], "cases": [["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4", false], ["头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2", false], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |\n", true], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4", false], ["| 头1 | 头2 |\n| --- | --- |\n数据1 | 数据2 |\n| 数据3 | 数据4 |", false]]}
{"instruction": "- 以Markdown表格格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔符行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 1.0]], "cases": [["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", true], ["列1 | 列2\n--- | ---\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4", false], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2\n| 数据3 | 数据4 |", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2\n数据3 | 数据4", false]]}
{"instruction": "- 每个段落都以“因为”字开头。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('因为'):\n            return False\n    return True", 1.0]], "cases": [["因为这是第一个段落。\n因为这是第二个段落。", true], ["因为这是唯一的段落。", true], ["因为这是第一个段落。\n因为这是第二个段落。\n因为这是第三个段落。", true], ["因为这是第一个段落。\n这是第二个段落。", false], ["这是第一个段落。\n因为这是第二个段落。", false]]}
{"instruction": "- 每个段落都以“虽然”字开头。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('虽然'):\n            return False\n    return True", 1.0]], "cases": [["虽然天气很好，但我还是决定在家。\n我很想出去玩，但工作太多了。", false], ["虽然天气很好，\n虽然我很忙，\n虽然时间不多，\n虽然我很累。", true], ["虽然天气很好，但我还是决定在家。", true], ["虽然天气很好，但我还是决定在家。\n虽然我很想出去玩，但工作太多了。", true], ["天气很好，但我还是决定在家。\n虽然我很想出去玩，但工作太多了。", false], ["虽然天气很好，\n虽然我很忙，\n虽然时间不多。", true], ["虽然天气很好，但我还是决定在家。\n虽然我很想出去玩，但工作太多了。\n虽然今天是周末，但我还是要加班。", true], ["虽然天气很好，\n虽然我很忙，\n时间不多。", false], ["虽然天气很好，\n我很忙，\n虽然时间不多。", false], ["天气很好，\n虽然我很忙，\n虽然时间不多。", false]]}
{"instruction": "- 每个段落都以“所以”字开头。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('所以'):\n            return False\n    return True", 1.0]], "cases": [["所以这是第一段。\n所以这是第二段。", true], ["这是第一段。\n所以这是第二段。", false], ["所以这是唯一一段。", true], ["所以这是第一段。\n这是第二段。", false], ["所以这是第一段。\n所以这是第二段。\n所以这是第三段。", true]]}
{"instruction": "- 回复中的每个句子必须包含一个数字。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip() == '':\n            continue\n        if not any(char.isdigit() for char in sentence):\n            return False\n    return True", 1.0]], "cases": [["天气很好。我们去散步。", false], ["他买了5个苹果。她买了2个橙子。", true], ["今天是个好日子。我们去公园玩。", false], ["我有2只猫。她有3只狗。", true]]}
{"instruction": "- 回复中的每个句子必须包含一个日期。", "eval_func": [["def evaluate(response):\n    import re\n    # 定义日期模式\n    date_pattern = re.compile(r'\\d{4}年\\d{1,2}月\\d{1,2}日')\n    # 分割句子\n    sentences = re.split(r'[。！？]', response)\n    # 检查每个句子是否包含日期\n    for sentence in sentences:\n        if sentence.strip() and not date_pattern.search(sentence):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # 定义日期的正则表达式模式\n    date_pattern = re.compile(r'\\d{4}年\\d{1,2}月\\d{1,2}日')\n    # 将回复按句子分割\n    sentences = re.split(r'[。！？]', response)\n    # 检查每个句子是否包含日期\n    for sentence in sentences:\n        if sentence.strip() and not date_pattern.search(sentence):\n            return False\n    return True", 1.0]], "cases": [["今天是2023年10月5日，明天是2023年10月6日。", true], ["2023年10月5日是个好日子。2023年10月6日也是。", true], ["2023年10月5日是个好日子！2023年10月6日我们去旅行。", true], ["今天是2023年10月5日。明天是2023年10月6日。", true], ["今天是2023年10月5日。明天我们去旅行。", false], ["2023年10月5日。2023年10月6日。", true], ["今天是2023年10月5日。明天是星期五。", false]]}
{"instruction": "- 回复中的每个句子必须包含一个时间。", "eval_func": [["def evaluate(response):\n    import re\n    sentences = response.split('。')\n    time_pattern = re.compile(r'\\d{1,2}[:：]\\d{2}|\\d{1,2}点|\\d{1,2}时|\\d{1,2}分|\\d{1,2}秒')\n    for sentence in sentences:\n        if sentence.strip() and not time_pattern.search(sentence):\n            return False\n    return True", 1.0]], "cases": [["早上起床。然后在9:15出门。晚上7点回家。", false], ["早上8点起床。然后在9:15出门。晚上7点回家。", true], ["现在是10点。我们在12:30吃午饭。下午3点开会。", true], ["今天是个好日子。我们在12:30吃午饭。下午3点开会。", false]]}
{"instruction": "- 回复中的每个句子必须包含一个网址。", "eval_func": [["def evaluate(response):\n    import re\n    sentences = response.split('。')\n    url_pattern = re.compile(r'https?://[\\w\\.-]+')\n    for sentence in sentences:\n        if sentence.strip() and not url_pattern.search(sentence):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    sentences = response.split('。')\n    url_pattern = re.compile(r'https?://(?:[-\\w.]|(?:%[\\da-fA-F]{2}))+')\n    for sentence in sentences:\n        if sentence.strip() and not url_pattern.search(sentence):\n            return False\n    return True", 1.0]], "cases": [["这是一个测试句子。另一个测试句子https://example.org。", false], ["https://example.com。 这是一个测试句子https://example.org。", true], ["这是一个测试句子https://example.com。另一个测试句子https://example.org。再一个测试句子https://example.net。", true], ["https://example.com。https://example.org。", true], ["这是一个测试句子https://example.com。另一个测试句子没有网址。", false], ["这是一个测试句子https://example.com。另一个测试句子https://example.org。", true]]}
{"instruction": "- 每个句子都以“假如……那么……”的结构展开。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip():  # 忽略空句子\n            if not sentence.strip().startswith('假如') or '那么' not in sentence:\n                return False\n    return True", 1.0]], "cases": [["假如你今天早起，那么你就能赶上早班车。假如你努力学习，你就能取得好成绩。", false], ["假如你今天来，那么我们可以一起吃饭。假如天气好，那么我们去公园。假如你有时间，那么我们可以去看电影。", true], ["假如你今天来，那么我们可以一起吃饭。天气好，我们去公园。", false], ["假如你今天早起，那么你就能赶上早班车。你努力学习，那么你就能取得好成绩。", false], ["假如天气好，那么我们去公园。假如下雨，那么我们在家。", true], ["假如你今天早起，那么你就能赶上早班车。假如你努力学习，那么你就能取得好成绩。假如天气好，那么我们去公园。", true], ["假如你今天来，那么我们可以一起吃饭。假如天气好，那么我们去公园。", true], ["假如你喜欢，那么你可以留下来。假如你不喜欢，那么你可以离开。", true], ["假如你今天早起，那么你就能赶上早班车。假如你努力学习，那么你就能取得好成绩。天气好，那么我们去公园。", false], ["假如你今天来，那么我们可以一起吃饭。假如天气好，我们去公园。", false], ["假如你今天来，那么我们可以一起吃饭。", true], ["假如你今天早起，那么你就能赶上早班车。假如你努力学习，那么你就能取得好成绩。", true], ["假如天气好，我们去公园。假如下雨，那么我们在家。", false]]}
{"instruction": "- 每个句子都以“当……时……”的结构展开。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip() == '':\n            continue\n        if not sentence.startswith('当') or '时' not in sentence:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip():  # 忽略空句子\n            if not sentence.startswith('当') or '时' not in sentence:\n                return False\n    return True", 1.0]], "cases": [["当我早上起床时，我会先刷牙。我喜欢喝咖啡。", false], ["当我早上起床时，我会先刷牙。当我吃早餐时，我喜欢喝咖啡。当我工作时，我会集中注意力。", true], ["当我早上起床时，我会先刷牙。当我吃早餐时，我喜欢喝咖啡。当我工作时，我会集中注意力。当我休息时，我会放松。", true], ["我喜欢喝咖啡。当我吃早餐时，我会看新闻。", false], ["当我早上起床时，我会先刷牙。当我吃早餐时，我喜欢喝咖啡。", true], ["当我早上起床时，我会先刷牙。当我吃早餐时，我喜欢喝咖啡。当我工作时，我会集中注意力。当我休息时，我会散步。", true]]}
{"instruction": "- 每个句子都以“只要……就……”的结构展开。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip():  # 忽略空句子\n            if not sentence.startswith('只要') or '就' not in sentence:\n                return False\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip() == '':\n            continue\n        if not sentence.startswith('只要') or '就' not in sentence:\n            return False\n    return True", 1.0]], "cases": [["只要努力学习，就能取得好成绩。只要坚持锻炼，就能保持健康。", true], ["只要努力学习，就能取得好成绩。只要坚持锻炼，就能保持健康。饮食均衡，就能增强免疫力。", false], ["只要天气好，就去郊游。只要有时间，就去看电影。", true], ["只要天气好，就去郊游。我们去看电影。", false], ["只要努力学习，就能取得好成绩。坚持锻炼，就能保持健康。", false], ["只要有梦想，就有希望。只要有信心，就能成功。", true], ["只要有梦想，就有希望。只要有信心，就有力量。", true], ["只要努力学习，就能取得好成绩。只要坚持锻炼，就能保持健康。只要饮食均衡，就能增强免疫力。", true], ["只要努力学习，就能取得好成绩。", true]]}
{"instruction": "- 每个句子都以“无论……都……”的结构展开。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip():  # 忽略空句子\n            if not sentence.startswith('无论') or '都' not in sentence:\n                return False\n    return True", 1.0]], "cases": [["无论天气如何，我们都要去上班。无论遇到什么困难，我们都要坚持。无论结果如何，我们都要努力。", true], ["无论你怎么说，我都不会改变主意。发生什么，我们都要坚持。", false], ["无论你怎么说，我都不会改变主意。无论发生什么，我们都要坚持。", true], ["无论天气如何，我们都要去上班。无论发生什么，我们都要坚持。无论多么困难，我们都不会放弃。", true], ["无论天气如何，我们都要去上班。无论发生什么，我们都要坚持。", true], ["无论天气如何，我们都要去上班。无论发生什么，我们都要坚持。多么困难，我们都不会放弃。", false], ["无论天气如何，我们都要去上班。我们要坚持。", false], ["无论天气如何，我们都要去上班。无论遇到什么困难，我们要坚持。", false], ["无论你怎么说，我都不会改变主意。", true], ["无论天气如何，我们都要去上班。无论遇到什么困难，我们都要坚持。", true], ["无论天气如何，我们都要去上班。", true]]}
{"instruction": "- 每个句子都以“即使……也……”的结构展开。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip():  # 忽略空句子\n            if not sentence.startswith('即使') or '也' not in sentence:\n                return False\n    return True", 1.0]], "cases": [["即使天气不好，我们也要去上班。我们要坚持。", false], ["即使很累，我们要坚持。即使很忙，我们也要完成任务。", false], ["即使很累，我们也要坚持。即使很忙，我们也要完成任务。", true], ["即使下雨了，我们也要去跑步。即使很冷，我们也要锻炼。", true], ["即使天气不好，我们也要去上班。即使很累，我们也要坚持。", true], ["即使很累，我们也要坚持。很忙，我们也要完成任务。", false]]}
{"instruction": "- 每个句子都以“因为……所以……”的结构展开。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    for sentence in sentences:\n        if sentence.strip():  # 忽略空句子\n            if not sentence.startswith('因为') or '所以' not in sentence:\n                return False\n    return True", 1.0]], "cases": [["因为天气很好，所以我们去公园散步。", true], ["因为天气很好，所以我们去公园散步。因为我饿了，所以我去吃饭", true], ["因为天气很好，所以我们去公园散步。我们去吃饭，因为我饿了。", false], ["因为我喜欢编程，所以我每天都写代码。因为我喜欢学习，所以我每天都看书。", true], ["因为我喜欢编程，所以我每天都练习。因为我喜欢学习，所以我每天都看书。", true], ["因为我喜欢编程，所以我每天都写代码。每天写代码让我很开心。", false], ["天气很好，所以我们去公园散步。因为我饿了，所以我去吃饭。", false], ["因为我喜欢编程，所以我每天都写代码。", true], ["因为天气很好，所以我们去公园散步。因为我饿了，所以我吃了一个苹果。", true], ["因为天气很好，所以我们去公园散步。因为我饿了，所以我去吃饭。", true], ["因为天气很好，所以我们去公园散步。我们还带了午餐。", false], ["因为天气很好，所以我们去公园散步。我们在公园里玩得很开心。", false]]}
{"instruction": "每个回答段落的首字母必须大写。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # skip empty strings\n            continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # Skip empty paragraphs\n            continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        # Skip empty paragraphs\n        if not paragraph.strip():\n            continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph: continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0]], "cases": [["All good here.\nEven this one is fine!", true], ["The first paragraph is correct.\nthis one starts with lowercase.", false], ["This is a paragraph.\nAnd another one starts here.", true]]}
{"instruction": "回答必须以问句形式结束，并用半角问号“？”。", "eval_func": [["def evaluate(response):\n    return response.endswith(\"？\") and any(char.isalnum() for char in response)", 1.0]], "cases": [["这个表达式结束吗?", false], ["这应该没有以问号结束。", false], ["正确的例子？", true], ["这句话不是以半角问号结尾。", false], ["这是一个问题吗？", true]]}
{"instruction": "回答中必须包含一个用单个反引号包裹的技术术语，例如`术语`。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'`[^`]+`'\n    result = re.findall(pattern, response)\n    return len(result) == 1 and result[0][1:-1].isalnum()", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'`[^`]+`')\n    matches = pattern.findall(response)\n    return len(matches) == 1", 1.0], ["def evaluate(response):\n    import re\n    matches = re.findall(r'`[^`]+`', response)\n    return len(matches) == 1", 1.0]], "cases": [["正确的格式应该像这样使用`技术术语`来表示。", true], ["正确的应该像这样包含一个术语，例如`技术词汇`。", true], ["这个回答没有使用反引号 ` 包裹任何术语。", false], ["同时包含多个`术语1`和`术语2`也是不符合要求的。", false], ["如果没有使用反引号包裹，比如这样的术语就是错误的。", false], ["在这个回答中，我使用了一个被反引号包裹的术语，比如 `编程`。", true], ["反引号不止一个`错误1`和`错误2`都被包裹了。", false], ["正确的示例应该像这样：使用`网络协议`这个词。", true], ["这个例子中没有使用反引号来包裹术语。", false]]}
{"instruction": "回答需要包含至少三个用中文括号包裹的数字序列号，如（一）、（二）、（三）。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the regular expression pattern to match sequences of Chinese numerals in parentheses\n    pattern = re.compile('（[一二三四五六七八九十百千万]+）')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'（[一二三四五六七八九十百千万]+）')\n    matches = pattern.findall(response)\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    # 匹配至少三个用中文括号包裹的数字序列号\n    pattern = re.compile(r'（[一-龥]）')\n    matches = pattern.findall(response)\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0], ["import re\n\ndef evaluate(response):\n    # Define the pattern to match Chinese-bracketed sequences\n    pattern = re.compile(r'（[一二三四五六七八九十]+）')\n\n    # Find all matches in the response\n    matches = pattern.findall(response)\n\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0]], "cases": [["仅有两个序列号（一）和（二），不够。", false], ["这里有四个数字序号（一）、（二）、（三）、（四），超出要求。", true], ["这是一个例子（一）、（二）和（三），它符合要求。", true]]}
{"instruction": "回答中必须含有至少两个带下标的词语，用markdown格式表示，例如H~2~O。", "eval_func": [["def evaluate(response):\n    import re\n    matches = re.findall(r'\\w+~\\d+~', response)\n    return len(matches) >= 2", 1.0], ["def evaluate(response):\n    import re\n    # The markdown subscript pattern to search for\n    subscript_pattern = re.compile(r'\\w~\\d+~')\n    # Find all matches of the pattern in the response\n    matches = subscript_pattern.findall(response)\n    # Evaluate if there are at least two subscripted words as per the instruction\n    return len(matches) >= 2", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to find markdown subscript characters\n    subscript_pattern = r'\\w~\\d+~'\n    # Find all instances of markdown subscripts\n    matches = re.findall(subscript_pattern, response)\n    # The response is valid if there are at least two markdown subscripts\n    return len(matches) >= 2", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r'\\w+~\\d+~'  # Regular expression pattern for markdown formatted subscript\n    matches = re.findall(pattern, response)\n    return len(matches) >= 2", 1.0]], "cases": [["C~6~H~12~O~6~是葡萄糖分子的化学式。", true], ["化学中常见的水分子是H~2~O和二氧化碳CO~2~。", true], ["在这个方程式中，只有NH~3~一个带下标的词语。", false]]}
{"instruction": "回答应在末尾附上一个水平分割线，使用markdown格式表示，即 `---`。", "eval_func": [["def evaluate(response):\n    return response.strip().endswith('---')", 1.0], ["def evaluate(response):\n    # Check if the response ends with the markdown horizontal rule\n    return response.strip().endswith('---')", 1.0], ["def evaluate(response):\n    # Split the response text by lines\n    lines = response.strip().split('\\n')\n    # Check if the last non-empty line is '---'\n    for line in reversed(lines):\n        if line.strip():  # Find the last non-empty line\n            return line.strip() == '---'\n    return False", 0.9090909090909091], ["def evaluate(response):\n    # Split the response by lines\n    lines = response.strip().split('\\n')\n    # Check if the last non-empty line is a markdown horizontal rule\n    return lines[-1] == '---'", 0.9090909090909091]], "cases": [["这是一个回答。\\n---", true], ["这是一个符合规定的回答。\n---", true], ["这个回答虽然有水平分割线，但是不在末尾。\n---\n还有文字。", false], ["这是一个带有正确markdown水平分割线的回答。\n---", true], ["这个回答后面的分割线是错误的。\n- - -", false], ["这个回答没有水平分割线", false], ["这个回答非常详细。\\n---\\n但是分割线后面还有内容。", false], ["这个回答在最后没有水平分割线", false], ["这个回答忘记了分割线。", false], ["这是一个遵循指示的回答。\n---", true], ["正确的回答。\\n但是后面没有分割线。", false]]}
{"instruction": "在回答中使用至少有三项的复选框列表，用markdown格式表示，如 `- [ ] 项1`。", "eval_func": [["def evaluate(response):\n    # split the string by lines to process them individually\n    lines = response.split('\\n')\n    checklist_count = 0 # Variable to count the number of checklist items\n    for line in lines:\n        # Check if the line starts with the markdown for a checkbox\n        if line.startswith('- [ ] '):\n            checklist_count += 1\n    # Return True only if there are at least three checklist items\n    return checklist_count >= 3", 1.0], ["def evaluate(response):\n    # Check if there are at least three checkbox items in markdown format\n    lines = response.strip().split('\\n')\n    checkbox_count = 0\n\n    # Iterate through each line to count markdown checkboxes\n    for line in lines:\n        if line.startswith('- [ ] '):\n            checkbox_count += 1\n\n    # Evaluate if there are at least three checkboxes\n    return checkbox_count >= 3", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    checkbox_count = 0\n    for line in lines:\n        if line.strip().startswith('- [ ] '):\n            checkbox_count += 1\n    return checkbox_count >= 3", 1.0], ["def evaluate(response):\n    required_prefix = '- [ ] '\n    lines = response.split('\\n')\n    checkbox_count = 0\n    for line in lines:\n        if line.startswith(required_prefix):\n            checkbox_count += 1\n    return checkbox_count >= 3", 1.0], ["def evaluate(response):\n    checkbox_lines = response.strip().split('\\n')\n    checkbox_count = 0\n    for line in checkbox_lines:\n        if line.startswith('- [ ] '):\n            checkbox_count += 1\n    return checkbox_count >= 3", 1.0]], "cases": [["- [ ] 项目1\n- [ ] 项目2\n- [ ] 项目3", true], ["- [ ] 项目1\n- [ ] 项目2", false]]}
{"instruction": "回答应该包括一段用markdown引用格式书写的文字，格式为 `> 引用文字`。", "eval_func": [["def evaluate(response):\n    import re\n    # Check if the response starts with '> '\n    if not response.startswith('> '):\n        return False\n    # Check if the response is in markdown blockquote format only\n    # i.e., lines should start with '> ' (except empty lines)\n    pattern = r'^(> .+)$'\n    lines = response.strip().split('\\n')\n    # Allow empty lines\n    blockquote_lines = [line for line in lines if line.strip() != '']\n    # Ensure all non-empty lines conform to markdown quote format\n    for line in blockquote_lines:\n        if not re.match(pattern, line):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Check if the response starts with the markdown quote format\n    if not response.startswith('> '):\n        return False\n\n    # Check if there is any content after the markdown quote format\n    quote_content = response[2:].strip()\n    if not quote_content:\n        return False  # No content after the quote\n\n    # If the response starts with '> ' and has content after it, the response follows the instruction\n    return True", 1.0], ["def evaluate(response):\n    if not response.strip():\n        return False\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # First check if the response includes markdown quote format\n    quote_pattern = r'^> .+'\n    if not re.match(quote_pattern, response.strip()):\n        return False\n    # Then check if it strictly contains only the quote and optional whitespace\n    strict_pattern = r'^> .+\\n*$'\n    if not re.fullmatch(strict_pattern, response.strip()):\n        return False\n    return True", 1.0]], "cases": [[">引用文字", false], ["> 引用文字", true], ["> 引用文字\\n> 追加的引用文字", true]]}
{"instruction": "回答回答中的URL必须用尖括号包裹，如<http://example.com>。", "eval_func": [["def evaluate(response):\n    import re\n    # This regular expression matches URLs enclosed in angle brackets\n    # The pattern will match a string that starts with <http:// or <https://\n    # followed by any characters (non-greedy), and then ends with >\n    pattern = re.compile(r'<https?://.*?>')\n    # Find all the matches in the input string\n    matches = pattern.findall(response)\n    # Removing all matches from the response to see if any URLs are left without brackets\n    for match in matches:\n        response = response.replace(match, '')\n    # Check if there are any URLs left in the response\n    # This pattern checks for URLs not enclosed in angle brackets\n    leftover_urls = re.compile(r'https?://')\n    if leftover_urls.search(response):\n        return False\n    return all(match.startswith('<http') and match.endswith('>') for match in matches)", 1.0]], "cases": [["全部正确的范例：<http://example.com>和<https://example.org>。", true], ["这个回答中的URL没有用尖括号包裹 http://example.com 应该返回False。", false], ["这是一个规范的回答<http://example.com>，完全符合要求。", true]]}
{"instruction": "回答必须包含至少一个用等号 = 表示的数学表达式。", "eval_func": [["def evaluate(response):\n    return '=' in response and any(char.isdigit() for char in response.split('=')[0]) and any(char.isdigit() for char in response.split('=')[1])", 1.0], ["def evaluate(response: str) -> bool:\n    return '=' in response and any(char.isdigit() for char in response.split('=')[0]) and any(char.isdigit() for char in response.split('=')[1])", 1.0]], "cases": [["这并不含等号的表达式。", false], ["这是一个数学表达式 5 = 5。", true], ["等号在这里=，但是两边没有数字。", false]]}
{"instruction": "回答的最后需要附上一个以“致谢：”开头的段落。", "eval_func": [["def evaluate(response):\n    if not response.endswith('\\n'):\n        response += '\\n'\n    sections = response.split('\\n')\n    for i in range(len(sections)-1, -1, -1):\n        if sections[i].strip():\n            return sections[i].startswith('致谢：')\n    return False", 1.0]], "cases": [["花了一个小时才找到这个终于得到了解决方案。\n致谢：感恩大家", true], ["您好，请您查看我的回复。\n致谢：", true], ["感谢您的回复，我已经修改了那个错误。致谢：这里没有换行", false]]}
{"instruction": "回答中必须包含一个电话号码格式，用短横线连接，如“123-4567-8900”。", "eval_func": [["def evaluate(response):\n    import re\n    phone_number_pattern = re.compile(r'\\d{3}-\\d{4}-\\d{4}')\n    match = phone_number_pattern.search(response)\n    return bool(match)", 1.0]], "cases": [["确保使用短横线连接，例如这样的格式：987-6543-2100。", true], ["请拨打123-45-6789联系我。", false], ["我的电话号码是123-4567-8900。", true]]}
{"instruction": "回答中的每个段落开头必须使用四个空格进行缩进。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(paragraph.startswith('    ') for paragraph in paragraphs if paragraph.strip())", 1.0]], "cases": [["    这是正文第一段。\n这是正文第二段，但是没有进行缩进。", false], ["    这是正文第一段。\n    这是正文第二段，也遵循了规则。", true], ["这是正文第一段没有缩进。\n    这是正文第二段，但未全部遵循规则。", false]]}
{"instruction": "在回答的结尾列出“参考资料：”并用星号 * 表示列表项。", "eval_func": [["def evaluate(response):\n    if not response.endswith('参考资料：'):\n        return False\n\n    lines = response.split('\\n')\n    references_index = -1\n    for i, line in enumerate(lines):\n        if '参考资料：' in line:\n            references_index = i\n            break\n\n    if references_index == -1:\n        return False\n\n    for line in lines[references_index+1:]:\n        if not line.startswith('* '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if '参考资料：' in response and response.strip().endswith('参考资料：'):\n        lines = response.split('\\n')\n        if len(lines) > 1 and all(line.strip().startswith('*') for line in lines if '参考资料：' not in line):\n            return True\n        else:\n            return False\n    return False", 1.0], ["def evaluate(response):\n    # Check if the response ends with a reference list following the pattern\n    if response.endswith('\\n'):\n        response = response[:-1]\n    ref_section = response.split('\\n')[-1]\n    # Check if the reference section starts with the correct prefix\n    if not ref_section.startswith('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):\n        return False\n    # Check if each item in the reference list starts with an asterisk followed by a space\n    ref_items = ref_section[len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):].split('\\n')\n    for item in ref_items:\n        if not item.startswith('* '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if not response.strip().endswith('参考资料：'):\n        return False\n    last_line_index = response.rfind('\\n')\n    if last_line_index == -1:\n        return False\n    reference_header = response[last_line_index + 1:].strip()\n    if reference_header != '参考资料：':\n        return False\n    list_items = response[:last_line_index].strip().split('\\n')\n    list_items = [item for item in list_items if item.strip() != '']\n    if not all(item.strip().startswith('*') for item in list_items):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Check if '参考资料：' exists at the end of the string before any lists\n    reference_index = response.rfind('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A')\n    if reference_index == -1 or reference_index + len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A') != len(response.strip()) - 1:\n        return False\n\n    # Verify if the lines after '参考资料：' are formatted as list items with asterisks\n    list_items = response[reference_index + len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):].strip().split('\\n')\n    for item in list_items:\n        if not item.startswith('* '):\n            return False\n    return True", 1.0]], "cases": [["正确的回答但没有参考资料。", false], ["这是另一个回答。\n参考资料：\n* 参考文献1\n错误格式的参考文献", false]]}
{"instruction": "回答必须用圆括号包含所有出现的英文单词，例如（example）。", "eval_func": [["import re\n\ndef evaluate(response):\n    # Check if all English words are enclosed in parentheses\n    words = re.findall(r'[a-zA-Z]+', response)\n    for word in words:\n        if f'（{word}）' not in response:\n            return False\n    return True", 1.0]], "cases": [["这个函数都会（return）（True）如果所有的单词都被正确地（enclosed）。", true], ["每一个（English）（word）（is）（bracketed）。", true], ["如果这个句子有 words not in parentheses, 返回（False）。", false]]}
{"instruction": "回答中要求有5个不同的章节标题，每个标题都是markdown的四级标题，比如“#### 第一章”", "eval_func": [["def evaluate(response):\n    import re\n    if not isinstance(response, str):\n        return False\n    \n    headers = re.findall(r'#### 第[一-龥零九]+章', response)\n    if len(headers) != 5:\n        return False\n    \n    unique_headers = set(headers)\n    if len(unique_headers) != 5:\n        return False\n    \n    return True", 1.0], ["def evaluate(response):\n    # Check if there are exactly five headings in the response\n    headings = [line.strip() for line in response.split('\\n') if line.strip().startswith('#### ')]\n    if len(headings) != 5:\n        return False\n    \n    # Check if all the headings are unique\n    if len(set(headings)) != 5:\n        return False\n    \n    # Check if headings are properly formatted\n    for heading in headings:\n        # Each heading should have the form '#### 第x章' where x is a number or a word\n        if not heading.startswith('#### 第') or not heading.endswith('章'):\n            return False\n    \n    return True", 1.0], ["def evaluate(response):\n    import re\n    \n    headers = re.findall(r'^#### 第一章$|^#### 第二章$|^#### 第三章$|^#### 第四章$|^#### 第五章$', response, re.MULTILINE)\n    unique_headers = set(headers)\n    return len(unique_headers) == 5", 1.0], ["def evaluate(response):\n    # Check that there are 5 distinct headers matching the format with unique titles\n    headers = set()\n    lines = response.split('\\n')\n    for line in lines:\n        if line.startswith('#### '):\n            headers.add(line.strip())\n    return len(headers) == 5", 1.0], ["def evaluate(response):\n    import re\n\n    # Define the pattern to match markdown headers\n    pattern = r'(#### 第一章|#### 第二章|#### 第三章|#### 第四章|#### 第五章)'\n\n    # Find all matches of the pattern\n    matches = re.findall(pattern, response)\n\n    # Check if there are exactly 5 different chapter titles\n    if len(matches) == 5 and len(set(matches)) == 5:\n        # Check if there is any other level 4 markdown header\n        other_headers = re.findall(r'#### .+', response)\n        return len(other_headers) == 5\n    else:\n        return False", 1.0]], "cases": [["#### 第一章\n\nSome content here.\n\n#### 第二章\n\nSome other content here.\n\n### 第三章\n\nThis is not a fourth-level header.\n\n#### 第四章\n\nAdditional content.", false], ["#### 第一章\n\nSome content.\n\n#### 第二章\n\nSome other content.\n\n#### 第三章\n\n#### 第四章\n\nMore content.\n\n#### 第五章\n\nLast bit of content.", true], ["#### 第一章\n\nSome content here.\n\n#### 第二章\n\nSome other content here.\n\n#### 第三章\n\nMore content.\n\n#### 第四章\n\nAdditional content.\n\n#### 第五章\n\nLast bit of content.", true]]}
{"instruction": "确保回答中包含分隔线，使用markdown的三个或更多连续星号表示，例如 ******", "eval_func": [["def evaluate(response):\n    return '****' in response", 1.0]], "cases": [["这个回答没有分隔线，所以应该返回False。", false], ["这个回答包含一个不够长的分隔线, 如 ***, 应该返回False。", false], ["这是一个带有分隔线的回答\n******\n确保它被正确处理。", true]]}
{"instruction": "回答中每一段的首行需要缩进，使用四个空格表示。", "eval_func": [["def evaluate(response):\n    if not response.splitlines():  # If the response is empty or just newline characters, return False\n        return False\n\n    for line in response.splitlines():\n        if not line.startswith('    '):  # Check if each line starts with four spaces\n            return False\n        if not line[4:].strip():  # If there's nothing but spaces after the indentation, return False.\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if len(paragraph) == 0:\n            continue\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):  # Check if the first line starts with four spaces\n            return False\n        if '\\n' in paragraph[4:]:  # Ensure that subsequent lines do not have indentation\n            return False\n    return True", 1.0]], "cases": [["This is a line without indentation.", false], ["这是第一段但未缩进。\n    这是第二段，正确缩进了。", false], ["    第一段正确。\n第二段未缩进。\n    第三段正确。", false], ["    这是第一段的首行，严格遵守要求。\n    这是第二段的首行，同样遵守要求。", true], ["    This is a paragraph with correct indentation.\nBut this line should be indented as it's in the same paragraph.", false], ["    This is the first line of the first paragraph.\n    This is the first line of the second paragraph.", true]]}
{"instruction": "回答中所有数字必须使用阿拉伯数字表示，不能使用文字描述。", "eval_func": [["def evaluate(response):\n    for char in response:\n        if char.isdigit():\n            continue\n        if char.isnumeric() and not char.isdigit():\n            return False\n    return True", 0.875], ["def evaluate(response):\n    import re\n    # Check if any numeric values are written as Chinese characters or other textual representations.\n    chinese_numerals = '零一二三四五六七八九十百千万亿'\n    return all(char.isdigit() or not char in chinese_numerals for char in response)", 0.875], ["def evaluate(response):\n    import re\n    # Regex pattern to match any full-width or traditional Chinese numerals or any text that \n    # suggests a number in textual form (e.g., '一', '十', '百', '千', '万', etc.)\n    pattern = '[一二三四五六七八九十百千万亿兆]|[壹贰叁肆伍陆柒捌玖拾佰仟万亿兆]'\n    # Search for occurrences of Chinese numerals using the regex pattern\n    match = re.search(pattern, response)\n    # If a match was found, some number is not in Arabic numerals\n    return match is None", 0.875]], "cases": [["我有两个苹果。", false], ["我有3个苹果。", true], ["我的年龄是25岁。", true], ["数字包括123和456。", true], ["我有3只猫。", true], ["成绩提高了10分，现在是90分。", true], ["我有三个苹果。", false], ["五湖四海。", false]]}
{"instruction": "每一行回答的开始需要先标明行号，格式为“(n) ”，其中n是行号，从1开始递增。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for i, line in enumerate(lines, 1):\n        if not line.startswith(f'({i}) '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for index, line in enumerate(lines, start=1):\n        expected_prefix = f'({index}) '\n        if not line.startswith(expected_prefix):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by lines to evaluate each line separately\n    lines = response.split('\\n')\n    for i, line in enumerate(lines, start=1):\n        # Check if the line starts with the correct line number\n        if not line.startswith(f'({i}) '):\n            return False\n        # Additional checks can be applied here if there were more instructions\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for i, line in enumerate(lines, start=1):\n        if not line.startswith(f'({i}) '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Break the response into lines\n    lines = response.split('\\n')\n    for i, line in enumerate(lines, start=1):\n        # Create the expected line prefix\n        expected_prefix = f'({i}) '\n        # Check if the line starts with the expected prefix\n        if not line.startswith(expected_prefix):\n            return False\n    return True", 1.0]], "cases": [["(1) This is the first line.\n(2) And this is the second.", true], ["1) Missed the parenthesis.\n(2) This line is fine.", false], ["(1) Correct format.\n(2) Correct format.\n(3) Correct format.", true]]}
{"instruction": "回答中最少使用4个不同的HTML实体，比如&copy;表示版权符号。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the pattern to search for HTML entities\n    pattern = r'&[a-zA-Z0-9]+;'\n    # Find all unique HTML entities in the response\n    found_entities = set(re.findall(pattern, response))\n    # Check if there are at least 4 unique HTML entities\n    return len(found_entities) >= 4", 0.8333333333333334], ["def evaluate(response):\n    import html\n    import re\n    # Match all HTML entities in the response\n    entities = re.findall(r'&[#\\w]+;', response)\n    # Decode entities and filter out non-unique ones\n    unique_entities = set(html.unescape(entity) for entity in entities)\n    # Evaluate if there are at least 4 unique entities\n    return len(unique_entities) >= 4", 1.0], ["def evaluate(response):\n    import re\n    entities = re.findall(r'&[a-zA-Z0-9]+;', response)\n    unique_entities = set(entities)\n    return len(unique_entities) >= 4", 0.8333333333333334]], "cases": [["&#60;&#62;&amp;&apos;&quot;Hello", true], ["&copy;&reg;&euro;&yen;Symbols", true], ["&#60;&#60;&#60;&#60;Hi there", false], ["在HTML中，我们使用&copy;表示版权符号，&gt;表示大于，&lt;表示小于，&amp;表示和号。", true], ["HTML实体很有用&mdash;比如&ndash;, &permil; 和 &euro; 来格式化文本。", true], ["请注意，实体只使用了三个：&copy;，&quot;和&apos;。", false]]}
{"instruction": "回答的每个部分都必须由一个清单开头，用markdown的项目列表表示并且加粗，例如 - **列表项**", "eval_func": [["def evaluate(response):\n    import re\n\n    # Define a regular expression pattern for a bolded markdown list item\n    pattern = re.compile(r'(- \\*\\*[^*]+\\*\\*)')\n\n    # Split the input text into parts using newline as delimiter\n    parts = response.strip().split('\\n')\n\n    # Iterate over each part\n    for part in parts:\n        # If a part is empty, continue to the next part\n        if not part.strip():\n            continue\n\n        # Check if each part starts with a bolded markdown list item\n        if not pattern.match(part.strip()):\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n\n    # Regular expression to match the specified pattern\n    pattern = re.compile(r'(- \\*\\*.+\\*\\*)')\n    parts = response.split('\\n')\n    \n    for part in parts:\n        # Skip empty lines\n        if not part.strip():\n            continue\n        # Check if each part adheres to the pattern\n        if not pattern.fullmatch(part.strip()):\n            return False\n    return True", 1.0]], "cases": [["- **清单项1**\n\n-清单项2\n\n- **清单项3**", false], ["- **清单项1**\n\n- **清单项2**\n\n- **清单项3**", true], ["- **清单项1**\n其他文字\n\n- **清单项2**\n更多的文字\n\n- **清单项3**", false]]}
{"instruction": "回答中至少用两种不同的颜色突出文字，使用HTML的<span>和style属性实现。", "eval_func": [["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class StyleCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.styles = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style':\n                        self.styles.add(attr[1])\n\n    # Instantiate parser and feed the response\n    parser = StyleCounter()\n    parser.feed(response)\n\n    # Check if at least two different colors are used in styles\n    colors = [s for s in parser.styles if 'color' in s]\n    unique_colors = set(color.split(':')[1].strip() for color in colors)\n    return len(unique_colors) >= 2", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class StyleParser(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                style_attr = dict(attrs).get('style', '')\n                color_value = next((value[6:] for value in style_attr.split(';') if value.startswith('color')), None)\n                if color_value:\n                    self.colors.add(color_value.strip())\n\n    # Parse the input response\n    parser = StyleParser()\n    parser.feed(response)\n\n    # The response is valid if at least two unique colors are used\n    return len(parser.colors) >= 2", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class ColorCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style':\n                        parts = attr[1].split(';')\n                        for part in parts:\n                            if 'color' in part:\n                                color_value = part.split(':')[1].strip()\n                                self.colors.add(color_value)\n\n    parser = ColorCounter()\n    parser.feed(response)\n\n    return len(parser.colors) >= 2", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n    class StyleParser(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                style = dict(attrs).get('style', '')\n                if 'color:' in style:\n                    color_val = style.split('color:')[-1].split(';')[0].strip()\n                    self.colors.add(color_val)\n\n    parser = StyleParser()\n    parser.feed(response)\n\n    return len(parser.colors) >= 2", 1.0]], "cases": [["<p>All text is <span style=\"color: red;\">red</span> here only.</p>", false], ["<p>This is a <span style=\"color: red;\">red</span> word and another <span style=\"color: blue;\">blue</span> word.</p>", true], ["<p>This text has <span style='color: red;'>red</span> and <span style='color: blue;'>blue</span> highlights.</p>", true], ["<p>This text has <span style='color: red;'>red</span> and no other color.</p>", false], ["<p>No color <b style='color: green;'>or</b> highlights.</p>", false], ["<p>Text with <b style=\"color: green;\">bold green</b> and without span.</p>", false]]}
{"instruction": "每一段落的首个字需要加上上标注记，使用HTML的<sup>标签表示。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Split the response into paragraphs by looking for newline characters\n    paragraphs = response.split('\\n')\n\n    # Define the regular expression to match a paragraph starting with <sup>\n    pattern = re.compile(r'^<sup>.</sup>')\n\n    # Check each paragraph to ensure it follows the instruction\n    for paragraph in paragraphs:\n        # Skip empty paragraphs\n        if not paragraph.strip():\n            continue\n\n        # If the paragraph doesn't start with <sup>, return False\n        if not pattern.match(paragraph):\n            return False\n\n    # If all paragraphs start with <sup>, return True\n    return True", 0.8333333333333334]], "cases": [["<sup>每</sup>一段落的首个字需要加上上标注记，使用HTML的<sup>标签表示。\n<sup>这</sup>是第二段落。\n<sup>第</sup>三段的样例文本。", true], ["<sup>每</sup>个段落开始都正确。\n<sup>但</sup>这里<sup>漏</sup>掉了一个<sup>.</sup>", false], ["<sup>每</sup>一段落的首个字需要加上上标注记，使用HTML的<sup>标签表示。\n这是没有上标的第二段落。\n<sup>第</sup>三段的样例文本。", false], ["每<sup>一</sup>段落的首个字需要加上上标注记，使用HTML的<sup>标签表示。\n<sup>包</sup>括这个段落。", false], ["每一段落的首个字需要上标，但是这个没有使用<sup>标签。\n<sup>而</sup>这一段使用了。", false], ["<sup>每</sup>一段落的首个字需要加上上标注记，使用HTML的<sup>标签表示。\n<sup>包</sup>括这个段落。", true]]}
{"instruction": "在回答中提供一个列表，使用 markdown 箭头列表`> - 列表项`格式表示层级。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not line.startswith('> - '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response: str) -> bool:\n    lines = response.strip().split('\\n')\n    for line in lines:\n        stripped_line = line.strip()\n        if not stripped_line.startswith('> - '):\n            return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        stripped_line = line.strip()\n        if not stripped_line.startswith('> - '):\n            return False\n    return True", 0.8333333333333334]], "cases": [["> - 列表项1\n> - 列表项2\n> - 列表项3", true], ["> - 列表项1\n> - 列表项2\n>   - 列表项2.1\n> - 列表项3", false], ["> - 第一级\n > - 第二级\n  > - 第三级", false], ["> - 第一级\n> - 第二级\n> - 第三级", true], ["> - 第一级\n>    - 第二级\n>      - 第三级", false], ["> - 列表项1\n- 列表项2\n> - 列表项3", false]]}
{"instruction": "回答要求列出至少3个步骤，步骤之间用带有箭头的符号表示顺序，例如 “步骤1 → 步骤2 → 步骤3”", "eval_func": [["def evaluate(response):\n    steps = response.split(' → ')\n    if len(steps) < 3:\n        return False\n    for step in steps:\n        if not step.startswith('步骤') and not step[2:].isdigit():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    steps = response.split('→')\n    if len(steps) < 3:\n        return False\n    for step in steps:\n        if not step.strip().startswith('步骤'):\n            return False\n    return True", 1.0], ["def evaluate(response): \n    steps = response.split(' → ') \n    if len(steps) < 3: \n        return False \n    for step in steps: \n        if not step.startswith('步骤') or not step[2:].isdigit(): \n            return False \n    return True", 1.0], ["def evaluate(response):\n    steps = response.split(' → ')\n    if len(steps) < 3:\n        return False\n    for step in steps:\n        if not step.startswith('步骤1') and not any(step.startswith(f'步骤{i}') for i in range(2, len(steps) + 1)):\n            return False\n    return True", 1.0]], "cases": [["步骤1-步骤2-步骤3", false], ["步骤1 → 步骤2 → 步骤3", true], ["步骤1 → 步骤2 → 步骤3 → 步骤4", true]]}
{"instruction": "每个项目列表项之后必须跟上说明性文字，文字要用括号包围，例如 - 重点内容(请参考以下说明)", "eval_func": [["def evaluate(response):\n    import re\n\n    def is_valid_entry(entry):\n        # Check if there's a bracketed explanation after the list item\n        return re.fullmatch(r'.+\\(.*\\)$', entry.strip()) is not None\n\n    # Separate the response into a list of items\n    items = response.split('-')[1:] # split and remove the first empty item\n\n    # Evaluate each item\n    for item in items:\n        if not is_valid_entry(item):\n            return False\n    return True if items else False", 1.0]], "cases": [["- 项目一(项目一说明) - 项目二(项目二说明) - 项目三", false], ["- 项目一 - 项目二(项目二说明) - 项目三(项目三说明)", false], ["- 项目一(项目一说明) - 项目二(项目二说明) - 项目三(项目三说明)", true]]}
{"instruction": "回答中的每个句子必须以数字开始，例如\"1 xxxxx。2 xxxxx。\"，而且每个句子的数字必须连续。", "eval_func": [["def evaluate(response):\n    if not response:\n        return False\n    sentences = response.split('。')\n    if sentences[-1] == '':\n        sentences.pop()\n    current_num = 0\n    for sentence in sentences:\n        parts = sentence.strip().split(' ', 1)\n        if len(parts) < 2:\n            return False\n        try:\n            num = int(parts[0])\n            if num != current_num + 1:\n                return False\n            current_num = num\n        except ValueError:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.split('。')\n    if not sentences[-1]:\n        sentences.pop()  # Remove the last empty item after split\n    \n    expected_number = 1\n    for sentence in sentences:\n        parts = sentence.strip().split(' ', 1)\n        if len(parts) != 2:\n            return False  # No space or more than one space\n        \n        number_str, _ = parts\n        if not number_str.isdigit():\n            return False  # Not a number at the beginning\n        \n        number = int(number_str)\n        if number != expected_number:\n            return False  # Numbers are not consecutive\n        \n        expected_number += 1\n    \n    return True", 1.0], ["def evaluate(response):\n    import re\n    sentences = re.split(r'(?<!\\d)[。]\\s*', response)\n    if sentences[-1] == '':\n        sentences.pop()\n    for index, sentence in enumerate(sentences):\n        sentence_num = sentence.split(' ', 1)[0]\n        if not sentence_num.isdigit() or int(sentence_num) != index + 1:\n             return False\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.strip().split('。')\n    # Remove empty elements that may result from the split\n    sentences = [s for s in sentences if s.strip()]\n\n    last_number = 0\n    for sentence in sentences:\n        parts = sentence.strip().split(' ', 1)\n        # Check if the sentence starts with a number and has content following it\n        if len(parts) != 2:\n            return False\n\n        try:\n            number = int(parts[0])\n        except ValueError:\n            return False\n\n        # Check if the numbers are consecutive and the sequence starts at 1\n        if number != last_number + 1:\n            return False\n\n        last_number = number\n\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.split('。')\n    if not sentences[-1]:\n        sentences = sentences[:-1]  # Remove the empty string after the last period\n\n    expected_num = 1\n    for sentence in sentences:\n        parts = sentence.strip().split(' ', 1)\n        if len(parts) != 2:\n            return False\n\n        try:\n            num = int(parts[0])\n        except ValueError:\n            return False\n\n        if num != expected_num:\n            return False\n        expected_num += 1\n\n    return True", 1.0]], "cases": [["1 这是第一句。2 这是第二句。", true], ["1 这是第一句。3 这是第三句，错了。", false], ["一 这是不正确的开头。", false]]}
{"instruction": "插入一个Markdown的图片链接，格式为\"![描述](图片地址)\"，必须有描述和真实可访问的图片地址。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to match Markdown image link with a description and URL\n    pattern = r'!\\[([^\\]]+)\\]\\((https?:\\/\\/(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+)\\)'\n    # Check if the response matches the pattern\n    match = re.fullmatch(pattern, response)\n    # The match succeeds only if there's a description and the URL seems valid\n    if match:\n        description, url = match.groups()\n        if description and url:\n            return True\n    return False", 1.0]], "cases": [["![A beautiful landscape](https://example.com/image.png)", true], ["![Another image](http://notarealwebsite.com/img.jpg)", true], ["![](https://example.com/no_description.jpg)", false]]}
{"instruction": "回答中需要有一个二级标题，紧接着是一个由三个连续中划线组成的分隔线，Markdown格式如\"## 二级标题\\n---\"。", "eval_func": [["def evaluate(response):\n    import re\n    # The pattern checks for the specific Markdown formatting for the subtitle and separator\n    pattern = r'^## \\u4e8c\\u7ea7\\u6807\\u9898\\n---$'\n    # Using re.match to check if the response follows the pattern exactly from start to end\n    return bool(re.match(pattern, response))", 1.0]], "cases": [["## 二级标题\n---", true], ["## This is not the correct header\n---", false], ["## 二级标题\n---\nMore text", false]]}
{"instruction": "回答应该包含一个列表，列表项之间以单换行`\\n`分隔。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    if not lines or len(lines) < 2:\n        return False\n    for line in lines:\n        if not line.startswith('- '):\n            return False\n    return True", 1.0]], "cases": [["- item1\n- item2\n- item3", true], ["item1\nitem2\nitem3", false], ["- item1\nitem2\n- item3", false]]}
{"instruction": "回答中需要包含一个带有至少3个项目符号列表项的无序列表，每个列表项用\"-\"表示。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    bullet_count = 0\n    for line in lines:\n        if line.startswith('- '):\n            bullet_count += 1\n    return bullet_count >= 3", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    bullet_count = 0\n\n    for line in response_lines:\n        stripped_line = line.strip()\n        if stripped_line.startswith('-'):\n            bullet_count += 1\n\n    return bullet_count >= 3", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    lines = response.strip().split('\\n')\n    list_count = 0\n    # Iterate through each line to search for unordered list items\n    for line in lines:\n        # Strip leading and trailing spaces and check if it starts with '-'\n        stripped_line = line.strip()\n        if stripped_line.startswith('-'):\n            list_count += 1\n    # Check if there are at least 3 list items\n    return list_count >= 3", 1.0], ["def evaluate(response):\n    bullet_points = response.split('\\n')\n    bullet_count = 0\n    for point in bullet_points:\n        if point.startswith('- '):\n            bullet_count += 1\n    return bullet_count >= 3", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    bullet_points = [line.strip() for line in items if line.strip().startswith('-')]\n    return len(bullet_points) >= 3", 1.0]], "cases": [["- Item 1\\n* Item 2 with an asterisk\\n- Item 3\\n- Item 4", false], ["- One item only", false]]}
{"instruction": "回答需要使用至少2种字体加粗的方法，包括Markdown的双星号`**加粗**`和双下划线`__加粗__`。", "eval_func": [["def evaluate(response):\n\tmd_bold = '**'\n\tunderscore_bold = '__'\n\tmd_count = response.count(md_bold)\n\tunderscore_count = response.count(underscore_bold)\n\n\t# Check if both bold methods are used at least once\n\tif md_count >= 2 and underscore_count >= 2:\n\t\t# Check for properly closed tags\n\t\tmd_proper = response.split(md_bold)\n\t\tunderscore_proper = response.split(underscore_bold)\n\n\t\t# There must be an even number of markdowns or underscores (opening and closing pairs)\n\t\tif len(md_proper) % 2 == 1 and len(underscore_proper) % 2 == 1:\n\t\t\treturn True\n\n\treturn False", 1.0], ["def evaluate(response):\n    bold_markdown = '**'\n    bold_underline = '__'\n\n    def contains_bold(text, delimiters):\n        start = text.find(delimiters)\n        end = text.rfind(delimiters)\n        return start != -1 and end != -1 and start != end\n\n    markdown_bold = contains_bold(response, bold_markdown)\n    underline_bold = contains_bold(response, bold_underline)\n\n    return markdown_bold and underline_bold", 1.0], ["def evaluate(response):\n    bold_md = '**'\n    bold_ud = '__'\n    parts = response.split(' ')\n    has_md_bold = any(part.startswith(bold_md) and part.endswith(bold_md) for part in parts)\n    has_ud_bold = any(part.startswith(bold_ud) and part.endswith(bold_ud) for part in parts)\n\n    if has_md_bold and has_ud_bold:\n        return True\n    else:\n        return False", 1.0]], "cases": [["回答包含 **Markdown加粗** 以及 __HTML加粗__", true], ["未使用技术要求的任何加粗方式", false], ["只使用了一种加粗方式：**Markdown加粗**", false]]}
{"instruction": "回答需要包含一个水平线分割符，使用Markdown的三个或更多连续星号***表示。", "eval_func": [["def evaluate(response):\n    import re\n    return bool(re.search(r'^.*\\n?\\*{3,}.*$', response, re.MULTILINE))", 1.0], ["def evaluate(response: str) -> bool:\n    return '***' in response and response.count('***') == 1 and not any(seq in response for seq in ['****', '*****', '******'])", 1.0], ["def evaluate(response):\n    return '***' in response and response.count('****') == 0", 1.0]], "cases": [["这是一个答案\\n***\\n这是分割线后的内容", true], ["这是一个分割线但是用的不是星号----", false], ["忘记加水平线分割符了", false]]}
{"instruction": "回答中必须包括一个内联代码，使用Markdown格式的反引号表示，如`内联代码`。", "eval_func": [["def evaluate(response):\n    # Search for inline code markdown pattern\n    inline_code_pattern = '`[^`]+`'\n    search_result = re.search(inline_code_pattern, response)\n\n    # Check if there is exactly one match\n    if search_result:\n        # Make sure there are not more than one inline code markdowns\n        return response.count('`') == 2\n    else:\n        return False", 1.0]], "cases": [["这里没有使用Markdown格式表示的内联代码。", false], ["这是一个例子，它包含一个内联代码`example`。", true], ["这个例子有`多个`内联`代码`。", false]]}
{"instruction": "回答应开头包含至少3个问号表示的占位符，格式为\"??? 处理内容\"。", "eval_func": [["def evaluate(response):\n    return response.startswith('??? ') and ' ' in response[4:]", 0.8333333333333334], ["def evaluate(response):\n    # Checking if the response starts with at least three question marks\n    if not response.startswith('???'):\n        return False\n\n    # Split the string by spaces to analyze the parts\n    parts = response.split(' ')\n    if len(parts) < 2:\n        return False # There must be a part after the '???'\n\n    # Confirm that the first three characters are question marks\n    if parts[0][:3] != '???':\n        return False\n\n    # Confirm there is additional text after the question marks\n    after_question_marks = response[3:].strip()\n    if not after_question_marks:\n        return False\n\n    # Evaluation passed, the instruction is followed\n    return True", 0.8333333333333334], ["def evaluate(response):\n    return response.startswith('??? ') and len(response) > 4", 1.0]], "cases": [["???Another invalid response with no space after placeholder.", false], ["??? This is a valid response with the placeholder at the beginning.", true], ["?? This is an invalid response with two question marks.", false], ["???处理内容没有空格", false], ["??? 这里是处理内容", true], ["?? 这是不足的占位符", false]]}
{"instruction": "回答必须有序列出5条信息，使用Markdown格式，每条信息前加上复选框\" - [ ] 信息\"，全部留空。", "eval_func": [["def evaluate(response):\n    # Split the response by newline to get individual items\n    items = response.strip().split('\\n')\n\n    # Check for exactly 5 items\n    if len(items) != 5:\n        return False\n\n    # Check if each item starts with the correct markdown checkbox format\n    for item in items:\n        if not item.startswith('- [ ] '):\n            return False\n\n    # Check if the rest of each item (after the checkbox) is non-empty\n    for item in items:\n        content = item[6:].strip()  # Remove '- [ ] ' and any leading/trailing whitespace\n        if not content:\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if len(lines) != 5:\n        return False\n    for line in lines:\n        if not line.startswith('- [ ] '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    lines = response.strip().split('\\n')\n    # Check that there are exactly 5 lines with checkboxes\n    if len(lines) != 5:\n        return False\n    # Check each line follows the necessary format\n    for line in lines:\n        if not line.startswith('- [ ] '):\n            return False\n    # If all lines are correct, return True\n    return True", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if len(lines) != 5:\n        return False\n    for line in lines:\n        if not line.startswith('- [ ] '):\n            return False\n        if len(line) <= 6 or line[6] == ' ':\n            return False\n    return True", 1.0]], "cases": [["- [ ] 信息1\n- [ ] 信息2\n- [ ] 信息3\n- [ ] 信息4", false], ["- [X] 信息1\n- [ ] 信息2\n- [ ] 信息3\n- [ ] 信息4\n- [ ] 信息5", false], ["- [ ] 信息1\n- [ ] 信息2\n- [ ] 信息3\n- [ ] 信息4\n- [ ] 信息5", true]]}
{"instruction": "回答以单词\"结尾\"结束，并且此单词必须是斜体和加粗，即Markdown格式为`***结尾***`。", "eval_func": [["def evaluate(response):\n    target_str = '***结尾***'\n    return response.endswith(target_str) and response.count(target_str) == 1", 1.0], ["def evaluate(response):\n    return response.endswith('***结尾***')", 1.0], ["def evaluate(response):\n    # Define the strict ending pattern\n    target_ending = '***结尾***'\n    return response.endswith(target_ending) and response.count(target_ending) == 1", 1.0], ["def evaluate(response):\n    # Compare the response with the specified Markdown format for the word '结尾'\n    expected_suffix = '***结尾***'\n    # Check if response ends with the expected suffix and if the suffix is in the right format\n    return response.endswith(expected_suffix)", 1.0]], "cases": [["答案的最后必须是这个词：**结尾**", false], ["这是一个完整的回答，它的结尾是这样***结尾***", true], ["请注意格式，答案应该是这样的：结尾", false], ["最后的单词虽然符合格式，但不是正确的单词***结束***", false], ["这是我对问题的回答，答案是***结尾***", true], ["这个回答没有正确的结束格式结尾", false], ["这个回答的***结尾***没有加粗和斜体", false], ["回答看起来不错，但没有用正确的Markdown格式结束: 结尾", false], ["这是一条回答，它以正确的格式结束***结尾***", true]]}
{"instruction": "回答中至少包含一个用尖括号`< >`括起来的HTML标签，例如`<p>`。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = re.compile(r'<[^>]+>')\n    return bool(pattern.search(response))", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern for a simple HTML tag enclosed in angle brackets\n    pattern = r'<\\w+?>|</\\w+?>'\n    # Search for at least one HTML tag in the response string\n    return bool(re.search(pattern, response))", 0.8888888888888888], ["def evaluate(response):\n    import re\n    # Regular expression for matching <tag> where tag can be anything except spaces and angle brackets\n    pattern = re.compile(r'<[^\\s<>]+>')\n    # Search for the pattern in the response\n    return bool(pattern.search(response))", 1.0]], "cases": [["另一个示例 <br/>", true], ["这是一个包含HTML标签的回答 <p>", true], ["这是一个包含标签的回答 <p>段落</p>", true], ["这个响应没有HTML标签。", false], ["这是一个包含HTML标签的响应<p>。", true], ["仅仅是这样的括号<>并不足以构成一个有效的HTML标签。", false], ["这个回答's有误，HTML标签应该用尖括号 <html>", true], ["这个答案没有尖括号包围的内容", false], ["这个回答没有HTML标签", false]]}
{"instruction": "回答中每个段落后面必须跟随一个空白行，使用Markdown的换行表示`\\n`。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    # Iterate over the paragraphs and check the following element\n    for idx, paragraph in enumerate(paragraphs[:-1]):\n        if paragraph.strip() and (idx + 1 < len(paragraphs)) and paragraphs[idx + 1] != '':\n            return False\n    return True if paragraphs[-1] == '' else False", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for i in range(len(paragraphs)-1):\n        if not paragraphs[i].strip():\n            continue # Skip multiple blank lines.\n        if paragraphs[i] and paragraphs[i+1].strip():\n            return False\n    return True", 0.8], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    # Check if every paragraph (except potentially the last) is followed by an empty line\n    for i in range(len(paragraphs) - 1):\n        if paragraphs[i].strip() and (i + 1 < len(paragraphs)) and paragraphs[i + 1].strip():\n            return False\n    # Check if the response ends with a non-empty line (which also violates the instruction)\n    if paragraphs[-1].strip():\n        # There should be a trailing empty line hence the last element should be empty after a split\n        return False\n    return True", 1.0]], "cases": [["\n这是一个段落，但是前面多了一个换行。\n\n", true], ["第一个段落。\n\n第二个段落。\n\n第三个段落没有空白行。", false], ["第一个段落后面没有空格行。\n这是第二个段落。\n\n", false], ["这是第一个段落。\n\n这是第二个段落。\n\n", true], ["这是第一个段落。\n这是第二个段落。\n\n", false]]}
{"instruction": "回答应该包括四个以标准缩进块格式的代码行，每个代码行使用四个空格开始。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    if len(lines) != 4:\n        return False\n    for line in lines:\n        if not line.startswith('    '):\n            return False\n        if line[4:].startswith(' '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    if len(lines) != 4:\n        return False\n    for line in lines:\n        if not line.startswith('    '):\n            return False\n        stripped_line = line[4:]\n        if stripped_line.startswith(' '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    if len(lines) != 4:\n        return False\n    for line in lines:\n        if not line.startswith('    '):  # Check if line starts with four spaces\n            return False\n        if len(line) > 4 and line[4] == ' ':\n            return False  # Check if there's an extra space after the standard indent\n    return True", 1.0]], "cases": [["    line_one = 1\n    line_two = 2\n    line_three = 3\n    line_four = 4", true], ["    line_one = 1\n\tline_two = 2\n    line_three = 3\n    line_four = 4", false], ["line_one = 1\n    line_two = 2\n    line_three = 3\n    line_four = 4", false]]}
{"instruction": "回答中必须包含一个用来表示重要信息的双下划线加粗文本，格式为`__重要信息__`。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'__[^\\s]+__'\n    matches = re.findall(pattern, response)\n    return any(len(match) > 4 and match.startswith('__') and match.endswith('__') for match in matches)", 1.0], ["def evaluate(response):\n    import re\n    # Use a regular expression to find the bolded text with double underscores\n    pattern = re.compile(r'__.*?__')\n    matches = pattern.findall(response)\n\n    # Check that there is exactly one bolded text and it is not empty\n    if len(matches) == 1 and matches[0] != '__':\n        # Ensure the bolded text does not contain any additional double underscores inside\n        if '__' not in matches[0][2:-2]:\n            return True\n    return False", 0.8333333333333334], ["def evaluate(response):\n    import re\n    return bool(re.search(r'__[^\\s]+__', response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'__[一-鿿A-Za-z0-9\\s]+__'\n    matches = re.findall(pattern, response)\n    return bool(matches and all('__' + text.strip('_') + '__' == text for text in matches))", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # Regex to find '__text__' pattern in the response\n    pattern = r'__[^__]+__'\n    matches = re.findall(pattern, response)\n    # Check that there is exactly one match and it uses double underscores\n    return len(matches) == 1 and all('__' in match for match in matches)", 0.8333333333333334]], "cases": [["这是一段回答，但它没有包含需要的格式。", false], ["这是一段回答，其中包含的__重要信息__符合要求。", true], ["这是__非重要信息__，但格式正确。", true], ["这是一条指令，其内容为__重要信息__。", true], ["这段回答中有__不正确的 __格式使用。", false], ["这里没有使用正确的格式。", false]]}
{"instruction": "回答需要使用至少两种不同的文本块引用级别，使用\">\"和\">>\"分别表示。", "eval_func": [["def evaluate(response):\n    has_single_blockquote = '> ' in response\n    has_double_blockquote = '>> ' in response\n    return has_single_blockquote and has_double_blockquote", 1.0], ["def evaluate(response):\n  blockquote_levels = {'>': False, '>>': False}\n\n  lines = response.split('\\n')\n  for line in lines:\n    # Checking if the line starts with either '>' or '>>'\n    if line.startswith('>> '):\n      blockquote_levels['>>'] = True\n    elif line.startswith('> '):\n      blockquote_levels['>'] = True\n\n  return blockquote_levels['>'] and blockquote_levels['>>']", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    single_quote = False\n    double_quote = False\n    for line in lines:\n        if line.startswith('>> '):\n            double_quote = True\n        if line.startswith('> '):\n            # Ensure it's not a '>> ' line\n            if not line.startswith('>>'):\n                single_quote = True\n        # If both single and double quotes have been found, we can return True\n        if single_quote and double_quote:\n            return True\n    # If either quote level is missing, return False\n    return False", 1.0], ["def evaluate(response):\n    blocks = response.split('\\n')\n    has_single_block = any(line.startswith('>') and not line.startswith('>>') for line in blocks)\n    has_double_block = any(line.startswith('>>') for line in blocks)\n    return has_single_block and has_double_block", 1.0]], "cases": [["Here is an example:\n> This is a blockquote.\n>> This is a nested blockquote.", true], ["> This has only one level of blockquote.", false], ["This text doesn't follow the instructions properly.", false]]}
{"instruction": "回答应该包括一个填充式小标题，以颜色和背景样式区分，使用HTML的`<span style>`标记表示。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'<span style=\"[^\"]*color:[^\"]*;?[^\"]*background:[^\"]*;?[^\"]*\">.+?</span>'\n    if re.search(pattern, response):\n        style_attributes = re.findall(r'style=\"([^\"]*)\"', response)\n        for attr in style_attributes:\n            if 'color:' not in attr or 'background:' not in attr:\n                return False  # Some style is missing either color or background\n        return True\n    return False", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class MyHTMLParser(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.span_found = False\n            self.style_found = False\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                self.span_found = True\n                for attr in attrs:\n                    if attr[0] == 'style':\n                        styles = attr[1].lower().split(';')\n                        color_found = any(s.strip().startswith('color') for s in styles)\n                        background_found = any(s.strip().startswith('background') for s in styles)\n                        self.style_found = color_found and background_found\n\n        def handle_endtag(self, tag):\n            if tag == 'span':\n                self.span_found = False\n\n        def handle_data(self, data):\n            if self.span_found and self.style_found:\n                if data.strip():  # Data inside span must not be empty\n                    return True\n            return False\n\n    parser = MyHTMLParser()\n    parser.feed(response)\n    return parser.style_found", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class MyHTMLParser(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.span_found = False\n            self.correct_style = False\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                self.span_found = True\n                for attr in attrs:\n                    if attr[0] == 'style':\n                        styles = [s.strip() for s in attr[1].split(';')]\n                        color_found = any(s.startswith('color:') for s in styles)\n                        background_found = any(s.startswith('background:') for s in styles)\n                        if color_found and background_found:\n                            self.correct_style = True\n\n    def handle_endtag(self, tag):\n        if tag == 'span':\n            self.span_found = False\n\n    def handle_data(self, data):\n        if self.span_found and not data.isspace():\n            self.contains_data = True\n\n    # Create a parser instance\n    parser = MyHTMLParser()\n    parser.feed(response)\n\n    # Evaluate the HTML\n    return parser.span_found and parser.correct_style", 1.0]], "cases": [["<span style=\"color: red; background: blue;\">A Fancy Title</span>", true], ["<span style=\"color: red;\">No Background</span>", false], ["<p>A Paragraph</p>", false]]}
{"instruction": "回答中包含 3 个用 markdown 的无序列表符号表示的要点，每个要点用 “-” 开头。", "eval_func": [["def evaluate(response):\n    try:\n        # Split into lines\n        lines = response.strip().split('\\n')\n\n        # Count the bullet points\n        bullet_points = [line for line in lines if line.startswith('- ')]\n\n        # Check if there are exactly 3 bullet points\n        if len(bullet_points) != 3:\n            return False\n\n        # Ensure that the bullet points are not empty and are formatted correctly\n        for point in bullet_points:\n            if len(point) <= 2 or not point[2:].strip():\n                # If the point is empty or just a dash and space, it's not valid\n                return False\n\n        # If all checks are passed, the response is correctly formatted\n        return True\n    except Exception as e:\n        # In case of any unexpected error, we consider the response not correctly formatted\n        return False", 1.0], ["def evaluate(response):\n    import re\n\n    # The regex looks for three separate list items,\n    # each starting with a dash and a space, possibly\n    # with leading and trailing whitespace.\n    bullet_points_pattern = r'^\\s*-\\s+[^\\n]+\\n(\\s*-\\s+[^\\n]+\\n){2}$'\n    match = re.match(bullet_points_pattern, response, re.MULTILINE)\n\n    # If the pattern is found, we return True, otherwise False.\n    if match:\n        return True\n    else:\n        return False", 0.8333333333333334], ["def evaluate(response):\n    # Split lines and strip whitespace\n    lines = [line.strip() for line in response.split('\\n')]\n\n    # Count the number of bullet points with '-'\n    bullet_points = sum(1 for line in lines if line.startswith('-'))\n\n    # Check if there are exactly 3 bullet points\n    return bullet_points == 3", 0.8333333333333334], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    bullet_points = [line for line in lines if line.startswith('- ')]\n    return len(bullet_points) == 3", 1.0], ["def evaluate(response):\n    # Count how many bullet points are in the response\n    bullet_points = response.strip().split('\\n')\n    count = 0\n    for item in bullet_points:\n        # Check the start of each line for a hyphen\n        if item.startswith('- '):\n            count += 1\n    return count == 3", 1.0]], "cases": [["-First point\n-Second point\n-Third point\n", false], ["- First point\n* Second point\n- Third point\n", false], ["- First point\n- Second point\n- Third point\n", true], ["- First point\n- Second point\n- Third point\n- Fourth point", false], ["- First point\n* Second point using wrong bullet\n- Third point", false], ["- First point\n- Second point\n- Third point", true]]}
{"instruction": "回答的每个部分以“主旨X”开头，并以“。”结束。", "eval_func": [["def evaluate(response):\n    parts = response.split('。')\n    # Remove empty strings if a split occurred right at the end\n    parts = [part for part in parts if part]\n    for part in parts:\n        if not part.startswith('主旨X'):\n            return False\n    return True if response.endswith('。') else False", 0.8333333333333334]], "cases": [["主旨X这是符合规则的句子。主旨X这句也是符合要求的。", false], ["环境保护很重要。主旨X我们要采取有效措施。", false], ["主旨X经济发展要与生态平衡并重。", true], ["主旨X开头但并未以句号结束", false], ["主旨X正确开头。主旨X也正确结束。", true], ["主旨X我们必须保护环境。主旨X减少资源浪费是每个人的责任。", true]]}
{"instruction": "以箭头符号“→”开始每个回答的段落。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(paragraph.startswith('→') for paragraph in paragraphs if paragraph.strip())", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('→'):\n            return False\n    return True if paragraphs else False", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('→'):\n            return False\n    return True", 1.0]], "cases": [["→ 这是遵循指示的一个段落。\n→ 这是另一个遵循指示的段落。", true], ["这个段落不以箭头开始。\n→ 但这个段落是。", false], ["→ 所有的段落都应该以箭头开始。", true]]}
{"instruction": "每个回答中必须包含 3 个用方框括起来的日期表示，例如 [2023-01-01]。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the regex pattern to check for dates within square brackets\n    pattern = r'\\[(\\d{4}-\\d{2}-\\d{2})\\]'\n    # Find all occurrences of the pattern\n    matches = re.findall(pattern, response)\n    # Check if there are exactly three dates within square brackets\n    return len(matches) == 3", 1.0], ["def evaluate(response):\n    import re\n    # Define the pattern to search for dates in the given format\n    date_pattern = r'\\[[0-9]{4}-[0-9]{2}-[0-9]{2}\\]'\n    # Find all matches in the response\n    matches = re.findall(date_pattern, response)\n    # Check if there are exactly three dates in the response\n    return len(matches) == 3", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\[\\d{4}-\\d{2}-\\d{2}\\]'\n    matches = re.findall(pattern, response)\n    return len(matches) == 3", 1.0], ["def evaluate(response):\n    import re\n    # The regex pattern to match dates in the form [YYYY-MM-DD]\n    pattern = re.compile(r'\\[[0-9]{4}-[0-9]{2}-[0-9]{2}\\]')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Check if there are exactly 3 dates in the response\n    return len(matches) == 3", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to match the required date format in brackets\n    date_pattern = r'\\[(\\d{4}-\\d{2}-\\d{2})\\]'\n    # Find all occurrences of date patterns\n    matches = re.findall(date_pattern, response)\n    # Check if there are exactly 3 date patterns\n    return len(matches) == 3", 1.0]], "cases": [["这件事发生在[2021-05-10]，然后在[2021-06-15]发现了新的线索，最终在[2021-07-20]解决了问题。", true], ["只有两个日期：[2022-04-01]和[2022-05-01]。", false], ["日期 [2020-12-25] 出现了一次，日期 [2020-01-01] 也出现了一次。", false]]}
{"instruction": "在回答的开始使用一个块引用标记，使用 markdown 的 “>”。", "eval_func": [["def evaluate(response):\n    return response.startswith('> ')", 1.0], ["def evaluate(response):\n    if not response.startswith('> '):\n        return False\n    lines = response.split('\\n')\n    if not all(line.startswith(('> ', '>')) or line == '' for line in lines):\n        return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    if not response:\n        return False\n    lines = response.split('\\n')\n    if lines[0].startswith('> '):\n        return True\n    else:\n        return False", 1.0]], "cases": [["No blockquote marker here", false], ["> This is a response with blockquote at the beginning.\nFollowing text without blockquote.", true], [" > Leading space before marker", false], ["> Markdown blockquote", true], ["This is a response without blockquote at the beginning.\n> Blockquote starts here.", false], [">Blockquote without space after the symbol.\nStill blockquote without proper formatting.", false]]}
{"instruction": "回答中应包含至少两个用反引号\"`\"包裹的术语。", "eval_func": [["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i].strip():\n            count += 1\n    return count >= 2", 1.0], ["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i]:  # Check if the term is not just empty string\n            count += 1\n    return count >= 2", 1.0], ["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i]:\n            count += 1\n        if count >= 2:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    count = 0\n    tokens = response.split('`')\n    for i in range(1, len(tokens), 2):\n        if tokens[i]:\n            count += 1\n    return count >= 2", 1.0]], "cases": [["在Python中，`list`和`dict`是常用的数据结构。", true], ["在Python中，list和dict是常用的数据结构。", false], ["正确的回答应该有两个术语, 像这样: `术语一`和`术语二`。", true], ["这个应答包含`术语一`但是只有一个。", false], ["使用`map()`函数可以对`iterables`进行操作。", true], ["这是一个包含`术语一`和`术语二`的合格回答。", true]]}
{"instruction": "回答以 markdown 的六级标题格式呈现问题，即使用六个井号“######”。", "eval_func": [["def evaluate(response):\n    # Remove leading and trailing whitespace\n    stripped_response = response.strip()\n    # Check if the response strictly follows the markdown six-level header format\n    return stripped_response.startswith('###### ') and stripped_response.count('#') == 6 and '\\n' not in stripped_response", 1.0], ["def evaluate(response):\n    # Trim the response to ensure we don't count trailing spaces\n    response = response.strip()\n    # Check if the response starts with six hashes followed by a space and then has content\n    if response.startswith('###### ') and len(response) > 7:\n        # Check that there are no more hashes in the rest of the response\n        content = response[7:]\n        return '######' not in content\n    return False", 1.0], ["def evaluate(response):\n    # Check whether the response meets the markdown level six heading format\n    if not response.startswith('###### '):\n        return False\n    # Check that there is some content after the six hashes\n    content = response[7:].strip()\n    if not content:\n        return False\n    # Check for no additional hashes at the beginning\n    if content.startswith('#'):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Your function should check if the input starts with six hashtags followed by a space\n    if not response.startswith('###### '):\n        return False\n    # Strip the six hashtags and the following space, then check if anything is left\n    content = response[7:].strip()\n    # There must be some content after the hashtags for it to be a valid header\n    return bool(content)", 1.0]], "cases": [["###### This is a correct six-level markdown header", true], ["##### Only five hashtags", false], ["######This is not correct because it lacks a space after the hashes", false], ["###### This is a level six heading", true], ["####### This is also incorrect because it has seven hashes", false], ["###### This is a correctly formatted header", true], ["######This is not correct", false], ["######This is missing a space after hashtags", false], ["####### This is a level seven heading", false]]}
{"instruction": "回答中的每个列表项都必须以一个顺序数字和点“1.”开头。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for idx, line in enumerate(lines, 1):\n        if not line.startswith(f'{idx}.'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    for i, line in enumerate(response_lines, 1):\n        prefix = '{}.'.format(i)\n        if not line.startswith(prefix):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # first, split the response into lines\n    items = response.strip().split('\\n')\n    # check if each item follows the pattern\n    for i, item in enumerate(items):\n        # trim leading and trailing whitespace\n        item = item.strip()\n        # generate expected prefix e.g., '1.', '2.', '3.', ...\n        expected_prefix = f'{i+1}.'\n        # check if the item starts with the expected prefix\n        if not item.startswith(expected_prefix):\n            return False\n    # if all items start with the correct prefix, return True\n    return True if items else False", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    items = response.strip().split('\\n')\n\n    # Define a variable to keep track of the expected starting number\n    number = 1\n\n    # Iterate over each line in the items\n    for item in items:\n        # Check if the line starts with the expected number and a dot\n        if not item.startswith(f'{number}.'):\n            return False\n\n        # Increment the number for the next expected item\n        number += 1\n\n    return True", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for index, item in enumerate(items, start=1):\n        if not item.startswith(f\"{index}.\"):\n            return False\n    return True", 1.0]], "cases": [["1.这是第一个列表项\n2.这是第二个列表项\n3.这是第三个列表项", true], ["1. 第一项\n2. 第二项\n4.跳过数字3", false], ["1. 第一项\n2. 第二项\n3. 第三项", true], ["第一个项目没有编号\n2.这是第二个项目，但第一个没有编号", false], ["1.第一个项目开始得对\n2.第二个项目也对\n4.但是这个项目的编号错了", false], ["0. 开始错误\n1. 第一项\n2. 第二项", false]]}
{"instruction": "回答包含一组步骤，每个步骤用 markdown 的引用格式表示，每步用“>”开头。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    if not response_lines:\n        return False\n    for line in response_lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    steps = response.strip().split('\\n')\n    for step in steps:\n        # Check if each step starts with > and is not just the > character\n        if not step.startswith('> ') or step == '> ':\n            return False\n    return True if steps else False", 1.0]], "cases": [["> Step 1\n> Step 2\n> Step 3", true], ["> Step 1\n> Step 2\n\n> Step 3", false], ["Step 1\n> Step 2\n> Step 3", false]]}
{"instruction": "回答中每个要点的前面必须有对应的小写拉丁字母标记，如“a.”、“b.”等。", "eval_func": [["def evaluate(response):\n    import re\n    points = re.split(r'\\n|(?<=\\d)\\.\\s*(?=[a-z])', response)\n    for point in points:\n        if not re.match(r'^[a-z]\\.', point.strip()):\n            return False\n    return True", 0.8333333333333334]], "cases": [["a.这是第一个要点。b. 这是第二个要点。 c. 这是第三个要点。", false], ["a. 这是第一个要点。\nb. 这是第二个要点。\nc. 这是第三个要点。", true], ["This is a point without a letter prefix.", false], ["a. Point with prefix\nPoint without prefix.", false], ["a. This is the first point.\nb. This is the second point.", true], ["这是第一个要点。\nb. 这是第二个要点。\nc. 这是第三个要点。", false]]}
{"instruction": "回答中出现的列表项必须满足交替顺序排列，如第一项用“*”，第二项用“-”，依此类推。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for index, line in enumerate(lines):\n        if index % 2 == 0 and not line.startswith('*'):\n            return False\n        elif index % 2 == 1 and not line.startswith('-'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    for i, line in enumerate(lines):\n        expected_char = '*' if i % 2 == 0 else '-'\n        if not line.startswith(expected_char):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    items = response.strip().split('\\n')\n    for index, item in enumerate(items):\n        if index % 2 == 0 and not item.startswith('*'):\n            return False\n        elif index % 2 == 1 and not item.startswith('-'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    correct_symbols = ['*', '-']\n    for i, line in enumerate(lines):\n        if not line.startswith(correct_symbols[i % 2]):\n            return False\n    return True", 1.0]], "cases": [["* 第一项\n- 第二项\n* 第三项\n- 第四项", true], ["* 第一项\n* 第二项错误\n- 第三项", false], ["- 错误的符号\n* 第一项\n- 第二项", false]]}
{"instruction": "必须在回答中至少使用 3 个不同颜色的文字，用 html 标签表示，例如 `<span style=\"color:red;\">红色文字</span>`。", "eval_func": [["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class ColorCounterHTMLParser(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style' and 'color:' in attr[1]:\n                        color_value = attr[1].split(':')[1].strip().replace(';', '')\n                        self.colors.add(color_value)\n\n    parser = ColorCounterHTMLParser()\n    parser.feed(response)\n    return len(parser.colors) >= 3", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n    class ColorCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style':\n                        color_info = attr[1].split(':')\n                        if len(color_info) == 2 and color_info[0].strip() == 'color':\n                            self.colors.add(color_info[1].strip())\n\n    # Create an instance of the ColorCounter\n    parser = ColorCounter()\n    parser.feed(response)\n\n    # Check if there are at least 3 distinct colors\n    return len(parser.colors) >= 3", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n    \n    class ColorCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n            \n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style' and 'color:' in attr[1]:\n                        color_value = attr[1].split('color:')[-1].split(';')[0].strip()\n                        self.colors.add(color_value)\n                        \n    parser = ColorCounter()\n    parser.feed(response)\n    return len(parser.colors) >= 3", 1.0]], "cases": [["<span style=\"color:red;\">红色文字</span>普通文字<span style=\"color:red;\">红色文字</span>", false], ["<p><span style=\"color:red;\">Red text</span> and a <span style=\"color:green;\">green one</span> without tags</p>", false], ["<p><span style=\"color:red;\">红色文字</span><span style=\"color:red;\">还是红色</span><span style=\"color:blue;\">蓝色文字</span></p>", false], ["<span style=\"color:red;\">红色文字</span><span style=\"color:green;\">绿色文字</span><span style=\"color:blue;\">蓝色文字</span>", true], ["只有普通文字没有颜色标签", false], ["<p><span style=\"color:red;\">红色文字</span><span style=\"color:green;\">绿色文字</span><span style=\"color:blue;\">蓝色文字</span></p>", true]]}
{"instruction": "回答必须以“回答内容如下：”作为正文开始的第一句话。", "eval_func": [["def evaluate(response):\n    return response.startswith(u'回答内容如下：')", 1.0], ["def evaluate(response):\n    prefix = '回答内容如下：'\n    return response.startswith(prefix)", 1.0], ["def evaluate(response):\n    return response.startswith('\\u56de\\u7b54\\u5185\\u5bb9\\u5982\\u4e0b\\uff1a')", 1.0]], "cases": [["回答内容如下：\n详细内容在这个部分。", true], ["我的回答是：回答内容如下：这里有一些消息。", false], ["回答内容如下：这是正确赋予的回答。", true]]}
{"instruction": "回答中必须包含 3 个以 markdown 删除线格式表示的单词或短语，例如“~~删除线文本~~”。", "eval_func": [["def evaluate(response):\n    # Check for markdown strikethroughs\n    strikethroughs = response.count('~~')\n\n    # Each strikethrough phrase has two '~~', so we expect strikethroughs to be 6\n    if strikethroughs != 6:\n        return False\n\n    # Splitting the response to find individual strikethrough phrases\n    parts = response.split('~~')\n\n    # Counting how many valid strikethrough phrases are there\n    count_strikethrough_phrases = sum(1 for i, part in enumerate(parts) if i % 2 == 1 and part.strip())\n\n    # Return True if exactly 3 strikethrough phrases are present\n    return count_strikethrough_phrases == 3", 1.0], ["def evaluate(response):\n    import re\n    \n    # Define a regex pattern to find markdown strikethrough text\n    pattern = r'~~(.*?)~~'\n    \n    # Find all strikethrough texts in the response\n    strikethrough_texts = re.findall(pattern, response)\n    \n    # Check if there are exactly 3 strikethrough texts\n    if len(strikethrough_texts) == 3:\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    # Import regex module\n    import re\n    \n    # Define pattern to find markdown strikethrough text\n    pattern = r'~~(.*?)~~'\n    \n    # Find all strikethrough occurrences\n    strikethrough_texts = re.findall(pattern, response)\n    \n    # Check if there are exactly three strikethrough phrases\n    return len(strikethrough_texts) == 3", 1.0], ["def evaluate(response):\n    import re\n    # Count the number of markdown strikethroughs using a regular expression\n    strikethroughs = re.findall(r'~~(.*?)~~', response)\n    # Check if there are exactly three strikethrough phrases\n    return len(strikethroughs) == 3", 1.0], ["def evaluate(response):\n    import re\n\n    # Regex pattern to find markdown strikethrough text (~~text~~)\n    pattern = r'~~[^~]+~~'\n\n    # Find all occurrences of markdown strikethrough in the response\n    strikethrough_matches = re.findall(pattern, response)\n\n    # Check if there are exactly three strikethrough phrases\n    return len(strikethrough_matches) == 3", 1.0]], "cases": [["这个回答有超过三个的删除线文本：~~一~~, ~~二~~, ~~三~~, ~~四~~。", false], ["此~~回答应包含~~三个删除线格式,但它只有两个~~例子~~。", false], ["这是一个包含~~删除线文本~~的回答, 这里还有一个~~第二个例子~~以及~~第三个例子~~。", true]]}
{"instruction": "回答责备必须每个句子结束后跟一个不同的特殊字符，如“†”、“‡”、“•”等。", "eval_func": [["def evaluate(response):\n    special_chars = set(['†', '‡', '•'])\n    sentences = response.split()\n    prev_char = ''\n    for sentence in sentences:\n        if len(sentence) < 2 or sentence[-1] not in special_chars:\n            return False\n        if sentence[-1] == prev_char:\n            return False\n        prev_char = sentence[-1]\n    return True", 1.0]], "cases": [["没有特殊符号结束。这是不符合要求。", false], ["这是一个句子。†另一个句子。‡最后的句子。•", true], ["符号不正确结束句子。*", false]]}
{"instruction": "回答时必须有至少一个段落以斜体字书写，使用 markdown 语法“*斜体文本*”。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to capture italic text in markdown\n    italic_pattern = re.compile(r'\\*{1}[^*]+\\*{1}')\n    # Search for at least one occurrence of italic text\n    matches = italic_pattern.findall(response)\n    # Ensure that there is at least one valid italic paragraph\n    for match in matches:\n        if '\\n' not in match and match.count('*') == 2:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    italic_paragraphs = re.findall(r'(?m)^\\*[^*]+\\*$', response)\n    for paragraph in italic_paragraphs:\n        if '*' not in paragraph.strip('*'):\n            return True\n    return False", 1.0], ["def evaluate(response):\n    # Search for italic text using markdown syntax\n    italic_pattern = r'\\*[^*]+\\*'\n    # Search for at least one occurrence of italicized paragraph\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if re.search(italic_pattern, paragraph):\n            return True\n    return False\n\nimport re", 1.0], ["def evaluate(response):\n    import re\n    italic_paragraph_pattern = r'(?m)(^|\\n)\\*.*?\\*(\\n|$)'\n    # Check for at least one paragraph with italic markdown syntax\n    match = re.search(italic_paragraph_pattern, response)\n    return bool(match)", 1.0], ["def evaluate(response):\n    return bool(re.search(r'\\*[^*]+\\*', response))\n\nimport re", 1.0]], "cases": [["*完全一段斜体文本*\n并且正确闭合。", true], ["这是普通的回答。\n这一行也是普通的。\n*但这一行忘记闭合", false], ["这是普通的回答。\n*这是斜体段落。*", true]]}
{"instruction": "回答中的每一个要点开头都要附带相应的全角中文标点序号，例如：“（一）”、“（二）”等。", "eval_func": [["def evaluate(response):\n    import re\n\n    # regular expression to match full-width numbered points\n    pattern = re.compile(r'（(一-九）|一十一）|一十二）|一十三）|一十四）|一十五）.*?)+')\n\n    # split the response into paragraphs\n    paragraphs = response.split('\\n')\n\n    for index, paragraph in enumerate(paragraphs):\n        # Each paragraph must start with corresponding number\n        num_str = ''\n        if index < 9:\n            num_str = chr(0xff08) + chr(0x4e00 + index) + chr(0xff09)\n        elif index < 19:\n            num_str = chr(0xff08) + '十' + (chr(0x4e00 + index - 10) if index > 9 else '') + chr(0xff09)\n\n        if not paragraph.startswith(num_str):\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n\n    # Split the response into points based on the full-width numbering\n    points = re.split(r'\\uff08[一-龥]\\uff09', response)\n\n    # Check if the split generates at least 2 elements\n    # the first element should be empty if the response starts with the numbering\n    if len(points) < 2 or points[0] != '':\n        return False\n\n    # Check for each point after the first (which should be empty)\n    for point in points[1:]:\n        # Ensure that each point starts immediately after a full-width bracket numbering\n        if not point or not re.match(r'^[^\\uff08].*', point):\n            return False\n    return True", 1.0]], "cases": [["这是第一个要点。 （一）这其实第二个要点，但编号错误。", false], ["（一）全部正确。 （二）没有问题。 （三）完美。", true], ["（一）这是第一个要点。 （二）接着是第二个要点。", true]]}
{"instruction": "回答中的每个段落都需以大写的英文字母开头，比如“A开头的内容。”", "eval_func": [["def evaluate(response):\n    # Splitting the response into paragraphs\n    paragraphs = response.split('\\n')\n    # Loop through each paragraph\n    for paragraph in paragraphs:\n        # Check if paragraph is not empty and starts with an uppercase letter\n        if not paragraph or not paragraph[0].isupper():\n            return False\n    # If all paragraphs satisfy the condition, return True\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for para in paragraphs:\n        if not para or not para[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph: continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0]], "cases": [["A very good day to you.\nBlessings come in many forms.\nCan't wait to see you soon!", true], ["very good day.\nShould start with a capital letter.", false], ["Sometimes it starts right.\nsometimes it does not.", false]]}
{"instruction": "回答中的日期必须按照“YYYY-MM-DD”的格式书写。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\b(\\d{4})-(\\d{2})-(\\d{2})\\b'\n    match = re.search(pattern, response)\n\n    if match:\n        year, month, day = match.groups()\n        if int(year) > 0 and 1 <= int(month) <= 12 and 1 <= int(day) <= 31:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = '^\\d{4}-\\d{2}-\\d{2}$'\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile('^(\\d{4}-\\d{2}-\\d{2})$')\n    return bool(pattern.match(response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n    if pattern.match(response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["March 25, 2023", false], ["2023/03/25", false], ["2023-03-25", true]]}
{"instruction": "每个要点需用圆括号括起来并加粗，如**(要点)**。", "eval_func": [["def evaluate(response: str) -> bool:\n    import re\n    # Regular expression to match bold parentheses pattern\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Split the response by the bold parentheses, if the split result doesn't\n    # have empty strings (or only contains the bold parentheses patterns),\n    # then the response didn't strictly follow the instruction.\n    split_response = pattern.split(response)\n    if any(not pattern.match(part) and len(part.strip()) > 0 for part in split_response):\n        return False\n    # Check if all the bold patterns are strictly (要点)\n    for match in pattern.findall(response):\n        if match != '**(要点)**':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern to find all instances that match the instruction\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Replace the matches to see if any text remains unformatted\n    unformatted_parts = pattern.sub('', response).strip()\n    # The response follows the instruction if all text is wrapped as specified and nothing remains unformatted\n    return all('(' in match and ')' in match for match in matches) and not unformatted_parts", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to check the instruction\n    pattern = r'\\*\\*\\([^\\)]+\\)\\*\\*'\n    items = re.findall(pattern, response)\n\n    # Split the string by the found items\n    split_parts = re.split(pattern, response)\n\n    # Check if all parts that are split out do not contain any unformatted key point\n    # This assumes that key points are all in Chinese characters, though it may match other characters in a similar range.\n    all_parts_valid = all(not re.search(r'[\\u4e00-\\u9fff]+', part) for part in split_parts)\n\n    # True if all the found items are strictly following the instructions and all other parts are valid\n    return bool(items) and all_parts_valid", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern to match the instruction\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Find all occurrences that match the pattern\n    matches = pattern.findall(response)\n    # Extract text between '**(' and ')**'\n    contents = [m[3:-3] for m in matches]\n    # Check for any non-matching parts of the response\n    split_response = pattern.split(response)\n    for part in split_response:\n        if part.strip():  # Checks if there is any text outside the bold parenthesis\n            return False\n    # Check if all required parts are within the bold parenthesis\n    return all('**(' in response and ')**' in response for point in contents)", 1.0]], "cases": [["**(要点)** 及另一点", false], ["**(要点)** 和 **( )**", false]]}
{"instruction": "回答必须在结尾包含签名“敬上”，最后一行。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    return lines[-1].strip() == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    return lines[-1] == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    last_line = lines[-1].strip()\n    return last_line == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    return lines[-1].strip() == '敬上'", 1.0]], "cases": [["这里是我的回答。\n敬上", true], ["这是另一个回答但不符合要求。", false], ["敬上\n本来应该在最后一行，但规则未被遵循。", false]]}
{"instruction": "回答中需要包含至少2个内链，格式为[链接文字](URL)。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find markdown links\n    pattern = re.compile(r'\\[[^\\]]+\\]\\([^)]+\\)')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Check if there are at least two links\n    return len(matches) >= 2", 1.0], ["def evaluate(response):\n    import re\n    # Define a regex pattern to find markdown links\n    pattern = r'\\[([^\\]]+)\\]\\((https?:\\/\\/[a-zA-Z0-9./]+)\\)'\n    # Use re.findall to get all the links in a list\n    links = re.findall(pattern, response)\n    # Check if there are at least 2 links\n    return len(links) >= 2", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\[([^\\]]+)\\]\\((https?://[^\\)]+)\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 2", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r'\\[.*?\\]\\(http?s://.*?\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 2", 1.0]], "cases": [["只有一个内链[链接文字](https://example.com)是不足够的", false], ["这是第一个内链[链接文字](https://example.com)和第二个内链[另一个链接](https://example.org)", true], ["多个内链但不符合格式如此: 链接文字(https://example.com), [链接文字]https://example.com", false]]}
{"instruction": "回答的每个要点前必须使用单破折号，如“- 要点内容”。", "eval_func": [["def evaluate(response):\n    points = response.strip().split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True if points else False", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = [point.strip() for point in response.split('\\n') if point]\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 0.8333333333333334]], "cases": [["- 要点一\n- 要点二\n-要点三", false], ["-要点一\n- 要点二\n - 要点三", false], ["第一个要点\n- 第二个要点\n- 第三个要点", false], ["- 要点一\n- 要点二\n- 要点三", true], ["- 第一个要点\n - 第二个要点\n- 第三个要点", false], ["- 第一个要点\n- 第二个要点\n- 第三个要点", true]]}
{"instruction": "回答中的每段开头需要使用四个空格缩进。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    return all(line.startswith('    ') or line == '' for line in lines)", 1.0], ["def evaluate(response):\n    # Split the response by newlines to handle each paragraph\n    paragraphs = response.split('\\n')\n    # Check if each paragraph begins with four spaces\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '): # Checks for four spaces\n            return False\n    return True", 1.0]], "cases": [["This is not correctly indented.\n    This one is correct.", false], ["    Only the first line is correct.\nNot this one.", false], ["    This is a correctly indented paragraph.\n    This one is correct as well.", true]]}
{"instruction": "回答结束前，必须提问用户是否满意，如“您对以上回答是否满意？”。", "eval_func": [["def evaluate(response):\n    # Define patterns to look for\n    satisfaction_query_patterns = [\n        r'您对以上回答是否满意？',\n        r'您对以上回答是否满意',\n    ]\n\n    # Check if the response ends with one of the satisfaction query patterns\n    for pattern in satisfaction_query_patterns:\n        if response.strip().endswith(pattern):\n            return True\n\n    # If none of the patterns matched and the response did not end with them, return False\n    return False", 1.0], ["def evaluate(response):\n    satisfaction_query = '您对以上回答是否满意？'\n    return response.endswith(satisfaction_query)", 1.0], ["def evaluate(response):\n    satisfaction_asked = '您对以上回答是否满意？'\n    return response.endswith(satisfaction_asked)", 1.0], ["def evaluate(response):\n    satisfaction_questions = [\n        '您对以上回答是否满意？'\n    ]\n    for question in satisfaction_questions:\n        if question in response and response.endswith(question):\n            return True\n    return False", 1.0]], "cases": [["我们提供了详细的解释。您对以上回答是否满意？", true], ["我们尽量给出了详尽的答案，不过如果还有什么遗漏，请提出。您对以上回答是否满意？", true], ["以下是我们的答复。如果您有任何疑问，请告诉我们。", false]]}
{"instruction": "回答的每个主要部分下面都必须有一个以半角分号结尾的小结，如“这是小结；”。", "eval_func": [["def evaluate(response):\n    # split the response into major parts using a full-stop followed by a newline character\n    parts = response.split('\\n')\n    # check that each major part has a semicolon-terminated summary\n    for part in parts:\n        if not part.strip().endswith(';'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sections = response.split('\\n')\n    for section in sections:\n        parts = section.split('；')\n        if len(parts) < 2 or parts[-1].strip() != '':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into sections\n    sections = response.split('、') # U+3001 is the codepoint for the Chinese comma used to separate sections\n    for section in sections:\n        # Check if the section ends with a semicolon\n        if not section.strip().endswith(';'):\n            return False\n\n    # If all sections have a semicolon at the end, the instruction is followed\n    return True", 1.0], ["def evaluate(response):\n    sections = response.split('、')\n    if not sections or '' in sections:\n        return False\n    return all(section.strip().endswith(';') for section in sections)", 1.0]], "cases": [["这是第一部分的内容。\n这是小结；\n这是第二部分的内容\n这是小结；", false], ["这是第一部分的内容。\n这是小结。\n这是第二部分的内容。\n这是小结；", false]]}
{"instruction": "回答中的条形列表必须使用减号并加空格，如- 条目。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('- '):\n            return False\n        items = line[2:].split('\\u3000')\n        if '' in items:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('- '):\n            return False\n        if '  ' in line:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by new lines to process individual lines\n    lines = response.split('\\n')\n    for line in lines:\n        # Check if the line starts with '-' followed by a space and then any character\n        if not line.startswith('- '):\n            return False\n        if '-  ' in line or '--' in line:\n            # Check if there are extra spaces or more than one dash\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('- '):\n            return False\n    return True", 1.0]], "cases": [[" - 条目一\n- 条目二\n- 条目三", false], ["-条目一 - 条目二 - 条目三", false], ["- 条目1\n- 条目2\n- 条目3", true], ["-条目1\n- 条目2\n- 条目3", false], ["- 条目一\n- 条目二\n - 条目三", false], ["- 条目一\n-条目二\n- 条目三", false], ["- 条目一\n- 条目二\n- 条目三", true]]}
{"instruction": "回答中需要使用至少两种字体大小，大号字体用增强标签，即**大号字体**，小号字体用删除线标签表示，即~~小号字体~~。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Regular expression patterns to check for the font sizes\n    bold_pattern = r'\\*\\*[^\\*]+\\*\\*'\n    small_pattern = r'~~[^~]+~~'\n\n    # Check if there are at least two sizes of fonts by finding the patterns\n    bold_matches = re.findall(bold_pattern, response)\n    small_matches = re.findall(small_pattern, response)\n\n    # Evaluate whether both large font (bold) and small font (strikethrough) are present at least once\n    return len(bold_matches) >= 1 and len(small_matches) >= 1", 1.0], ["def evaluate(response):\n    import re\n\n    # Define regular expressions for large and small font markers\n    large_font_pattern = r'\\*\\*[^*]+\\*\\*'\n    small_font_pattern = r'~~[^~]+~~'\n\n    # Find all instances of large and small fonts in the response\n    large_fonts = re.findall(large_font_pattern, response)\n    small_fonts = re.findall(small_font_pattern, response)\n\n    # Evaluate if the response has at least one instance of each font size\n    has_large_font = len(large_fonts) >= 1\n    has_small_font = len(small_fonts) >= 1\n\n    # Return the logical AND of both conditions\n    return has_large_font and has_small_font", 1.0], ["def evaluate(response):\n    import re\n    bold_pattern = r'\\*\\*[^*]+\\*\\*'\n    small_pattern = r'~~[^~]+~~'\n    bold_matches = re.findall(bold_pattern, response)\n    small_matches = re.findall(small_pattern, response)\n    if bold_matches and small_matches:\n        return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    # Find all instances of bold and strikethrough text\n    bold_pattern = r'\\*\\*[^*]+\\*\\*'\n    small_pattern = r'~~[^~]+~~'\n\n    # Search for the patterns\n    bold_matches = re.findall(bold_pattern, response)\n    small_matches = re.findall(small_pattern, response)\n\n    # Check if both patterns exist and there is at least one of each\n    return bool(bold_matches) and bool(small_matches)", 1.0], ["def evaluate(response):\n    import re\n\n    # We check if there is at least one occurrence of each necessary pattern\n    bold_pattern = re.compile(r'\\*\\*[^*]+\\*\\*') # Pattern to match bold text\n    small_pattern = re.compile(r'~~[^~]+~~')   # Pattern to match small text\n\n    # Search for at least one occurrence of each pattern\n    has_bold = bool(bold_pattern.search(response))\n    has_small = bool(small_pattern.search(response))\n\n    # Evaluate if both patterns are present\n    return has_bold and has_small", 1.0]], "cases": [["这是一个例子，其中包含**大号字体**和~~小号字体~~。", true], ["既没有大号字体也没有小号字体。", false], ["这里全是**大号字体**，没有小号的。", false], ["忘记使用~~小号字体~~了。", false], ["这里是**大号字体**，这里是~~小号字体~~。", true], ["仅仅有**大号字体**，但是没有小号字体。", false]]}
{"instruction": "回答开头必须说明回答能解决的问题数量，并用方括号表示，如[解决3个问题]。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Regular expression to match the pattern at the beginning of the string\n    pattern = re.compile(r'^\\[解决\\d+个问题\\]')\n\n    # Check if the response matches the pattern\n    match = pattern.match(response)\n\n    # If the response matches, returns True; otherwise, returns False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    match = re.match(r'^\\[解决(\\d+)个问题\\]', response)\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    match = re.match(r'^\\[解决(\\d+)个问题\\]', response)\n    if match:\n        try:\n            num_problems = int(match.group(1))\n            return True\n        except ValueError:\n            return False\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = '^\\[解决(\\d+)个问题\\]'\n    match = re.match(pattern, response)\n    if match:\n        return True\n    else:\n        return False", 1.0]], "cases": [["解决[3个问题] 这是不符合要求的回答开头。", false], ["[解决3个问题] 这是符合要求的回答开头。", true], ["[解决三个问题] 数字必须为阿拉伯数字，这是不符合要求的。", false]]}
{"instruction": "回答中的每一段都必须以“---”开头，表示分割线。", "eval_func": [["def evaluate(response):\n    # Check if the response is not empty\n    if not response:\n        return False\n    \n    # Split response on new lines to get paragraphs\n    paragraphs = response.split('\\n')\n    \n    # Check if every paragraph starts with '---'\n    for paragraph in paragraphs:\n        if not paragraph.startswith('---'):\n            return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(paragraph.startswith('---') for paragraph in paragraphs if paragraph.strip())", 1.0], ["def evaluate(response):\n    paragraphs = response.strip().split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('---'):\n            return False\n    return True if paragraphs else False", 0.8333333333333334], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('---'):\n            return False\n    return True if paragraphs else False", 0.8333333333333334], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(p.startswith('---') for p in paragraphs if p)", 1.0]], "cases": [["---这是第一段\n---这是第二段\n---这是第三段", true], ["第一段内容\n---第二段内容\n---第三段内容", false], ["---第一段内容\n\n---第二段内容\n---第三段内容", true], ["---这是第一段\n这是没有前缀的第二段\n---这是第三段", false], ["---第一段内容\n---第二段内容\n---第三段内容", true], ["---只有一段，但是格式正确", true]]}
{"instruction": "回答中的每一段必须以“>”开头，表示引用文本格式。", "eval_func": [["def evaluate(response):\n    # Split the response into paragraphs\n    paragraphs = response.split('\\n')\n\n    # Check each paragraph starts with '>'\n    for paragraph in paragraphs:\n        if not paragraph.startswith('>'):\n            return False\n\n    # If all paragraphs start with '>', return True\n    return True", 1.0]], "cases": [[">这是第一段\n\n>这是第三段（第二段是空白行）。", false], [">这是第一段。\n这是第二段未用引号。", false], [">这是第一段。\n>这是第二段。", true]]}
{"instruction": "回答中至少要包含一个图片链接，并使用 markdown 语法插入图片，比如“![图片描述](图片链接地址)”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'!\\[.*?\\]\\(http(s)?://.*?\\)'\n    if re.search(pattern, response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    markdown_image_pattern = r'!\\[.*?\\]\\(http[s]?://.*?\\)'\n    if re.search(markdown_image_pattern, response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    # Define the markdown image regex pattern\n    markdown_image_pattern = r'!\\[.*?\\]\\(.+?\\)'\n    # Use regex to find all markdown image patterns in the response\n    matches = re.findall(markdown_image_pattern, response)\n\n    # Check if there is at least one markdown image pattern match\n    return any(match for match in matches if (match and match.startswith('![') and match.endswith(')')))", 1.0], ["def evaluate(response):\n    import re\n    # Define the markdown image regex pattern\n    image_pattern = r'!\\[.*?\\]\\(http[s]?://.*?\\)'\n    # Search for the pattern in the response\n    match = re.search(image_pattern, response)\n    # If there is a match and it's an image link, return True\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression pattern to find markdown image syntax\n    pattern = r'!\\[.*?\\]\\(http[s]?://.*?\\)'\n    # Finds all occurances that match the pattern\n    matches = re.findall(pattern, response)\n    # Evaluates if there is at least one match\n    return len(matches) >= 1", 1.0]], "cases": [["查看这张图片![Image](https://example.com/flower.png)它很漂亮。", true], ["<img src='http://example.com/picture.jpg'/>", false], ["这是一个图片 ![图片描述](http://example.com/picture.jpg)", true]]}
{"instruction": "在回答的开头使用横线，使用 markdown 语法插入横线“---”。", "eval_func": [["def evaluate(response):\n    # Check if the response starts with the markdown horizontal line\n    return response.startswith('---\\n')", 1.0], ["def evaluate(response):\n    return response.startswith('---\\n')", 1.0], ["def evaluate(response):\n    if not response.startswith('---\\n'):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Check whether the response starts with a markdown horizontal line\n    return response.startswith('---\\n')", 1.0]], "cases": [["--- 这是横线后有空格的情况。\n", false], ["---\n这是遵循指示的回答", true], ["这是没有使用横线开头的回答。\n---", false], ["---\n这是遵循指令的回答。", true], ["---\n\n这是遵循指令的回答，但有多余的空行。", true], ["---\n这是遵循了指示的回答。", true], ["这个回答没有使用横线开头", false], ["---这并没有遵循指示，因为它缺少了换行符", false], ["这不是遵循指令的回答。\n---", false]]}
{"instruction": "回答的最后必须包含一行感谢语，用斜体书写，例如“*感谢阅读！*”。", "eval_func": [["def evaluate(response):\n    if not response.strip().endswith('*'):\n        return False\n    lines = response.split('\\n')\n    last_line = lines[-1].strip()\n    if last_line.startswith('*') and last_line.endswith('*') and '感谢' in last_line:\n        return True\n    return False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    last_line = lines[-1].strip() if lines else ''\n    return last_line.startswith('*') and last_line.endswith('*') and '感谢' in last_line", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    last_line = lines[-1].strip()\n    return last_line.startswith('*') and last_line.endswith('*') and '感谢' in last_line", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    if not response_lines:\n        return False\n    last_line = response_lines[-1]\n    return last_line.startswith('*') and last_line.endswith('*') and '感谢' in last_line", 1.0]], "cases": [["这是一段回答，包含一些信息内容。\n*感谢阅读！*", true], ["最后一行有感谢但不是斜体。\n感谢阅读！", false], ["这里有一些文本，但是不以斜体感谢结束。", false]]}
{"instruction": "回答中不得包含任何形式的加粗格式。", "eval_func": [["def evaluate(response):\n    if '**' in response or '__' in response:\n        return False\n    return True", 1.0], ["def evaluate(response):\n    return '**' not in response and '__' not in response", 1.0]], "cases": [["这是一个没有加粗文字的回答", true], ["这是一个有__加粗__格式的例子", false], ["这是一个有**加粗**文字的回答", false]]}
{"instruction": "回答必须以问句结束，且用斜体书写，例如“*这是否解决了您的问题？*”。", "eval_func": [["def evaluate(response):\n    if not response.endswith('？*'):\n        return False\n    if not response.startswith('*'):\n        return False\n    if not ('*' in response[1:-2]) and not response[-3].isdigit():\n        return True\n    return False", 1.0]], "cases": [["*这真的能够帮到您吗？*", true], ["这是否解决了您的问题？", false], ["*这是否解决了您的问题？*", true]]}
{"instruction": "每段回答中必须包含并突出显示一个主要名词，使用 markdown 加粗语法，例如“**主要名词**”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define a regular expression pattern for markdown bold syntax\n    pattern = re.compile(r'\\*\\*(.*?)\\*\\*')\n    # Find all occurrences of the markdown bold syntax in the response\n    bold_phrases = pattern.findall(response)\n    # Check if there is exactly one bold phrase and it is a noun\n    if len(bold_phrases) == 1:\n        # Simplified check: Assume any single word in bold is a noun\n        return True if re.match(r'^[一-龥]+$', bold_phrases[0]) else False\n    return False", 1.0]], "cases": [["重要的概念需要用粗体标注，例如我们可以使用**Concept**来突出。", false], ["一般来说，我们可以在句子中找到名词。", false], ["在这篇文章中，我们重点关注了**名词**的使用。", true]]}
{"instruction": "回答必须在结尾提供一个总结性的段落，并且使用四个空格缩进。", "eval_func": [["def evaluate(response):\n    if not response:\n        return False\n    paragraphs = response.strip().split('\\n')\n    if not paragraphs:\n        return False\n    last_paragraph = paragraphs[-1]\n    return last_paragraph.startswith('    ')", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n\n    # Split the input response into paragraphs\n    paragraphs = response.strip().split('\\n')\n    last_paragraph = paragraphs[-1]\n    # Check if the last paragraph starts with four spaces for indentation\n    if not last_paragraph.startswith('    '):\n        return False\n\n    # Check if the last paragraph is not just four spaces without any content\n    if len(last_paragraph.strip()) == 0:\n        return False\n\n    # The response strictly follows the instruction\n    return True", 1.0], ["def evaluate(response):\n    # First, we need to find the last paragraph\n    paragraphs = response.strip().split('\\n')\n    if not paragraphs:\n        return False\n    last_paragraph = paragraphs[-1]\n    # Check if the last paragraph is indented with four spaces\n    if not last_paragraph.startswith('    '):\n        return False\n    # Ensure the last paragraph is not empty after removing the four space indentation\n    if len(last_paragraph) <= 4 or last_paragraph[4:].strip() == '':\n        return False\n    return True", 1.0], ["def evaluate(response):\n    if not response or not response.strip():\n        return False\n    paragraphs = response.split('\\n')\n    if not paragraphs[-1].startswith('    '):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    if not response or not response.strip():\n        return False\n\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n\n    last_line = lines[-1]\n    return last_line.startswith('    ') and '\\n    ' not in last_line[4:]", 1.0]], "cases": [["这是第一段内容。\n这是第二段内容。\n    这是总结性的段落。", true], ["这是第一段内容。\n    这是紧接着的段落，不是结尾。\n    这是总结性的段落。", true], ["回答是合法的。\n    这是总结性的段落。", true], ["", false], ["这是第一段内容。\n这是第二段内容。\n这是没有缩进的总结性段落。", false], ["回答是合法的。这是总结性的段落。", false]]}
{"instruction": "回答中出现的每个关键词都必须使用 markdown 下划线格式，例如“_关键词_”。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Find all markdown-formatted keywords\n    md_keywords = re.findall(r'_([^_]+)_', response)\n\n    # Ensure that there are no other forms of the keywords\n    plain_keywords = re.findall(r'\\b(?!_)(\\w+)(?!_)\\b', response)\n\n    # Check if all plain_keywords are in markdown format and have an equivalent in md_keywords\n    for keyword in plain_keywords:\n        if keyword not in md_keywords:\n            return False\n    return True", 1.0], ["def evaluate(response: str) -> bool:\n    import re\n\n    # Find all words between underscores \n    markdown_words = re.findall(r'_([^_]+)_', response)\n    non_markdown_words = re.findall(r'\\b(?!_)([^_\\s]+)(?!_)\\b', response)\n\n    # Each non-markdown word that is not punctuation should be in markdown format.\n    for word in non_markdown_words:\n        if any(char.isalnum() for char in word) and word in markdown_words:\n            continue\n        if any(char.isalnum() for char in word):\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression pattern to find markdown underlined words\n    pattern = r'_([^_]+)_'\n    \n    # Find all markdown underlined words and store them in a set\n    underlined_words = set(re.findall(pattern, response))\n    \n    # Extract words from the response that look like keywords (not in markdown format)\n    # Assuming keywords are Chinese characters\n    keywords = set(re.findall(r'[一-鿿]+', response)) - underlined_words\n    \n    # If there are keywords not in markdown format, return False\n    if keywords - underlined_words:\n        return False\n    \n    # If all keywords are underlined with markdown, return True\n    return True", 1.0], ["def evaluate(response):\n    import re\n\n    # Find all occurrences of markdown underlined words\n    underlined_keywords = re.findall(r'_([^_]+)_', response)\n    # Find all stand-alone Chinese characters that could be considered keywords\n    potential_keywords = re.findall(r'[一-鿿]+', response)\n\n    # Check if all potential_keywords have been underlined\n    for keyword in potential_keywords:\n        # Regex pattern to check proper markdown format\n        pattern = r'_' + re.escape(keyword) + r'_'\n        if not re.search(pattern, response):\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n\n    # Extract all words within markdown underlines\n    pattern = r'_([^_]+)_'\n    underlined_words = re.findall(pattern, response)\n\n    # Split response into words and strip unnecessary punctuation\n    words = re.findall(r'\\b\\w+\\b', response)\n\n    for word in words:\n        # Check if every word that might be a keyword is underlined\n        if word in underlined_words:\n            continue\n        else:\n            # If any potential keyword is not underlined, return False\n            return False\n    return True", 1.0]], "cases": [["这个例子_correctly_ _formats_ 关键词，但_forgets_ 一个。", false], ["在这个示例中，没有使用格式：回答。", false]]}
{"instruction": "回答必须以 HTML 注释的形式开始，即 `<!-- 回答开始 -->`。", "eval_func": [["def evaluate(response):\n    # Check if the response string starts with the specified HTML comment\n    return response.startswith('<!-- 回答开始 -->')", 0.8888888888888888], ["def evaluate(response):\n    return response.strip().startswith('<!-- 回答开始 -->')", 1.0], ["def evaluate(response):\n    return response.startswith('<!-- 回答开始 -->')", 0.8888888888888888]], "cases": [["<!-- 回答开始 -->这是遵守指示的回答", true], ["<!-- 回答开始 -->This is a response that follows the instruction.", true], ["回答开始，这是不合规的回答", false], ["回答开始的信息", false], ["This does not follow the instruction.", false], ["<!-- 回答开始 -->\n这是也是合规的回答，即使它在新的一行", true], ["\t  <!-- 回答开始 --> 回答这个问题。", true], ["<!-- 回答开始 --><p>Another response that correctly follows the instruction.</p>", true], ["<!-- 回答开始 -->这是正确的回答。", true]]}
{"instruction": "每个回答部分之间必须有一个明确的分隔符，使用三个减号表示 `---`。", "eval_func": [["def evaluate(response):\n    # Split the response into parts using the specified separator\n    parts = response.split('---')\n    # Strip whitespace from each part to avoid false negatives due to extra spaces\n    parts = [part.strip() for part in parts]\n    # Check that there is more than one part and none of the parts are empty\n    if len(parts) < 2 or any(part == '' for part in parts):\n        return False\n    # Reconstruct the response from the split parts\n    reconstructed_response = '---'.join(parts)\n    # Check that the reconstructed response matches the original response\n    return reconstructed_response == response", 1.0]], "cases": [["这是问题一的答案---这是问题二的答案---这是问题三的答案", true], ["只有一个问题的答案没有分隔符", false], ["第一个答案--- 第二个答案 --- 第三个答案", false]]}
{"instruction": "回答中包括三个二级标题，使用 markdown 语法编写，格式为 `## 标题`。", "eval_func": [["def evaluate(response):\n    try:\n        # Split the response into lines\n        lines = response.strip().split('\\n')\n        # Check if there are three lines that start with '## ' (markdown for secondary heading)\n        secondary_headings = [line for line in lines if line.startswith('## ')]\n        # Return True if there are exactly three secondary headings; Otherwise return False\n        return len(secondary_headings) == 3\n    except Exception as e:\n        return False", 1.0], ["def evaluate(response):\n    # Count the number of level-2 headings in the response using markdown syntax\n    count_headings = response.count('## ')\n\n    # Check if there are exactly three level-2 headings\n    return count_headings == 3", 1.0], ["def evaluate(response):\n    subheading_lines = [line.strip() for line in response.split('\\n') if line.strip().startswith('## ')]\n    if len(subheading_lines) != 3:\n        return False\n    for line in subheading_lines:\n        if len(line) < 4 or line[2] != ' ':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # This will match two hashtags followed by a space and then any character except a newline\n    pattern = r'## .+'\n    # Find all occurrences of the pattern\n    matches = re.findall(pattern, response)\n    # Check if there are exactly three matches\n    return len(matches) == 3\n\nimport re", 1.0], ["def evaluate(response):\n    subheadings = response.split('\\n')\n    subheading_count = 0\n    for line in subheadings:\n        if line.startswith('## '):\n            subheading_count += 1\n    return subheading_count == 3", 1.0]], "cases": [["Here is some text.\n\n## First Heading\nMore text.\n## Second Heading\nEven more text.\n## Third Heading\nEnd of text.", true], ["## First Heading\nSome text.\n## Second Heading\nSome more text.\nLast text without heading.", false], ["## 1. First Heading\nContent under the first heading.\n\n## 2. Second Heading\nContent under the second heading.\n\n## 3. Third Heading\nContent under the third heading.", true]]}
{"instruction": "回答中每个段落的首字母必须为大写。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # Skip empty paragraphs\n            continue\n        if not paragraph[0].isupper():  # Check the first character\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # empty paragraph, skip or consider it valid\n            continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph: continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0]], "cases": [["this should fail.\nBecause the first paragraph does not start with an uppercase letter.", false], ["First paragraph is fine.\nsecond paragraph starts with lowercase.", false], ["this starts with a lowercase letter.\\nThis one starts with uppercase.", false], ["this is the first paragraph without uppercase.\nThis is the second paragraph.", false], ["This is a test.\nEvery paragraph starts with an uppercase letter.\nDoes it follow the rule?", true], ["This is the first paragraph.\nAnd this is the second one.\nFinally, this is the third paragraph.", true], ["This is a test.\\nEach paragraph starts with a capital letter.\\nAll rules followed.", true]]}
{"instruction": "回答中必须包含至少三个用方括号括起来的关键字，如 `[关键字]`。", "eval_func": [["def evaluate(response):\n    import re\n    # Use regex to find all instances of words in brackets\n    matches = re.findall(r'\\[[^\\]]+\\]', response)\n    # Check if there are at least three keywords in brackets\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    keywords = re.findall(r'\\[[^\\]]+\\]', response)\n    return len(keywords) >= 3", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern to find '[keyword]' occurrences\n    pattern = re.compile(r'\\[.+?\\]')\n    # Find all matches of the pattern in the response\n    matches = pattern.findall(response)\n    # Check if there are at least three keyword brackets\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to find all occurrences of words within brackets\n    pattern = r'\\[[^\\]]+\\]'\n    # Find matches using the regular expression\n    matches = re.findall(pattern, response)\n    # Check if there are at least three bracketed keywords in the response\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    keywords = re.findall(r'\\[([^\\]]+)\\]', response)\n    return len(keywords) >= 3", 1.0]], "cases": [["这是一个示例回答，它包含了三个关键字，分别是[第一个]、[第二个]和[第三个]。", true], ["这个回答只有两个关键字：[仅仅第一个]和[仅仅第二个]。", false], ["虽然这个回答看似有很多关键字，但它们并未使用方括号，如第一个、第二个、第三个。", false]]}
{"instruction": "回答必须以至少三个 `#` 符号开头，表明这是一个一级标题。", "eval_func": [["def evaluate(response):\n    if not response.startswith('###'):\n        return False\n    if len(response) < 3:\n        return False\n    return not response[3].isalnum()", 1.0], ["def evaluate(response):\n    return response.startswith('###')", 1.0]], "cases": [["### This is a level one heading", true], ["## This is not correctly formatted", false], ["### Here is a Level 1 Heading", true], ["#### This is also a valid header but with extra hashes", true], ["#### Too many hashes but correct format", true], ["## This should be false since it has only two #", false], ["## This does not have enough hashes", false], ["### This is a title following the instructions", true], ["#### This is also a heading but with four #", true]]}
{"instruction": "回答中的日期必须以 ISO 8601 格式表示，即 `YYYY-MM-DD`。", "eval_func": [["def evaluate(response):\n    import re\n    # ISO 8601 date format regex pattern\n    pattern = r'^(19|20)\\d\\d-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$'\n    # Check if response matches ISO 8601 date format\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    iso_8601_pattern = r'\\b\\d{4}-\\d{2}-\\d{2}\\b'\n    search_result = re.findall(iso_8601_pattern, response)\n    for date_string in search_result:\n        year, month, day = map(int, date_string.split('-'))\n        if not (1 <= month <= 12 and 1 <= day <= 31):\n            return False\n    return len(search_result) == 1 and search_result[0] == response", 1.0], ["def evaluate(response):\n    import re\n    iso8601_pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n    matches_iso8601 = re.fullmatch(iso8601_pattern, response)\n    return bool(matches_iso8601)", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression for matching ISO 8601 Date Format\n    pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n    # Check if the response matches the ISO 8601 Date format\n    match = re.match(pattern, response)\n    # If there's a match, it means the response is in the correct format\n    return bool(match)", 1.0], ["def evaluate(response: str) -> bool:\n    import re\n    # Define a regular expression pattern for ISO 8601 date format YYYY-MM-DD\n    pattern = r'\\b(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])\\b'\n\n    # Search for the pattern in the response\n    match = re.fullmatch(pattern, response.strip())\n\n    # Check if there is a match and return True or False\n    return bool(match)", 1.0]], "cases": [["15-03-2023", false], ["2023/03/15", false], ["2023-03-15", true]]}
{"instruction": "回答中出现的所有英文单词必须使用反引号 ` 包围。", "eval_func": [["def evaluate(response):\n    import re\n    # Define a regex pattern that matches words that are NOT enclosed with backticks\n    pattern = r'\\b(?!`)[a-zA-Z]+(?!`)\\b'\n    # Use search to find a match of the pattern in the response\n    if re.search(pattern, response):\n        return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # Define regex pattern for finding words surrounded by backquotes\n    pattern = r'`([^`]+)`'\n    # Find all occurrences in the response\n    surrounded_words = re.findall(pattern, response)\n    # Remove surrounded words from the original response\n    modified_response = re.sub(pattern, '', response)\n    # Check for any English words left after removal of the quoted ones\n    remaining_words = re.findall(r'\\b[a-zA-Z]+\\b', modified_response)\n    # The response is valid only if there are no English words left\n    return len(remaining_words) == 0", 0.8333333333333334]], "cases": [["这个 `sentence` 没有使用反引号`correctly`。", false], ["所有英文单词都使用`backticks`包围着", true], ["这是一个正确的`example`", true], ["这是一个测试 `example`。", true], ["这里有 `two` 英文 `words`。", true], ["这个不包括反引号 example", false]]}
{"instruction": "回答所列每一点之间必须用至少两个连续空格分隔。", "eval_func": [["def evaluate(response):\n    parts = response.split()\n    for i in range(len(parts) - 1):\n        if '  ' not in response[response.find(parts[i]) + len(parts[i]):response.find(parts[i+1])]:\n            return False\n    return True", 0.8333333333333334], ["def evaluate(response):\n    points = response.split('  ')\n    for point in points:\n        if ' ' in point:\n            return False\n    return len(points) > 1", 0.8333333333333334]], "cases": [["符合规则的  例子  请检查", true], ["中间只有一个空格不符合规则", false], ["这是一个例子  用两个空格隔开  按照要求", true], ["这是一条指令  请严格遵守", true], ["这里仅有一个空格分隔 这是不符合要求的", false], ["这里有三个空格符合   要求", true]]}
{"instruction": "在回答中每次出现数字时，均需用一对方括号括起来，例如 `[42]`。", "eval_func": [["def evaluate(response):\n    import re\n    # This regex will find any standalone numbers or numbers not enclosed in brackets\n    pattern = r\"(\\D|^)(\\d+)(\\D|$)\"\n    # This finds all matches of the pattern in the response\n    matches = re.findall(pattern, response)\n    for match in matches:\n        # Check that each number is enclosed by brackets\n        before, number, after = match\n        if not (before.endswith('[') and after.startswith(']')):\n            return False\n    return True", 1.0]], "cases": [["这是正确的例子包含数字[42]和数字[23]。", true], ["所有数字都用括号括起来了，比如[100]、[200]和[300]。", true], ["这个例子不正确因为数字42没有用括号括起来。", false]]}
{"instruction": "如果回答含有代码，每一行代码需要有相应的缩进，采用四个空格表示。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        # Skip empty lines or lines not starting with code\n        if not line or line.lstrip() == line:\n            continue\n        # Check if the line starts with four spaces for indentation\n        if not line.startswith('    '):\n            return False\n        # Check if rest of the code (if any) after the initial indent doesn't have any bad indentation\n        code_after_indent = line[4:]\n        if code_after_indent.startswith(' '):\n            return False\n    return True", 0.8]], "cases": [["这里有非法的缩进：\n  只有两个空格", false], ["这是一行代码。\n这是没有缩进的代码行，应该返回False。", false], ["这是一段文本。\n    这是一行代码。\n    还有一行代码。", true], ["    这行正确，但下面的不行：\n\t使用了Tab而非空格", false], ["这是一条指令：\n    正确的缩进代码行\n    又一行正确缩进的代码", true]]}
{"instruction": "回答中出现的列表必须为交替的黑体和斜体项目，比如 **项目1** *项目2* **项目3**。", "eval_func": [["def evaluate(response):\n    items = response.split(' ')\n    is_bold = lambda s: s.startswith('**') and s.endswith('**')\n    is_italic = lambda s: s.startswith('*') and s.endswith('*') and not is_bold(s)\n    for i, item in enumerate(items):\n        if i % 2 == 0 and not is_bold(item):\n            return False\n        if i % 2 != 0 and not is_italic(item):\n            return False\n    return True", 0.8571428571428571], ["def evaluate(response):\n    items = response.split()\n    last_type = None\n    for item in items:\n        if item.startswith('**') and item.endswith('**') and len(item) > 4:\n            if last_type == 'b':\n                return False\n            last_type = 'b'\n        elif item.startswith('*') and item.endswith('*') and not item.startswith('**') and len(item) > 2:\n            if last_type == 'i':\n                return False\n            last_type = 'i'\n        else:\n            return False\n    return True", 1.0]], "cases": [["*项目1* **项目2** *项目3*", true], ["**项目1** 项目2 **项目3**", false], ["**项目1* *项目2* **项目3**", false], ["**项目1** *项目2* **项目3", false], ["**项目1** **项目2** *项目3*", false], ["**项目1** *项目2* **项目3**", true], ["**项目1** *项目2* **项目3*", false]]}
{"instruction": "回答中引用的所有链接必须采用 markdown 内联链接的格式 `[链接文本](链接地址)`。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find markdown links\n    pattern = r'\\[.*?\\]\\(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\\)'\n    # Find all markdown links in the response\n    markdown_links = re.findall(pattern, response)\n\n    # Split response into segments outside of markdown links\n    segments = re.split(pattern, response)\n\n    # Check segments that are not markdown links for the presence of URLs\n    url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n    for segment in segments:\n        if re.search(url_pattern, segment):\n            # If a URL is found outside a markdown link, return False\n            return False\n\n    # If no URLs found outside markdown links, return True\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    # Regular expression for markdown links\n    markdown_link_pattern = re.compile(r'\\[([^\\]]+)\\]\\((http[s]?://[^\\)]+)\\)')\n\n    # Find all markdown links in the response\n    markdown_links = markdown_link_pattern.findall(response)\n\n    # Find all href links in the response\n    href_links_pattern = re.compile(r'<a href=\"[^\"]+\">[^<]+</a>')\n    href_links = href_links_pattern.findall(response)\n\n    # The response is valid only if there are no href links\n    # and if all links are in markdown format\n    return not href_links and len(markdown_links) == response.count('http')", 1.0]], "cases": [["沒有使用任何链接的文本。", true], ["這是一個正確格式的範例：[Google](http://www.google.com)。", true], ["This is a correct link: [Google](http://google.com).", true], ["This is an incorrect link format: <a href=\"http://google.com\">Google</a>.", false], ["Multiple links can be included like [Bing](http://bing.com) and [Yahoo](http://yahoo.com), as long as they are correct.", true], ["這是一個錯誤格式的範例：[Google]http://www.google.com。", false]]}
{"instruction": "回答中的所有命令或指令必须在单独的一行，以 `$` 符号开头。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line.startswith('$') and line.replace('$', '').strip() == '':\n            continue\n        elif line.strip() and not line.startswith('$'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        strip_line = line.strip()\n        if strip_line and not strip_line.startswith('$'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line and not line.startswith('$'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    lines = response.split('\\n')\n    for line in lines:\n        # Check if the line is empty or starts with a $ symbol\n        if line and not line.startswith('$'):\n            return False\n    return True", 1.0]], "cases": [["$ pwd\nThis should fail too", false], ["$ echo 'Hello'\n$ ls -la\n", true], ["This should fail because it doesn't start with $\n$ whoami\n", false], ["This should fail\n$ uname -r", false], ["$ echo 'Hello World'\n$ ls -la", true], ["$ ps -aux\nSome text without $", false]]}
{"instruction": "回答中的每个例子必须有明确的标注，使用 `例:` 开始。", "eval_func": [["def evaluate(response):\n    examples = response.split('\\n')\n    for example in examples:\n        if example.strip() == '': continue\n        if not example.strip().startswith('例:'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    examples = response.split('\\n')\n    for example in examples:\n        if example.strip():  # ignore empty lines\n            if not example.startswith('例:'):\n                return False\n    return True", 1.0], ["def evaluate(response):\n    examples = response.split('\\n')\n    for example in examples:\n        if example:\n            if not example.startswith('例:'):\n                return False\n    return True", 1.0], ["def evaluate(response):\n    examples = response.split('\\n')\n    for example in examples:\n        if not example.startswith('例:'):\n            return False\n    return True if examples else False", 0.8888888888888888]], "cases": [["例: 这是一个遵循指令的例子。\n例: 这是第二个例子。", true], ["这是一条不符合规则的回答。\n例: 虽然这里有一个例子标记，上面的回答已经违反了规则。", false], ["例: 这是一条遵守规则的回答。\n例: 这是另一个例子。", true], ["例: 这是一个遵循指示的例子。\n例: 另一个正确的例子。", true], ["例: 这个遵循了。\n但是这一行不遵循。", false], ["", true], ["例: 这里一个例子。\n但这一行却没有正确标记。", false], ["这个例子没有用“例:”开始。", false], ["这是不遵循指令的例子。", false]]}
{"instruction": "回答中的每个操作步骤都必须用一对半角括号包围，比如 `(操作步骤)`。", "eval_func": [["def evaluate(response):\n    pieces = response.split('()')\n    for piece in pieces:\n        if '(' in piece or ')' in piece:\n            return False\n    stripped = [part.strip() for part in response.split(')')]\n    for part in stripped:\n        if not part:\n            continue\n        if '(' not in part[-1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    pairs = response.split(')')\n    if pairs[-1] == '':\n        pairs.pop() # Remove the last empty element if present due to trailing )\n    for pair in pairs:\n        if not pair.startswith('('):\n            return False\n        if ' ' not in pair[1:]: # Check if there is at least one word between brackets\n            return False\n    return True", 1.0], ["def evaluate(response):\n    steps = response.split('(操作步骤)')\n    # If steps are properly split, there should be no other text outside the split parts\n    return len(steps) > 1 and all([(part == '' or part == '(操作步骤)') for part in steps])", 1.0], ["def evaluate(response):\n    import re\n\n    # Regex to identify all contents in half-width parenthesis\n    pattern = re.compile(r'\\((.*?)\\)')\n\n    # Find all matches\n    matches = pattern.findall(response)\n\n    # If no matches, return False\n    if not matches:\n        return False\n\n    # If there are characters outside the matches, return False\n    stripped_response = pattern.sub('', response).strip()\n    if stripped_response:\n        return False\n\n    # If all text is within half-width parenthesis, return True\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Check if every step is surrounded by a pair of half-width parentheses\n    steps = re.findall(r'\\([^\\)]+\\)', response)\n    # Split response on the steps and check if there are non-whitespace characters outside the steps\n    split_response = re.split(r'\\([^\\)]+\\)', response)\n    outside_steps = ''.join(split_response).strip()\n    return not outside_steps and len(steps) == len(split_response) - 1", 1.0]], "cases": [["错误示例：(这是一个错误的示例，因为这里没有结束的括号", false]]}
{"instruction": "回答的每一部分应该以竖线符号 `|` 作为开始。", "eval_func": [["def evaluate(response):\n    parts = response.split('|')\n    if parts[0] != '':\n        return False\n    for part in parts[1:]:\n        if not part:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    parts = response.split('|')\n    # Removing empty string before the first |\n    if parts[0] == '':\n        parts = parts[1:]\n    for part in parts:\n        if not part.startswith(' '):\n            return False\n    return True", 1.0]], "cases": [["这是一个没有竖线开始的部分 | 再一个正常的部分", false], ["| 仅有一部分且正确开始", true], ["| 这是第一部分 | 这是第二部分", true]]}
{"instruction": "在每个回答部分之后，必须添加一行横线，使用 markdown 语法 `---`。", "eval_func": [["def evaluate(response):\n    sections = response.strip().split('\\n')\n    for i in range(1, len(sections), 2):\n        if sections[i].strip() != '---':\n            return False\n    return len(sections) % 2 == 0", 1.0], ["def evaluate(response):\n    parts = response.split('\\n')\n    for i in range(1, len(parts), 2):\n        if parts[i].strip() != '---':\n            return False\n    return True if len(parts) % 2 == 0 else False", 1.0]], "cases": [["这是第一个回答。\n这不是横线。\n这是第二个回答。\n---", false], ["这是第一个回答。\n---\n这是第二个回答。\n---", true], ["这是第一个回答。\n---\n这是第二个回答。", false]]}
{"instruction": "回答中对于重要概念必须使用 markdown 的加重语法，即 **重要概念**。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Split response into chunks using markdown bold as delimiters\n    chunks = re.split(r'\\*\\*(.+?)\\*\\*', response)\n\n    # List of important concepts needs to be checked\n    important_concepts = ['重要概念'] \n\n    # Check if each important concept is enclosed in ** **\n    for concept in important_concepts:\n        pattern = r'\\*\\*' + re.escape(concept) + r'\\*\\*'\n        if not re.search(pattern, response):\n            return False\n\n    # Check if there are any additional ** usage that doesn't correspond to important concepts\n    bold_phrases = re.findall(r'\\*\\*(.+?)\\*\\*', response)\n    for phrase in bold_phrases:\n        if phrase not in important_concepts:\n            return False\n\n    return True", 1.0]], "cases": [["回答中每一个**重要概念**都必须使用 markdown 的加重语法表示。", true], ["回答中没有使用 markdown 的**加重**语法。", false], ["回答不包含加重的概念。", false]]}
{"instruction": "每个数据点或实例在回答中必须有单独的一段解释，解释前用 `>>` 标明。", "eval_func": [["def evaluate(response):\n    segments = response.strip().split('\\n')\n    if not all(segment.startswith('>>') for segment in segments):\n        return False\n    explanation_segments = [seg[2:].strip() for seg in segments if seg.startswith('>>')]\n    if not all(explanation_segments):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by newlines\n    parts = response.strip().split('\\n')\n    \n    for part in parts:\n        # Check if each part starts with '>>'\n        if not part.startswith('>>'):\n            return False\n        # Check if there's an explanation after '>>'\n        explanation = part[2:].strip()\n        if not explanation:\n            return False\n    \n    # Check if there's at least one data point or instance with an explanation\n    return bool(parts)", 1.0]], "cases": [[">> 第一个数据点的解释\n>> 第二个数据点的解释\n第三个数据点的解释", false], [">>第一个数据点的解释\n\n>> 第二个数据点的解释\n\n>> 第三个数据点的解释", false], [">> 第一个数据点的解释\n>> 第二个数据点的解释\n>> 第三个数据点的解释", true]]}
{"instruction": "回答中出现的所有文件路径必须采用等宽字体显示，使用单个反引号 ` 包围。", "eval_func": [["def evaluate(response: str) -> bool:\n    import re\n\n    # Define regex pattern for a file path enclosed within backticks\n    path_pattern = r'`[^`\\n]+`'\n    \n    # Find all instances that should be a path enclosed within backticks\n    paths_found = re.findall(path_pattern, response)\n    \n    # Check if there exists any file paths outside of backticks\n    def is_path(text):\n        # This is a simplistic check for paths.\n        # In practice, we would need a more elaborate method to locate file paths.\n        path_indicators = ['/', '\\\\', '.txt', '.exe', '.py', 'C:', '/dev']\n        return any(indicator in text for indicator in path_indicators)\n    \n    # Replace validated paths with a placeholder to exclude them from the next search\n    response_no_paths = re.sub(path_pattern, '', response)\n    \n    # Split by whitespace to inspect individual words\n    for word in response_no_paths.split():\n        if is_path(word):\n            return False  # Found a file path not enclosed in backticks\n    \n    return True  # No file paths found outside of backticks", 0.8333333333333334]], "cases": [["Linux系统上的路径通常为 /home/user/docs/, 这里出错了。", false], ["回答中正确显示文件路径： `/etc/passwd` 和 `/home/user/.bashrc`", true], ["路径 `C:/Program Files/app/` 不应该有空格。", true], ["文件路径包围了但包围不正确： `C:\\\\Program Files\\\\` and `/tmp/`", false], ["请查看配置文件 `config/settings.json` 然后更新。", true], ["文件路径未被等宽字体显示： /var/log/syslog", false]]}
{"instruction": "在回答的开头和结尾分别添加“【开始】”和“【结束】”。", "eval_func": [["def evaluate(response):\n    return response.startswith(\"【开始】\") and response.endswith(\"【结束】\")", 1.0], ["def evaluate(response):\n    if not response.startswith('【开始】') or not response.endswith('【结束】'):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    return response.startswith('【开始】') and response.endswith('【结束】')", 1.0]], "cases": [["这是错误的格式【结束】", false], ["This does not start with the required text【结束】", false], ["【开始】这是一个按照指令格式化的回答【结束】", true], ["【开始】这条回答没有正确的结尾", false], ["这是一个没有按照指令格式化的回答【结束】", false], ["【开始】Here is a sample response【结束】", true], ["【开始】这是一条遵守指令的回答【结束】", true], ["这是一条不遵守指令的回答", false], ["【开始】这是错误的格式", false], ["【开始】这是另一个没有按照指令格式化的回答", false], ["【开始】这是正确的格式【结束】", true], ["【开始】What if it doesn't end correctly", false]]}
{"instruction": "需要在回答中插入一个表格，表格至少包含两行两列。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n\n    try:\n        # Attempt to parse the response as if it is HTML/XML content\n        root = ET.fromstring('<root>' + response + '</root>')\n\n        # Find tables in the response\n        tables = root.findall('.//table')\n\n        # Evaluate if any table has at least two rows and two columns\n        for table in tables:\n            rows = table.findall('.//tr')\n            if len(rows) < 2:  # Check for at least two rows\n                continue\n\n            for row in rows:\n                columns = row.findall('.//td') + row.findall('.//th')\n                if len(columns) < 2:  # Check for at least two columns\n                    break\n            else:\n                return True  # Found a table that satisfies the condition\n\n        return False\n    except ET.ParseError:\n        # If an error occurred while parsing, the response is not a valid HTML/XML\n        return False", 0.8], ["def evaluate(response):\n    try:\n        # Primitive check for a table structure\n        # Splitting the response into lines\n        lines = response.strip().split('\\n')\n        # Counting the number of lines and columns\n        line_count = 0\n        column_count_set = set()\n        for line in lines:\n            # Assuming '|' is used as a column delimiter for the table\n            if '|' in line:\n                parts = line.split('|')\n                # Filter out empty strings if extra delimiters are used\n                parts = [part for part in parts if part.strip() != '']\n                if parts:\n                    line_count += 1\n                    column_count_set.add(len(parts))\n\n        # Evaluating the table structure\n        if line_count >= 2 and all(count >= 2 for count in column_count_set):\n            return True\n        return False\n    except Exception as e:\n        return False", 0.8], ["def evaluate(response):\n    try:\n        # Check if there is a table in response\n        start_table = response.index('<table>')\n        end_table = response.index('</table>')\n        table_content = response[start_table:end_table]\n\n        # Count rows - Look for <tr> tags\n        rows = table_content.split('<tr>')\n        valid_rows = [row for row in rows if '</tr>' in row]\n\n        # Count columns by looking for <td> tags in the first valid row\n        if len(valid_rows) >= 2:\n            first_row_columns = valid_rows[0].split('<td>')\n            valid_columns = [col for col in first_row_columns if '</td>' in col]\n            if len(valid_columns) >= 2:\n                return True\n\n    except ValueError:\n        # .index() will raise a ValueError if '<table>' or '</table>' is not found\n        pass\n\n    return False", 0.8]], "cases": [["<table><tr><td>Cell 1</td><td>Cell 2</td></tr><tr><td>Cell 3</td><td>Cell 4</td></tr></table>", true], ["+------+\n| cell |\n+------+\n| cell |\n+------+\n", false], ["+------+------+\n| cell | cell |\n+------+------+\n| cell | cell |\n+------+------+\n", true], ["<p>This is a paragraph, not a table.</p>", false], ["<table><tr><td>Only one row</td></tr></table>", false]]}
{"instruction": "回答中必须包含一个用单引号(')包裹的短语。", "eval_func": [["def evaluate(response):\n    single_quote_indices = [i for i, char in enumerate(response) if char == \"'\"]\n    if len(single_quote_indices) >= 2 and single_quote_indices[0] + 1 < single_quote_indices[-1]:\n        return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to find phrases enclosed in single quotes\n    match = re.findall(r\"'([^']+)'\", response)\n    # Check if there is at least one match and return True if so\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # Check if the response contains a phrase enclosed with single quotes\n    return bool(re.search(r\"'[^']*'\", response))", 0.8333333333333334], ["def evaluate(response):\n    if \"'\" in response:\n        parts = response.split(\"'\")\n        # Check if there's at least one quoted phrase\n        return len(parts) > 2 and parts[1].strip() != ''\n    return False", 1.0]], "cases": [["这是一个正确的回答，其中含有一个用单引号('正确短语')包裹的短语。", true], ["这个回答没有使用单引号包裹短语。", false], ["这里'有单引号'但是'多于一个'短语被包裹。", true], ["这里没有使用单引号包裹的短语。", false], ["这句话有单引号''但是里面没有内容。", false], ["這句話里面有一个用单引号包裹的'短语'。", true]]}
{"instruction": "回答必须使用markdown代码格式显示至少一个单词，用反引号(`)包裹。", "eval_func": [["def evaluate(response):\n    try:\n        # Check for any substrings enclosed in single backticks\n        # There should be at least one\n        parts = response.split('`')\n        # To have a markdown code, substrings length should be odd\n        # and at least three elements (opening backtick, code, closing backtick)\n        if len(parts) < 3 or len(parts) % 2 == 0:\n            return False\n\n        # Check that each backtick pair contains at least one character\n        for i in range(1, len(parts), 2):\n            if not parts[i].strip():\n                return False\n\n        return True\n    except:\n        return False", 1.0], ["def evaluate(response):\n    inside_code = False\n    found_word = False\n\n    for i, char in enumerate(response):\n        if char == '`':\n            if inside_code:\n                # Check if there is at least one character between the backticks\n                if i > 0 and response[i-1] != '`':\n                    found_word = True\n                inside_code = False\n            else:\n                inside_code = True\n        elif not inside_code and char in '\\n':\n            # Reset found_word if a newline is found outside code format\n            found_word = False\n\n    return found_word and not inside_code", 1.0], ["def evaluate(response):\n    import re\n    # Check if the response contains at least one word wrapped in backticks\n    pattern = r'`\\w+`'\n    return bool(re.search(pattern, response))", 1.0]], "cases": [["Multiple `words` are `formatted`.", true], ["遗漏了反引号。", false], ["两边的反引号都没有内容``。", false], ["This `is` a correct answer.", true], ["这是一个`正确`的回答。", true], ["This is a `markdown` example.", true], ["This text does not have markdown code.", false], ["This is an incorrect answer.", false], ["这是一个正确的回答`word`。", true]]}
{"instruction": "回答需要用markdown的分割线表示法在两处区分不同内容，即使用三个或以上连续的减号(---)。", "eval_func": [["def evaluate(response):\n    parts = response.split('---')\n    clean_parts = [part for part in parts if part.strip() != '']\n    return len(clean_parts) >= 3", 1.0]], "cases": [["We have two separators here, but one is not proper.\\n------\\nThis is okay.\\n- - -\\nThis is not.", false], ["Only one separator is not enough.\\n---\\nBut we need two separators.", false], ["This is the first part.\\n---\\nThis is the second part.\\n---\\nThis is the third part.", true]]}
{"instruction": "回答中需要有一个外链，表现为文字链接形式，比如[外链文字](http://example.com)。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\[.*?\\]\\(http[s]?://[^\\s]+\\)'\n    return bool(re.search(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    # Define the regular expression pattern for Markdown link\n    pattern = r'\\[.*?\\]\\(http[s]?://.*?\\)'\n    # Search for the pattern in the response\n    match = re.search(pattern, response)\n    # Return True if the pattern is found, otherwise False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\[[^\\]]+\\]\\(http[s]?://[^\\)]+\\)'\n    match = re.search(pattern, response)\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # The pattern looks for a markdown formatted link with text followed by a URL in parentheses\n    pattern = r'\\[.+?\\]\\(http[s]?://[^)]+\\)'\n    # Search for the pattern in the response\n    result = re.search(pattern, response)\n    # Return True if the pattern is found, otherwise False\n    return bool(result)", 1.0]], "cases": [["外链格式不正确，比如 www.example.com 。", false], ["回答中包含了一个外链，如下：[外链文字](http://example.com)。", true], ["请访问我的个人网站：http://example.com不是文本链。", false], ["这里是一个[外链](https://example.com)，但是还有另一个[链接](http://anotherexample.com)。", true], ["回答中没有外链。", false], ["请点击这个[外链文字](http://example.com)来访问我的个人网站。", true]]}
{"instruction": "回答中的每个段落首行需要缩进四个空格。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):  # Checks for four spaces\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):  # Checks if each paragraph starts with 4 spaces\n            return False\n    return True", 1.0]], "cases": [["    这是遵循指示的第一段。\n    这是第二段，也有四个空格缩进。", true], ["    这段缩进了，但是\n这一行没有缩进。", false], ["这是一段没有缩进的文本。\n    这是一段缩进了的文本。", false], ["这一段没有缩进，所以应该返回False。", false], ["    这是第一段的开始。\n    这是第二段的开始，也遵循了规定。", true]]}
{"instruction": "回答中必须包含三个以上的斜体markdown格式的单词，即用单个星号(*)或下划线(_)包裹。", "eval_func": [["def evaluate(response):\n    import re\n    # Count italic words using a regex pattern\n    italic_words = re.findall(r'(?<=\\*|_)\\w+(?=\\*|_)', response)\n    # Return True if there are three or more italic words, else False\n    return len(italic_words) >= 3", 1.0], ["def evaluate(response):\n    import re\n    italic_words = re.findall(r'(?<=\\*|_)[^\\*_]+(?=\\*|_)', response)\n    return len(italic_words) >= 3", 1.0], ["def evaluate(response):\n    import re\n    count = len(re.findall(r'\\*(\\w+)\\*|_(\\w+)_', response))\n    return count >= 3", 1.0], ["def evaluate(response):\n    import re\n    # This pattern matches words in markdown italics\n    pattern = r'(\\*|_)([^\\*_]+)\\1'\n    # Find all italic words in the response\n    italic_words = re.findall(pattern, response)\n    # Check if there are at least 3 italic words\n    return len(italic_words) >= 3", 1.0]], "cases": [["这是一句包含 *斜体* 文字的回答，其中 *_包含_* 了三个 _斜体_ 单词。", true], ["这是第二个测试案例，里面只有两个 *斜体* 单词。", false], ["一个 *_包含_* 四个语言元素的 *例子* ，但是斜体词汇实际上有 *四个* 。", true]]}
{"instruction": "回答中必须包含四个以上的子列表项，并用四个空格缩进。", "eval_func": [["def evaluate(response):\n    # Split the response using newlines to get the items\n    items = response.split('\\n')\n    # Count the number of items with four leading spaces (indentation)\n    count = 0\n    for item in items:\n        if item.startswith('    '):\n            count += 1\n    # Check if count is greater than or equal to 4\n    return count >= 4", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    count = 0\n    for item in items:\n        if item.startswith('    '):  # check indentation by 4 spaces\n            count += 1\n            if count >= 4:\n                return True\n    return False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    sub_list_count = 0\n    for line in lines:\n        if line.startswith('    ') and line.strip():\n            sub_list_count += 1\n    return sub_list_count >= 4", 1.0]], "cases": [["子列表项1\n子列表项2\n子列表项3\n子列表项4\n都没有缩进", false], ["    子列表项1\n    子列表项2\n    子列表项3\n    子列表项4\n正文内容不缩进", true], ["    List item 1\n    List item 2\n    List item 3\n    List item 4\nExtra line", true], ["    只有两个子列表项缩进\n    子列表项1\n这是正文内容\n    子列表项2", false], ["    List item 1\n    List item 2\n    List item 3\n    List item 4\n    List item 5", true], ["List item 1\n    List item 2\n    List item 3\nList item 4", false]]}
{"instruction": "回答必须包含至少两个问题，并且每个问题都用问号(?)结束。", "eval_func": [["def evaluate(response):\n    questions = response.split('?')\n    if len(questions) < 3:\n        return False\n    for question in questions[:-1]:\n        if not question.strip():\n            return False\n    return True if questions[-1].strip() == '' else False", 1.0]], "cases": [["这是问题吗。不是带问号的。", false], ["第一个问题结束了?第二个问题呢?这里又是一个问题?", true]]}
{"instruction": "回答中需要使用至少5个带有下划线(_)的空格填充的占位符，例如______。", "eval_func": [["def evaluate(response):\n    placeholders = response.count('______')\n    return placeholders >= 5", 1.0], ["def evaluate(response):\n    placeholders = response.count('_'*6)\n    return placeholders >= 5", 1.0]], "cases": [["这个例子有很多占位符，但没有用下划线:      。", false], ["这个例子没有足够的占位符______ ______。", false], ["这是一个例子，其中包含了足够的占位符______ ______ ______ ______ ______来满足条件。", true]]}
{"instruction": "回答中每一行必须以英文字母\"A\"开头。", "eval_func": [["def evaluate(response):\n    # Split the response into lines\n    lines = response.split('\\n')\n    # Check if each line starts with 'A'\n    for line in lines:\n        # Skip empty lines\n        if not line:\n            continue\n        if not line.startswith('A'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('A'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    return all(line.startswith('A') for line in lines if line.strip())", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    lines = response.split('\\n')\n    # Check that each line starts with 'A'\n    for line in lines:\n        if not line.startswith('A'):\n            return False\n    return True", 1.0]], "cases": [["AThis is the first line.\nAAnd this starts with A as well.", true], ["这是第一行\nA这是第二行", false], ["AAll good here.\nBut not here.", false], ["A每一行都以A开头\nA没有例外", true], ["A这是第一行\nA这是第二行", true], ["This does not follow the instruction.", false], ["A每行都以A开头\nA确实如此", true], ["A这是第一行\n这不是以A开头的行\nA这是第三行", false], ["A这是第一行\nA这是第二行\nA这是第三行", true]]}
{"instruction": "回答应该以一个横幅开始，使用markdown格式，即用三个连等号(===)表示。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    if not lines or len(lines[0]) < 1:\n        return False\n    return lines[0].startswith('===')", 0.8333333333333334], ["def evaluate(response):\n    # Check if the response starts with a markdown banner\n    if response.startswith('===') and '\\n' in response:\n        # Check if the markdown banner is immediately followed by more content \n        # (newline after '===')\n        banner_end_idx = response.find('\\n')\n        if banner_end_idx != -1 and banner_end_idx > 3:\n            # There must be non-whitespace characters after the banner\n            content_after_banner = response[banner_end_idx+1:].lstrip()\n            return bool(content_after_banner)\n    return False", 0.8333333333333334], ["def evaluate(response):\n    lines = response.split('\\n')\n    if lines and lines[0].startswith('==='):\n        return True\n    else:\n        return False", 0.8333333333333334], ["def evaluate(response):\n    if not response:\n        return False\n    lines = response.split('\\n')\n    first_line = lines[0].strip() if lines else ''\n    return first_line.startswith('===') and first_line.endswith('===')", 0.8333333333333334]], "cases": [["== Banner missing one equals sign\ntext under the banner", false], ["This response does not have a banner at the beginning.", false], ["=== Banner starts but does not end with triple equals\nSome more text.", false], ["=== Banner\ntext under the banner", true], ["=== Banner ===\nThis is a response that starts with a banner.", true], ["text without a banner", false]]}
{"instruction": "回答中必须包含字母序列（如 ABCD），并用方框[ABCD]标出。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\[(A.*?B.*?C.*?D.*?)\\]'\n    match = re.search(pattern, response)\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\[([A-Z]{2,})\\]'\n    matches = re.findall(pattern, response)\n    if not matches:\n        return False\n    for match in matches:\n        if ''.join(sorted(match)) != match:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\[(A.*B.*C.*D.*?)\\]'\n\n    if not re.search(pattern, response):\n        return False\n\n    sequence = re.findall(pattern, response)\n    for seq in sequence:\n        clean_seq = ''.join(filter(str.isalpha, seq))\n        if list(clean_seq) != sorted(set(clean_seq), key=lambda x: clean_seq.index(x)):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'\\[([A-Z]+)\\]')\n    matches = pattern.findall(response)\n    for match in matches:\n        if all(ord(match[i]) == ord(match[i-1]) + 1 for i in range(1, len(match))):\n            return True\n    return False", 1.0]], "cases": [["正确序列在这里[ABXD]，但是不完全符合。", false], ["回答中包含了序列[ABCD]，符合要求。", true], ["这是一个错误的回答，没有指定的序列。", false]]}
{"instruction": "回答中的数据需要用括号并标明单位，如（5kg）。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = re.compile(r'\\(\\d+(\\.\\d+)?[a-zA-Z]+\\)')\n    matches = pattern.findall(response)\n    return bool(matches) and all(match in response for match in matches)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\(\\d+(\\.\\d+)?[a-zA-Z]{1,3}\\)'\n    return bool(re.search(pattern, response))", 1.0]], "cases": [["这件衣服的重量是5kg。", false], ["格式不正确应该是（500g）而不是500克。", false], ["The weight is reported to be 12.5 kilograms (12.5kg).", true]]}
{"instruction": "回答中至少出现三次用 markdown 中的图片语法标记的图片，如![图片描述](图片链接)。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the markdown image syntax pattern\n    markdown_image_pattern = r'!\\[[^\\]]*\\]\\([^)]+\\)'\n\n    # Find all occurrences of markdown image syntax\n    images = re.findall(markdown_image_pattern, response)\n\n    # Check if at least three markdown images are present\n    return len(images) >= 3", 1.0], ["def evaluate(response):\n    import re\n    markdown_image_pattern = r'!\\[[^\\]]*\\]\\([^\\)]+\\)'\n    images = re.findall(markdown_image_pattern, response)\n    return len(images) >= 3", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'!\\[[^]]*\\]\\([^)]+\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'!\\[.*?\\]\\(.*?\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 3", 1.0]], "cases": [["只有两个图片 ![First](http://example.com/1.png) 和 ![Second](http://example.com/2.png) 所以不符合要求。", false], ["这里有很多文字，但并没有三个图片标记。注意看！[Oops](http://example.com/oops.png) 只有一个。", false], ["这是一个图片 ![Image One](http://example.com/one.png) 这是第二个 ![Image Two](http://example.com/two.png) 最后一个 ![Image Three](http://example.com/three.png)", true]]}
{"instruction": "回答中必须包含一个带有序号列表的清单，格式为：“1. XXX；2. XXX；3. XXX。”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the regular expression pattern for the required list format\n    pattern = r'(?<!\\d)1\\.\\s*\\S.*?；\\s*2\\.\\s*\\S.*?；\\s*3\\.\\s*\\S.*?。'\n\n    # Use regex search to check if the pattern is found within the response\n    if re.search(pattern, response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'^\\s*1\\.\\s+.+；\\s*2\\.\\s+.+；\\s*3\\.\\s+.+。\\s*$')\n    return bool(pattern.match(response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'^1\\.\\s+.*\\uff1b2\\.\\s+.*\\uff1b3\\.\\s+.*\\u3002$'\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    # Compile a regular expression pattern for the ordered list format\n    pattern = re.compile(r'^(\\d+\\.\\s.+?；)*(\\d+\\.\\s.+?。)$')\n    # Search for the pattern in the response\n    if pattern.search(response):\n        # Split the response to validate individual list items\n        items = response[:-1].split('；')\n        # Check if each item starts with a proper numeric sequence\n        for index, item in enumerate(items, start=1):\n            if not item.startswith(f'{index}. '):\n                return False\n        return True\n    return False", 1.0]], "cases": [["1. Apple；2. Banana；3. Cherry。", true], ["1. 第一項目 2. 第二項目 3. 第三項目", false], ["1. 這是第一項；2. 這是第二項；3. 這是第三項。", true]]}
{"instruction": "回答必须开始于一行空白，紧接着是你的文本内容。", "eval_func": [["def evaluate(response):\n    if response.startswith('\\n'):\n        stripped_response = response.lstrip('\\n')\n        if stripped_response and not stripped_response.startswith('\\n'):\n            return True\n    return False", 1.0], ["def evaluate(response):\n    # First, split the string into lines\n    lines = response.split('\\n')\n    # Check if the first line is empty (whitespace only or nothing at all)\n    if not lines[0].strip():\n        # If there is text content after the first line, evaluate to True\n        return len(lines) > 1 and lines[1].strip() != ''\n    return False", 1.0], ["def evaluate(response):\n    if not response.startswith('\\n'):\n        return False\n    non_empty_lines = [line for line in response.splitlines() if line.strip()]\n    return len(non_empty_lines) > 0 and response.index(non_empty_lines[0]) == 1", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n    lines = response.split('\\n')\n    if len(lines) < 2:\n        return False\n    return lines[0].strip() == '' and lines[1].strip() != ''", 1.0], ["def evaluate(response):\n    if not response.startswith('\\n'):\n        return False\n    text_content = response.lstrip('\\n')\n    return len(text_content) > 0", 1.0]], "cases": [["\\n\\n这个文本有多于一行的空白开始。", false], ["这不是从新行开始的文本。", false]]}
{"instruction": "回答中引用语言需要用markdown的引用格式，即在每行引用的前面加上“> ”。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line and not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line.strip() == '':\n            continue\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line.strip() and not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    lines = response.split('\\n')\n    # Check each line for markdown quote format\n    for line in lines:\n        # Skip empty lines\n        if not line.strip():\n            continue\n        # Check if the line starts with '> '\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Check each line to see if it starts with \"> \" if it is non-empty\n    for line in response.split('\\n'):\n        if line and not line.startswith('> '):\n            return False\n    return True", 1.0]], "cases": [["> This is a quoted line.\n> This is another quoted line.\n\n> This is yet another quoted line.", true], ["> 引用格式正确的第一行\n\n> 引用格式正确的第二行，前面有空行", true], ["> 这是一行引用的文本。\n> 这是另一行引用的文本。", true], ["这是一行未使用正确引用格式的文本。\n> 这是一行正确引用的文本。", false], ["This line does not have the markdown.\n> This line does.", false], ["> This is a quoted line.\nThis should be quoted but is not.", false], ["> All lines are quoted correctly.\n> Even this one.\n> And this one.", true], ["> This is a line with proper markdown quote.\n> This is another properly formatted line.", true]]}
{"instruction": "将回答的每一部分用不同的markdown列表符号标记，如第一部分用“* ”，第二部分用“- ”。", "eval_func": [["def evaluate(response):\n    parts = response.split('\\n')\n    if not parts or len(parts) < 2:\n        return False\n    if not parts[0].startswith('* '):\n        return False\n    for i in range(1, len(parts)):\n        if not parts[i].startswith('- '):\n            return False\n    return True", 0.875], ["def evaluate(response):\n    parts = response.split('\\n')\n    if not parts or len(parts) < 2:\n        return False\n\n    # Check if first part starts with '* '\n    if not parts[0].startswith('* '):\n        return False\n\n    # Check if second part starts with '- '\n    if not parts[1].startswith('- '):\n        return False\n\n    # Check if additional parts start with either '* ' or '- '\n    for part in parts[2:]:\n        if not (part.startswith('* ') or part.startswith('- ')):\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    parts = response.strip().split('\\n')\n    if not parts or len(parts) < 2:\n        return False\n\n    has_asterisk = parts[0].startswith('* ')\n    has_dash = parts[1].startswith('- ')\n\n    if has_asterisk and has_dash:\n        for part in parts[2:]:\n            if part.startswith('* ') or part.startswith('- '):\n                continue\n            else:\n                return False\n        return True\n    return False", 1.0]], "cases": [["* 第一部分\n- 第二部分\n* 第三部分", true], ["* 第一部分\n* 第二部分\n* 第三部分", false], ["- This part should have had an asterisk\n- This is the second part", false], ["- 第一部分错了\n- 第二部分\n* 第三部分", false], ["* This is the first part\n- This is the second part\n- This is another part following the second one", true], ["* 第一部分\n- 第二部分\n- 第三部分错了", true], ["- 第一部分\n* 第二部分\n- 第三部分", false], ["* First part correct\n* But this should have been a dash", false]]}
{"instruction": "回答中出现的数字列表需要交替使用圆点和短横线，首个使用圆点。", "eval_func": [["def evaluate(response):\n    numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    pattern = [True, False]  # True for circle, False for hyphen\n    idx = 0\n\n    for char in response:\n        if char in numbers:\n            expected_pattern = pattern[idx % 2]\n            preceding_char = response[response.index(char) - 1] if response.index(char) > 0 else ''\n            if expected_pattern and preceding_char != '●':  # Circle not found where expected\n                return False\n            if not expected_pattern and preceding_char != '-':  # Hyphen not found where expected\n                return False\n            idx += 1\n\n    return True if idx % 2 == 0 else False", 1.0], ["def evaluate(response):\n    import re\n    # Define a regex pattern for alternating bullet and dash sequences\n    pattern = r'(?<!\\d)(\\d+\\u2022(\\d+-)?)+(\\d+)?(?=\\D|$)'\n    # Find all occurrences of the pattern\n    all_matches = re.findall(pattern, response)\n    # Flatten the matches and filter out empty strings\n    matches = [item for sublist in all_matches for item in sublist if item != '']\n    # Split the response into segments by non-digit, non-bullet, non-dash characters\n    segments = re.split(r'[^0-9\\u2022-]+', response)\n    # Filter out empty segments\n    segments = [segment for segment in segments if segment]\n\n    # Check if the segments match the matches exactly\n    return matches == segments", 1.0], ["def evaluate(response):\n    symbols = iter(['\\u2022', '-'])\n    current_symbol = next(symbols)\n    previous_was_digit = False\n    for char in response:\n        if char.isdigit():\n            if previous_was_digit:\n                continue\n            previous_was_digit = True\n        else:\n            if previous_was_digit:\n                if char != current_symbol:\n                    return False\n                current_symbol = next(symbols, None) if current_symbol else '\\u2022'\n            previous_was_digit = False\n    return True", 1.0]], "cases": [["请参考以下数列：8- 7• 6- 5• 4-", false], ["1.2-3.4-5.6", false], ["14-15.16.17-18", false], ["数字序列：0• 1- 2• 3- 不符合要求", false]]}
{"instruction": "回答应包含至少三个带下划线的单词或短语，如“_例子_”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\b_+[^_]+_\\b'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 3", 1.0]], "cases": [["这只有两个带下划线的词，比如_示例_和_测试_。", false], ["我的答案是：_1_，_2_，_3_。", true], ["这个回答只有_two_个带下划线的词。", false], ["在句子中使用下划线，例如 _这个_、_示例_ 以及 _单词_ 是正确的。", true]]}
{"instruction": "回答要求末尾加上版权声明，格式：“版权所有，未经许可不得转载。”。", "eval_func": [["def evaluate(response):\n    copyright_statement = \"版权所有，未经许可不得转载。\"\n    return response.endswith(copyright_statement)", 1.0], ["def evaluate(response):\n    copyright_notice = '版权所有，未经许可不得转载。'\n    return response.endswith(copyright_notice)", 1.0], ["def evaluate(response):\n    copyright_statement = '\\u7248\\u6743\\u6240\\u6709\\uff0c\\u672a\\u7ecf\\u8bb8\\u53ef\\u4e0d\\u5f97\\u8f6c\\u8f7d\\u3002'\n    return response.endswith(copyright_statement)", 1.0]], "cases": [["版权所有，未经许可不得转载。这是我的回答。", false], ["这是我的回答。版权所有，未经许可不得转载。", true]]}
{"instruction": "在回答的末尾添加一个带有日期和时间戳的行，格式为“回答生成时间：YYYY-MM-DD HH:MM”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the pattern for the timestamp at the end of the response\n    pattern = r'\\u56DE\\u7B54\\u751F\\u6210\\u65F6\\u95F4\\uFF1A\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern at the end of the response\n    match = re.search(pattern, response)\n    if match and match.end() == len(response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\n\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    if re.search(pattern, response):\n        return True\n    else:\n        return False", 0.8888888888888888], ["def evaluate(response):\n    import re\n    # Define the regex pattern to match the date-time stamp at the end of the response\n    pattern = r'\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern in the response\n    match = re.search(pattern, response)\n    # Check if there is a match and if it is placed at the end\n    if match and match.span()[1] == len(response):\n        return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    # Define the regular expression pattern to check for the timestamp\n    pattern = r'\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern at the end of the response\n    if re.search(pattern, response):\n        # Split the response into lines\n        lines = response.split('\\n')\n        # Check if the last line matches the pattern\n        if re.match(pattern, lines[-1]):\n            return True\n    return False", 0.8888888888888888]], "cases": [["这是一个回答的例子。回答生成时间：2023-03-30 12:45", true], ["这是一个回答示例。\n回答生成时间：2023-03-15 12:45", true], ["这是另一个回答样本，但没有时间戳。", false], ["这个答案没有包含正确的日期时间戳。回答生成时间：2022/03/30 12:45", false], ["这是不符合要求的回答，因为它没有时间戳。", false], ["这是一个回答示例。\n回答生成时间：2023-03-25 14:50", true], ["正确格式的答案末尾需要有一个时间戳。\n回答生成时间：2023/03/25 14:50", false], ["这是一个回答示例，但是它的时间戳不在末尾。\n回答生成时间：2023-03-15 12:45\n这是多余的文字。", false], ["答案和时间戳都正确，但是时间戳不是在最末尾。回答生成时间：2023-03-30 12:45 在这里还有文本。", false]]}
{"instruction": "若回答中出现专有名词或缩写，必须首次出现时在括号内标明全称，如“CPU（Central Processing Unit）”。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Regular expression pattern to find acronyms and their expansions\n    pattern = re.compile(r'([A-Za-z]+)\\s*\\(([^)]+)\\)')\n\n    # This dictionary will map acronyms to their full forms\n    acronym_dict = {}\n\n    # Find all matches of the pattern\n    matches = pattern.findall(response)\n    for acronym, full_form in matches:\n        acronym_dict[acronym] = full_form\n\n    # Split the response into words\n    words = response.split()\n\n    # Check for acronyms and their expansions\n    for word in words:\n        # Strip punctuation\n        clean_word = re.sub(r'\\W', '', word)\n        # If the word is an acronym\n        if clean_word in acronym_dict:\n            # Find the acronym's index\n            index = response.find(clean_word)\n            prev_text = response[:index]\n            # Check if the acronym has appeared before without its full form\n            if clean_word in prev_text and not acronym_dict[clean_word] in prev_text:\n                return False\n    return True", 1.0]], "cases": [["现代计算机通常包括CPU、RAM（Random Access Memory）和HDD（Hard Disk Drive）。", true], ["操作系统（OS，Operating System）是控制计算机硬件与软件资源的程序。", true], ["在CPU和GPU（Graphics Processing Unit）之间进行选择时，你需要考虑你的计算需求。", true], ["在讨论CPU时，我们应该指出CPU（Central Processing Unit）是计算机的核心。", true], ["在计算机中，CPU（Central Processing Unit）是负责解释计算机指令以及处理计算机软件中的数据。", true], ["我们需要一个有强大CPU（Central Processing Unit）的计算机。", true]]}
{"instruction": "回答中的每个段落前都要加上一个罗马数字序号，比如“I. XXXX； II. XXXX；”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the regular expression pattern for Roman numerals as paragraph prefixes\n    pattern = r'^(I{1,3}|IV|VI{0,3}|IX)\\.\\s+[^\\n]+(\\n(II{1,3}|IV|VI{0,3}|IX)\\.\\s+[^\\n]+)*$'\n    # Use regex to search for the pattern\n    matches = re.match(pattern, response)\n    # Check if the whole string matches the pattern\n    return bool(matches)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'(^(?:I\\. .*?(?:\\n|$))+)|(^(?:II\\. .*?(?:\\n|$))+)|(^(?:III\\. .*?(?:\\n|$))+)|(^(?:IV\\. .*?(?:\\n|$))+)|(^(?:V\\. .*?(?:\\n|$))+)|(^(?:VI\\. .*?(?:\\n|$))+)|(^(?:VII\\. .*?(?:\\n|$))+)|(^(?:VIII\\. .*?(?:\\n|$))+)|(^(?:IX\\. .*?(?:\\n|$))+)|(^(?:X\\. .*?(?:\\n|$))+)'\n    paragraphs = response.split('\\n')\n    roman_numerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X']\n    for index, paragraph in enumerate(paragraphs):\n        if not paragraph: continue\n        # Checking if enumeration exists, and corresponds to the expected order\n        expected_prefix = '{}. '.format(roman_numerals[index])\n        if not paragraph.startswith(expected_prefix):\n            return False\n    # Passed all checks\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Define a regular expression pattern to check for Roman numerals followed by a dot and space\n    pattern = r'(^I\\. |^II\\. |^III\\. |^IV\\. |^V\\. |^VI\\. |^VII\\. |^VIII\\. |^IX\\. |^X\\. )'\n    # Check if all paragraphs start with the pattern\n    paragraphs = response.split('； ')\n    for paragraph in paragraphs:\n        if not re.match(pattern, paragraph):\n            return False\n    return True", 1.0]], "cases": [["1. 这不遵循规则，因为没有使用罗马数字； II. 这是第二段。", false], ["I. 这是第一段； II. 这是第二段； III. 这是第三段。", true]]}
{"instruction": "回答中的每个例子之前加上“例子X：”，其中X是从1开始的连续数字。", "eval_func": [["def evaluate(response: str) -> bool:\n    # Split into potential examples based on the pattern\n    examples = response.split('例子')  # This is the character sequence for '例子'\n    consecutive_number = 1\n    for example in examples[1:]:  # skip the first split as it is before any '例子'\n        # Check if the string starts with the correct consecutive number followed by '：'\n        if not example.startswith(str(consecutive_number) + '：'):  # '：' is the full-width colon\n            return False\n        consecutive_number += 1\n    return True if consecutive_number > 1 else False", 0.8], ["def evaluate(response):\n    examples = response.split('\\u4F8B\\u5B50')  # Split on the Chinese characters for 'example'\n    if not examples[0].strip():  # The string before the first '例子' should be empty\n        examples = examples[1:]  # Ignore the empty string before the first '例子'\n\n    count = 1\n    for example in examples:\n        num_and_text = example.split('：')  # Split on the Chinese character for ':'\n        if len(num_and_text) != 2:  # Each example should be split into 2 parts\n            return False\n        num, text = num_and_text\n        if not num.strip().isdigit() or int(num.strip()) != count:  # Check if the number is a digit and in sequence\n            return False\n\n        if not text.strip():  # Each example should contain text after the number and ':'\n            return False\n\n        count += 1\n\n    return True", 0.8], ["def evaluate(response):\n    examples = response.split('\\u3000')  # Split by the full-width space character\n    counter = 1\n    for example in examples:\n        prefix = f'\\u4F8B\\u5B50{counter}\\uFF1A'  # '例子X：' where X is the counter\n        if not example.startswith(prefix):\n            return False\n        counter += 1\n    return True", 0.8]], "cases": [["例子1：吃的就是坏吃的、例子2：睡的就是腰舀的", true], ["这是没有加例子前缀的话。", false], ["例子1：有趣的一点、例子2：非常有含量、例子3：玩弄有新意", true], ["例子1：状态不错、快乐样子、例子2：曲折木术路", false], ["例子１：这是第一个例子。例子３：缺少了一个例子。", false]]}
{"instruction": "回答中的每一个列表项都需要使用圆点符号“• ”开始。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not line.startswith('• '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for item in items:\n        if not item.startswith('• '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by newline to get individual lines\n    lines = response.strip().split('\\n')\n    # Check if each line starts with the bullet point\n    for line in lines:\n        if not line.startswith('• '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for item in items:\n        if not item.startswith('• '):\n            return False\n    return True if items else False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.strip().startswith('• '):\n            return False\n    return True", 1.0]], "cases": [["• 第一项\n第二项开始没有圆点符号\n• 第三项", false], ["• Item 1\nItem 2\n• Item 3", false], ["• Item 1\n•Item 2\n• Item 3", false], ["• First item\n•Second item\n• Third item", false], ["• 第一项\n• 第二项\n• 第三项", true], ["Item 1\n• Item 2\n• Item 3", false], ["", false], ["• Item 1\n• Item 2\n• Item 3", true], ["第一项\n• 第二项\n• 第三项", false], ["First item\n• Second item\n• Third item", false], ["• First item\n• Second item\n• Third item", true], ["• 第一项\n• 第二项\n- 第三项", false]]}
{"instruction": "回答的结尾必须加上一句话“本回答已完毕。”。", "eval_func": [["def evaluate(response):\n    return response.endswith('\\u672c\\u56de\\u7b54\\u5df2\\u5b8c\\u6bd5\\u3002')", 1.0], ["def evaluate(response):\n    return response.strip().endswith('本回答已完毕。')", 1.0], ["def evaluate(response: str) -> bool:\n    # This is the required ending sentence according to the instruction\n    required_ending = '本回答已完毕。'\n    # Check if response ends with the required sentence\n    return response.endswith(required_ending)", 1.0], ["def evaluate(response):\n    return response.endswith('本回答已完毕。')", 1.0]], "cases": [["这是一个符合规定的回答。本回答已完毕。", true], ["看似遵守了，但实际上最后一句话并不符合。本回答已经完毕。", false], ["这个回答没有加上指定的结尾", false], ["本回答已完毕。但是我还有其他话要说。", false], ["本回答已完毕。但是这句话在开头。", false], ["这是一个回答的例子。本回答已完毕。", true], ["这是一个回答。本回答已完毕。", true], ["没有经过任何灰庄，那也成不上真正的勇士。本回答已完毕。", true], ["这是一个遵循指导的回答。本回答已完毕。", true], ["这个回答没有遵守指令", false], ["这个回答没有按照要求结束。", false], ["本回答已完毕。确实这样结束了。", false]]}
{"instruction": "回答中必须包含至少一个由大括号{}包裹的表达式，比如{表达式}。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find at least one occurrence of expression within {}\n    pattern = re.compile(r'{[^{}]*}')\n    # Search the pattern in the response\n    match = pattern.search(response)\n    # Return True if a match is found, else return False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'{[^{}]*}'\n    matches = re.findall(pattern, response)\n    return bool(matches)", 1.0], ["def evaluate(response):\n    import re\n    # Use regex to find expressions within {}\n    pattern = re.compile(r'{[^{}]*}')\n    # Search for the pattern in the response\n    match = pattern.search(response)\n    # Check if at least one expression is found\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # The pattern checks for at least one occurrence of {expression}\n    # where 'expression' is any sequence of characters except for {} itself\n    pattern = re.compile(r'{[^{}]*}')\n    # Search for the pattern in the response\n    match = pattern.search(response)\n    # Return True if a match is found, otherwise return False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\{.*?\\}'\n    return bool(re.search(pattern, response))", 1.0]], "cases": [["这是一个包含{特定表达式}的答案。", true], ["这个回答{包含一部分}符合要求。", true]]}
{"instruction": "回答中必须包含一个有顺序的列表，且使用英文字母进行编号，比如“A. XXXX； B. XXX；”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = '^((?:[A-Z]\\.\\s.*?；\\s*)+)$'\n    match = re.match(pattern, response)\n    if not match:\n        return False\n\n    items = match.group(0).split('；')\n    items = [item.strip() for item in items if item.strip() != '']\n\n    prev_ord = None\n    for item in items:\n        current_ord = ord(item[0])\n        if prev_ord is not None and current_ord != prev_ord + 1:\n            return False\n        prev_ord = current_ord\n\n    return True", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # Define the regex pattern for the sequence with English letters\n    pattern = re.compile(r'^(?:(?:(?:[A-Z]\\.[^;]+; )|(?:[A-Z]\\.[^;]+;)))+$')\n\n    # Match the pattern to the input string\n    if pattern.match(response.strip()):\n        return True\n    else:\n        return False", 0.8333333333333334], ["import re\n\ndef evaluate(response):\n    # Define a regex pattern for an ordered list with English letters and items\n    pattern = re.compile(r'^\\s*(?:[A-Z]\\.\\s*.+\\s*;\\s*)+$')\n    # Check if the response matches the pattern\n    match = pattern.match(response)\n    # Return True if a match is found, False otherwise\n    return bool(match)", 0.8333333333333334]], "cases": [["A. Apple pie; B. Banana bread; C. Carrot cake;", true], ["A. First Item； B. Second Item； C. Third Item；", true], ["1. This is incorrect; 2. It does not use letters;", false], ["1. First Item； 2. Second Item； 3. Third Item；", false], ["A. First Item B. Second Item C. Third Item", false], ["A. This is correct but there is no semicolon at the end", false]]}
{"instruction": "回答必须严格遵守问答格式，即每个问题后跟着答案，格式为“Q:问题？A:回答。”。", "eval_func": [["def evaluate(response):\n    import re\n    # Regex to match the strict QA format\n    pattern = r'(Q:.*?\\uFF1F\\s*A:.*?\\u3002)(Q:.*?\\uFF1F\\s*A:.*?\\u3002)*'\n    # Check if the whole response matches the format\n    return bool(re.fullmatch(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n\n    # Define the pattern for the Q&A format\n    pattern = r'(Q:.+?\\uff1fA:.+?\\u3002)'\n\n    # Split the response into segments based on the Q&A pattern\n    segments = re.findall(pattern, response)\n\n    # Join segments and compare with original response\n    return ''.join(segments) == response", 1.0]], "cases": [["Q:第二个问题？回答是这样。", false], ["Q:这是问题1？A:这是回答1。", true], ["Q:问题3？A:正确的回答例子。Q:问题4？A:又一个正确的答案。", true]]}
{"instruction": "回答中的每个部分后面都必须附上一组中括号，内中需要注明该部分的字数，例如“这是部分内容[X字]”。", "eval_func": [["def evaluate(response):\n    import re\n    parts = re.split(r\"\\[[0-9]+\\u5b57\\]\", response)\n\n    # Strip the trailing empty string if it exists due to a split at the end\n    if parts and parts[-1] == '':\n        parts.pop()\n\n    matches = re.finditer(r\"\\[([0-9]+)\\u5b57\\]\", response)\n    for part, match in zip(parts, matches):\n        # Calculate expected character count and the actual count\n        expected_count = int(match.group(1))\n        actual_count = len(part)\n        if expected_count != actual_count:\n            return False\n\n    # Check if there are any parts without the bracketed character count\n    if len(parts) != len(list(matches)):\n        return False\n\n    # Verify if response ends with a character count\n    if not response.endswith(match.group(0)):\n        return False\n\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    # Define the regular expression pattern to match segments and count\n    pattern = re.compile(r'([^\\[\\]]+)(\\[(\\d+)字\\])')\n\n    # Use finditer to find all occurrences of the pattern\n    matches = list(pattern.finditer(response))\n\n    # If there are no matches, the instruction is definitely not followed\n    if not matches:\n        return False\n\n    # Reconstruct the response from the segments to check if the instruction is strictly followed\n    reconstructed = ''\n    for match in matches:\n        segment, _, count = match.groups()\n        segment_length = len(segment)\n        if segment_length != int(count):\n            return False  # If the count does not match the segment length\n        # Append the segment and the corresponding bracketed count\n        reconstructed += segment + '[{}字]'.format(count)\n\n    # The response strictly follows the instruction if it exactly matches the reconstructed string\n    return response == reconstructed", 1.0], ["def evaluate(response):\n    import re\n    parts = re.split(r'\\[\\d+\\u5b57\\]', response)\n    if not parts[-1].strip():\n        parts.pop()\n    pattern = re.compile(r'(.+)\\[(\\d+)\\u5b57\\]')\n    for part in parts:\n        match = pattern.match(part)\n        if not match:\n            return False\n        text, count = match.groups()\n        if len(text) != int(count):\n            return False\n    return True", 1.0]], "cases": [["这里少了数字[]", false], ["数字和内容不符[5字]", false]]}
{"instruction": "回答需要包括具体的日期，日期格式为“YYYY年MM月DD日”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\d{4}年\\d{2}月\\d{2}日'\n    match = re.search(pattern, response)\n    if match:\n        return True\n    else:\n        return False", 1.0]], "cases": [["今天是2023年03月25日。", true], ["记得2023年12月01日那天的大雨。", true], ["日期为03/25/2023。", false]]}
{"instruction": "在回答的开头和结尾，分别加上 “<回答开始>” 和 “<回答结束>” 标记。", "eval_func": [["def evaluate(response):\n    return response.startswith('<回答开始>') and response.endswith('<回答结束>')", 1.0], ["def evaluate(response):\n    if not response.startswith('<回答开始>') or not response.endswith('<回答结束>'):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    start_tag = \"<回答开始>\"\n    end_tag = \"<回答结束>\"\n    if response.startswith(start_tag) and response.endswith(end_tag):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    if response.startswith('<回答开始>') and response.endswith('<回答结束>'):\n        return True\n    else:\n        return False", 1.0]], "cases": [["<回答开始>这是符合指示的回答。<回答结束>", true], ["这是不符合指示的回答。<回答结束>", false], ["<回答开始>这是不符合指示的回答。", false]]}
{"instruction": "回答每提及一个关键点，都要以“关键点：”作为前缀。", "eval_func": [["def evaluate(response):\n    key_points = response.split('\\u3002')  # splitting by the Chinese full stop 。\n    for point in key_points:\n        if point and not point.strip().startswith('\\u5173\\u952e\\u70b9\\uff1a'):  # checking if each point starts with 关键点： (关键点：)\n            return False\n    return True", 1.0], ["def evaluate(response):\n    keys = ['关键点：']\n    if not response:\n        return False\n    points = response.split('\\n')\n    return all(point.startswith(tuple(keys)) for point in points if point.strip())", 0.8333333333333334], ["def evaluate(response):\n    keypoint_prefix = '关键点：'\n    keypoints = response.split(keypoint_prefix)\n    # Remove the first empty split if it exists\n    if keypoints[0] == '':\n        keypoints.pop(0)\n    # Check if there's any non-empty split before the first keypoint\n    if len(keypoints) == 0 or response.startswith(keypoint_prefix):\n        # Verify that each keypoint is not empty after removing the prefix\n        for kp in keypoints:\n            if not kp.strip():\n                return False\n        return True\n    return False", 0.8333333333333334]], "cases": [["关键点：第一个关键点说明。关键点：第二个关键点提及。", true], ["这里说明了一些内容但没有使用正确的前缀。", false], ["关键点：关于这个问题的第一点。关键点：第二个重要的说明。关键点：总结的部分。", true], ["第一个点是这样的。关键点：第二点。关键点：第三点。", false], ["关键点：只有一个关键点，但是格式正确。", true], ["关键点：这是第一个点。这是第二个点。关键点：第三个点。", false]]}
{"instruction": "回答中提及的每个人物，都需用双星号进行加粗标注，例如**人物名称**。", "eval_func": [["def evaluate(response):\n    import re\n    # A regex pattern to capture the pattern **Person Name**\n    pattern = re.compile(r'\\*\\*(.*?)\\*\\*')\n    # Find all bold marked patterns in the response\n    bolded_names = pattern.findall(response)\n    # A regex pattern to match any Chinese characters potentially being person names\n    potential_names = re.compile(r'[一-鿿]+')\n    # Find all potential Chinese character sequences (not bolded)\n    chinese_names = potential_names.findall(response)\n    for name in bolded_names:\n        # Remove the found bold names from the Chinese names set\n        chinese_names = [n for n in chinese_names if n != name]\n    # If there are still Chinese names left, they were not bolded properly\n    return len(chinese_names) == 0", 1.0], ["def evaluate(response):\n    import re\n    # Use a regular expression to find bolded words\n    bolded_words = re.findall(r'\\*\\*(.*?)\\*\\*', response)\n    # If there are no bold words, return False\n    if len(bolded_words) == 0:\n        return False\n    # Use another regular expression to check for non-bolded names\n    # Assuming that names start with a capital letter and have no spaces,\n    # adjust pattern accordingly if that's not the case\n    non_bolded_names = re.findall(r'\\b[A-Z一-龥][a-z一-龥]*(?!\\*\\*)', response)\n    # Check if there are any non-bolded names\n    return len(non_bolded_names) == 0", 1.0], ["def evaluate(response):\n    import re\n\n    # Regex to find names that are not properly bolded (i.e., without surrounding double asterisks)\n    improperly_bolded = re.compile(r'(?<!\\*)\\*{0,1}([^*]+?)\\*{0,1}(?!\\*)')\n\n    # Split response by properly bolded names\n    pieces = re.split(r'\\*\\*(.*?)\\*\\*', response)\n\n    # Check alternating pieces for improperly bolded names\n    for i in range(0, len(pieces), 2):\n        if improperly_bolded.search(pieces[i]):\n            return False\n\n    return True", 1.0]], "cases": [["故事的主角是Harry Potter，他的朋友有**Ron Weasley**和Hermione Granger。", false]]}
{"instruction": "回答中提及的数字必须用中文数字表示，而不能用阿拉伯数字。", "eval_func": [["def evaluate(response):\n    import re\n    # Define a function to check if there are Arabic numerals in the response\n    def has_arabic_numerals(input_string):\n        return bool(re.search(r'\\d', input_string))\n    # Define a function to check if a text includes Chinese numerals\n    def has_chinese_numerals(input_string):\n        # List of Chinese numerals for 0 to 9\n        chinese_numerals = '零一二三四五六七八九'\n        return any(char in chinese_numerals for char in input_string)\n    # Check response for Arabic numerals, which are not allowed\n    if has_arabic_numerals(response):\n        return False\n\n    # While an absence of any numerals is fine, presence of Chinese numerals would mean\n    # the instruction is satisfied, so no explicit check for their presence is needed.\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Check if the response contains Arabic numerals\n    if re.search(r'\\d', response):\n        return False\n    # Define the list of Chinese numerals\n    chinese_numerals = '零一二三四五六七八九十百千万亿兆'\n    # Check if all the numerals in the response are Chinese\n    for char in re.findall(r'\\b\\d+\\b', response):\n        if not all(num in chinese_numerals for num in char):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n\n    # Define a pattern that matches Arabic numerals (0-9)\n    # If an Arabic numeral is found, it violates the instruction\n    arabic_numeral_pattern = re.compile(r'\\d')\n\n    # Search for Arabic numerals within the response\n    if arabic_numeral_pattern.search(response):\n        # There are Arabic numerals, so it violates the instruction\n        return False\n\n    # No Arabic numerals found, it follows the instruction\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to find Arabic numbers\n    arabic_numbers_pattern = r'\\d+'\n    # Check if there are any Arabic numbers in response\n    return re.search(arabic_numbers_pattern, response) is None", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to match any Arabic numerals\n    arabic_numerals = r'\\d+'\n    # Search for Arabic numerals in the response\n    if re.search(arabic_numerals, response):\n        return False\n    # It is assumed that all Chinese numerals in the response are correct\n    # as the function only checks for the presence of Arabic numerals\n    return True", 1.0]], "cases": [["八百八十八是一个幸运数字", true], ["这个问题的答案是三", true], ["结果为42", false]]}
{"instruction": "回答包括一份清单，每个项目下面需要标注“- 完成”或“- 未完成”。", "eval_func": [["def evaluate(response):\n    response_lines = response.split('\\n')\n    if not response_lines:\n        return False\n    for line in response_lines:\n        if not line.strip():\n            continue  # Skip empty lines\n        if not (line.endswith('- 完成') or line.endswith('- 未完成')):\n            return False\n    return True", 1.0], ["def evaluate(response: str) -> bool:\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not (line.endswith('- 完成') or line.endswith('- 未完成')):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    if not lines: # Should not be empty\n        return False\n    for line in lines:\n        if not line.endswith(' - 完成') and not line.endswith(' - 未完成'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if not response:\n        return False\n    items = response.split('\\n')\n    if len(items) < 2:\n        return False\n    for item in items:\n        if not item.endswith('- 完成') and not item.endswith('- 未完成'):\n            return False\n    return True", 1.0]], "cases": [["项目一 - 已完成\n项目二 - 完成\n项目三 - 未完成", false], ["项目一 - 完成\n项目二 - 未完成\n项目三 - 完成", true], ["清单项目一 - 完成\n清单项目二 - 未完成\n清单项目三 - 完成", true], ["清单项目一 - 完成\n清单项目二\n清单项目三 - 未完成", false], ["项目一 - 完成\n项目二\n项目三 - 完成", false]]}
{"instruction": "如果回答中提到某个数字，数字必须用括号包围，例如“(123)”。", "eval_func": [["def evaluate(response):\n    import re\n    # Check if there are numbers not enclosed in parentheses\n    pattern = r'([^()]\\d+[^()])|(^\\d+[^()])|([^()]\\d+$)'\n    if re.search(pattern, response):\n        return False\n\n    # Confirm that all numbers are enclosed correctly\n    enclosed_numbers = re.findall(r'\\((\\d+)\\)', response)\n    for num in enclosed_numbers:\n        if not num.isdigit():\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Compiles a regular expression to find numeric characters not enclosed in parentheses\n    non_enclosed_numbers = re.compile(r'(?<!\\()\\d+(?!\\))')\n    # Find all instances where a number isn't enclosed properly\n    non_enclosed = non_enclosed_numbers.findall(response)\n    # If there are any instances, the input does not follow the instructions\n    if non_enclosed:\n        return False\n    # To ensure that numbers are correctly enclosed, all numbers must be within parentheses\n    # The following regular expression matches numbers enclosed in parentheses\n    properly_enclosed_numbers = re.compile(r'\\(\\d+\\)')\n    # Finds all properly enclosed numbers\n    properly_enclosed = properly_enclosed_numbers.findall(response)\n    # Having other characters within parentheses containing number is not allowed\n    improperly_enclosed_characters = re.compile(r'\\([^\\d]+\\d+[^\\d]+\\)')\n    improperly_enclosed = improperly_enclosed_characters.findall(response)\n    # No improperly enclosed sequences should be found\n    return len(improperly_enclosed) == 0", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression pattern to match a properly bracketed number\n    pattern = r'\\([^\\d]*(\\d+)[^\\d]*\\)'\n    # Find all occurrences of pattern\n    matches = re.findall(pattern, response)\n    # Split the response to analyze parts between matches\n    split_response = re.split(pattern, response)\n    for part in split_response:\n        # Check if any digits are found outside the matches\n        if any(char.isdigit() for char in part):\n            return False\n    return True", 0.8]], "cases": [["没有使用数字时，它(应该)返回True。", true], ["这是一个合法的回答(42)，它正确地遵守了指示。", true], ["这个回答违反了规则因为123没有被括号包围。", false], ["这个例子(123是错误的。", false], ["(1234)是被正确包围的，但这个没有(5678是错的。", false]]}
{"instruction": "回答中的例子需要用缩进形式表示，采用markdown的引用格式，比如 “> 这是一个例子”。", "eval_func": [["def evaluate(response):\n    return all(line.startswith('> ') for line in response.strip().split('\\n'))", 1.0], ["def evaluate(response):\n    import re\n    # We will use regular expression to check for lines starting with '> '\n    pattern = re.compile(r'^\\*> .+$', re.MULTILINE)\n    # Split the response to check each line\n    lines = response.split('\\n')\n    for line in lines:\n        # Check if the line is empty or matches the markdown quote format\n        if line != '' and not pattern.match(line):\n            return False\n    return True", 0.8], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    if not response.strip():\n        return False\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0]], "cases": [["> 这是一个错误的例子\n这里没有缩进", false], ["> 这是一个例子\n> 这是另一个例子", true], ["这不是一个例子\n> 这是一个例子", false], ["> 这是一个例子\n这不是缩进格式", false], ["这是一个例子\n> 这是另一个例子", false]]}
{"instruction": "在回答中每次谈到新的观点时，都要在句前加上“新观点：”作为引导。", "eval_func": [["def evaluate(response):\n    # Split the response by periods to check individual sentences\n    sentences = response.split('。')\n    for sentence in sentences:\n        # Strip whitespace and newlines for more robust checking\n        sentence = sentence.strip()\n        # Check if the sentence contains '新观点：'\n        if sentence and not sentence.startswith('新观点：'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = response.split('新观点：')\n    if len(points) < 2:\n        return False\n    if points[0].strip() != '':\n        return False\n    for point in points[1:]:\n        if '\\n' in point.splitlines()[0]:\n            return False\n        if not point.strip() or '新观点：' in point:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if point:\n            if not point.startswith('新观点：'):\n                return False\n    return True", 1.0]], "cases": [["今天天气不错。新观点：我们应该去户外活动。", false], ["新观点：今天天气不错。\n新观点：我们应该去户外活动。\n新观点：晚餐吃火锅怎么样？", true], ["新观点：今天天气不错。新观点：我们应该去户外活动。", true]]}
{"instruction": "回答中的统计图或者表格需要用markdown的图片格式表示，即![](图片链接)。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = re.compile(r'!\\[.*?]\\(.*?\\)')\n    matches = pattern.findall(response)\n    if not matches:\n        return False\n    for match in matches:\n        if not re.match(r'!\\[.*?]\\(https?://.*?\\)', match):\n            return False\n    return True", 0.8333333333333334]], "cases": [["这是我的统计图![](http://example.com/myimage.png)，可以看到详细信息。", true], ["根据最新数据，我们这里有一幅统计图展示结果，如下所示：![](http://example.com/chart.png)。", true], ["统计结果可以在下面的表格中找到：统计图![](http://example.com/myimage.png)。", false], ["如图所示，通过我们的分析![](http://example.com/graph.png)，可以看出趋势。", true], ["尽管我们尝试了不同的方法，但是统计图![](不是一个链接)表现不佳。", false], ["请查看我添加的图片![](http://example.com/myimage.png)来获取数据的视觉表示。", true]]}
