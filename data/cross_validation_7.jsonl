{"instruction": "- 回答中每个段落前加\"***\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('***'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查每个段落是否以'***'开头\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('***'):\n            return False\n    return True", 1.0]], "cases": [["***这是第一段。\n***这是第二段。", true], ["这是一个段落。\n***这是另一个段落。", false], ["***这是第一段。\n这是第二段。\n***这是第三段。", false], ["***这是一个段落。\n***这是另一个段落。\n***这是第三个段落。", true], ["***这是第一段。\n***这是第二段。\n这是第三段。", false], ["这是第一段。\n***这是第二段。\n***这是第三段。", false], ["***这是一个段落。\n***这是另一个段落。", true], ["***这是一个段落。\n这是另一个段落。", false], ["***这是一个段落。\n\n***这是另一个段落。", true], ["***这是第一段。\n***这是第二段。\n***这是第三段。", true]]}
{"instruction": "- 回答中每个段落前加\"+++\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('+++'):\n            return False\n    return True", 1.0]], "cases": [["这是第一段。\n+++这是第二段。", false], ["+++这是第一段。\n+++这是第二段。\n+++这是第三段。\n", true], ["+++这是第一段。\n这是第二段。\n+++这是第三段。", false], ["+++这是第一段。\n这是第二段。", false], ["+++这是第一段。\n+++这是第二段。\n这是第三段。", false], ["+++这是第一段。\n+++这是第二段。\n+++这是第三段。", true], ["这是第一段。\n+++这是第二段。\n+++这是第三段。", false], ["+++这是第一段。\n\n+++这是第二段。", true], ["+++这是第一段。\n+++这是第二段。", true]]}
{"instruction": "- 回答中每个段落前加\"|||\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('|||'):\n            return False\n    return True", 1.0]], "cases": [["|||这是第一段。\n|||这是第二段。\n|||这是第三段。\n|||这是第四段。", true], ["这是第一段。\n|||这是第二段。\n|||这是第三段。", false], ["|||这是第一段。\n|||这是第二段。\n这是第三段。", false], ["|||这是第一段。\n|||这是第二段。\n|||这是第三段。", true], ["|||这是唯一一段。", true], ["这是第一段。\n|||这是第二段。", false], ["|||这是第一段。\n这是第二段。\n|||这是第三段。", false], ["|||这是第一段。\n|||这是第二段。", true], ["|||这是第一段。\n这是第二段。", false]]}
{"instruction": "- 回答中每个段落前加\"---\"。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if paragraph and not paragraph.startswith('---'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('---') and paragraph.strip() != '':\n            return False\n    return True", 1.0]], "cases": [["---这是第一段。\n这是第二段。\n---这是第三段。", false], ["---这是第一段。\n---这是第二段。\n---这是第三段。", true], ["---这是第一段。\n---这是第二段。\n这是第三段。", false], ["这是第一段。\n---这是第二段。\n---这是第三段。", false], ["---这是第一段。\n---这是第二段。\n---这是第三段。\n", true], ["---这是唯一一段。", true], ["---这是第一段。\n---这是第二段。\n---这是第三段。", true], ["---这是第一段。\n---这是第二段。\n---这是第三段。\n", true]]}
{"instruction": "- 回答中至少包含一个阿拉伯数字。", "eval_func": [["def evaluate(response):\n    for char in response:\n        if char.isdigit():\n            return True\n    return False", 1.0]], "cases": [["我有2个苹果", true], ["价格是100元", true], ["测试123", true], ["这是一个测试1", true], ["测试0", true], ["123", true], ["他今年30岁", true]]}
{"instruction": "- 回答中至少包含一个英文单词。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to check for at least one English word\n    pattern = re.compile(r'[a-zA-Z]+')\n    # Search for the pattern in the response\n    if pattern.search(response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to find at least one English word\n    pattern = re.compile(r'[a-zA-Z]+')\n    # Search for the pattern in the response\n    if pattern.search(response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    # 使用正则表达式检查是否包含至少一个英文单词\n    return bool(re.search(r'[a-zA-Z]+', response))", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配至少一个英文单词\n    pattern = re.compile(r'[a-zA-Z]+')\n    # 搜索匹配\n    if pattern.search(response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["包含一个单词hello。", true], ["混合内容：中文和English。", true], ["包含一个单词word。", true], ["包含一个word。", true], ["混合的语言text。", true], ["这是一个测试example。", true], ["测试123 with numbers and words", true], ["测试123 with numbers and words.", true], ["测试内容包含一个word。", true], ["混合内容with中文。", true], ["这是一个测试response with English.", true], ["数字和字母123abc", true], ["这是一个测试response。", true]]}
{"instruction": "- 回答字数不多于100个字。", "eval_func": [["def evaluate(response):\n    return len(response) <= 100", 1.0]], "cases": [["这是一个接近100个字的测试案例。我们需要确保这个测试案例的字数刚好在100个字以内。这样可以测试evaluate函数在边界条件下的表现。希望这个测试案例能够帮助我们验证函数的正确性。", true], ["这是一个测试案例，字数超过了100个字。为了确保这个测试案例确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确地识别出这个字符串的长度是否超过了100个字。再多加几个字。", false], ["这是一个长度刚好为100个字的字符串。为了确保这个字符串的长度确实是100个字，我们需要精确地计算每一个字的数量。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回True。", true], ["简短的测试。", true], ["这是一个长度超过100个字的字符串。为了确保这个字符串的长度确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回False。再多加几个字。", false], ["这是一个非常长的测试案例，字数超过了100个字。为了确保这个案例确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回False。", true], ["这是一个测试案例，字数不超过100个字。", true], ["短句。", true], ["这是一个非常长的测试案例，字数超过了100个字。为了确保这个测试案例确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回False。", true], ["这是另一个测试案例，字数刚好100个字。为了确保这个案例确实是100个字，我们需要精确地计算每一个字的数量。这样一来，我们就可以测试evaluate函数是否能够正确地识别出这个输入字符串符合指令。", true], ["这是一个非常长的测试案例，字数超过了100个字。为了确保这个测试案例确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确地识别出这个字符串不符合指令。", false], ["简短的测试。", true], ["这个测试案例的字数刚好是100个字。为了确保这一点，我们需要非常小心地计算每一个字。这样一来，我们就可以测试evaluate函数是否能够正确地识别出这个字符串符合指令。", true], ["短句。", true], ["这是一个测试案例，字数超过了100个字。为了确保这个案例确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回False。再多加一些字。", true], ["简短的回复。", true], ["这是一个非常长的测试案例，字数超过了100个字。为了确保这个测试案例确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确地识别出超过100个字的情况。", false], ["这是一个测试字符串，长度不超过100个字。", true], ["这是另一个测试案例，字数刚好100个字。为了确保这个案例确实是100个字，我们需要精确地计算每一个字的数量。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回True。", true], ["这个字符串的长度刚好是100个字。为了确保这一点，我们需要精确地计算每一个字符。这样一来，我们就可以测试evaluate函数是否能够正确识别并返回True。", true], ["这是一个非常长的测试案例，字数超过了100个字。为了确保这个测试案例确实超过了100个字，我们需要继续添加更多的内容。这样一来，我们就可以测试evaluate函数是否能够正确地识别出这个字符串的长度是否超过了100个字。", false], ["这是一个测试案例，字数不超过100个字。", true], ["这是一个超过100个字的测试案例。我们需要确保这个测试案例的字数超过了100个字。这样可以测试evaluate函数在处理超过100个字的情况时是否能够正确地返回False。希望这个测试案例能够帮助我们验证函数的正确性。", false]]}
{"instruction": "- 回答字数不多于200个字。", "eval_func": [["def evaluate(response):\n    return len(response) <= 200", 1.0]], "cases": [["这是一个非常长的测试案例，字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常强大的编程语言，适合各种不同类型的项目。", false], ["这个回复稍微长一点，但仍然在200个字以内。Python是一种非常流行的编程语言，适用于各种应用场景。无论是Web开发、数据分析还是人工智能，Python都能胜任。它的语法简洁明了，非常适合初学者学习。同时，Python拥有丰富的第三方库和框架，能够大大提高开发效率。", true], ["为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常优秀的编程语言。", false], ["这个回复将会超过200个字。为了确保这一点，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常强大的编程语言，适合各种不同类型的项目。", false], ["这是一个测试案例，字数不超过200个字。", true], ["这是一个非常长的测试案例，字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常优秀的编程语言。", false], ["简短的测试。", true], ["这是一个边界测试案例，字数刚好是200个字。为了确保这个测试案例确实是200个字，我们需要精确地计算每一个字的数量。这个测试案例的目的是为了验证evaluate函数是否能够正确识别刚好200个字的输入字符串。继续添加更多的内容，直到我们确信这个字符串的长度已经是200个字。现在我们应该已经达到了200个字了。", true], ["简短的回复。", true], ["这个回复稍微长一点，但仍然不超过200个字。Python是一种非常流行的编程语言，适用于各种应用场景。", true], ["这是一个非常长的测试案例，字数超过了200个字。为了确保这个测试案例确实超过了200个字，我们需要继续添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的逻辑。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常强大的编程语言，适合各种不同类型的开发任务。", false]]}
{"instruction": "- 回答字数不多于300个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 检查长度是否不超过300个字\n    if length <= 300:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个非常长的测试案例，字数超过了300个字。为了确保这个测试案例确实超过了300个字，我们需要添加更多的内容。这个测试案例将继续添加更多的句子，直到我们确信它已经超过了300个字。我们可以谈论各种各样的话题，比如编程、数据科学、机器学习、人工智能等等。我们还可以讨论Python编程语言的优点和缺点。Python是一种非常流行的编程语言，因其简洁和易读性而受到广泛欢迎。它在数据科学和机器学习领域尤其受欢迎。现在我们应该已经超过了300个字。", true], ["这是一个测试案例，长度不超过300个字。", true], ["这是一个非常长的测试字符串，用于检查函数是否正确评估输入字符串的长度。这个字符串的长度应该超过300个字，以确保函数能够正确地返回False。为了达到这个目的，我们需要继续添加更多的内容。这个过程可能需要一些时间，但这是必要的，因为我们需要确保我们的评估函数能够处理各种不同长度的输入字符串。继续添加更多的内容，直到我们确信字符串的长度已经超过了300个字。现在我们已经接近目标了，但还需要再添加一些内容。希望这次能够达到目标。现在我们应该已经超过了300个字。", true], ["这是一个中等长度的字符串，用于测试评估函数是否能够正确处理不同长度的输入。", true], ["这是另一个测试案例，长度刚好300个字。为了确保这个测试案例确实是300个字，我们需要添加更多的内容。Python是一种广泛使用的高级编程语言，最初由Guido van Rossum于1991年发布。Python的设计哲学强调代码的可读性和简洁的语法，使得程序员能够用更少的代码表达想法。Python支持多种编程范式，包括面向对象、过程化和函数式编程。它拥有一个庞大的标准库，涵盖了从网络编程到文本处理的各种功能。Python的广泛应用包括Web开发、数据分析、人工智能、科学计算等领域。由于其易学易用，Python成为了初学者和专业开发者的首选语言之一。", true], ["短文本。", true], ["这是另一个非常长的测试字符串，用于确保评估函数能够正确地识别超过300个字的输入。我们需要继续添加更多的内容，以确保字符串的长度足够长。这个过程可能需要一些时间，但这是必要的，因为我们需要确保我们的评估函数能够处理各种不同长度的输入字符串。继续添加更多的内容，直到我们确信字符串的长度已经超过了300个字。现在我们已经接近目标了，但还需要再添加一些内容。希望这次能够达到目标。现在我们应该已经超过了300个字。", true], ["这是一个边界测试案例，字数刚好是300个字。为了确保这个测试案例确实是300个字，我们需要精确地计算每一个字。这个测试案例将继续添加更多的句子，直到我们确信它已经达到300个字。我们可以谈论各种各样的话题，比如编程、数据科学、机器学习、人工智能等等。我们还可以讨论Python编程语言的优点和缺点。Python是一种非常流行的编程语言，因其简洁和易读性而受到广泛欢迎。它在数据科学和机器学习领域尤其受欢迎。现在我们应该已经达到300个字。", true], ["简短的测试。", true], ["这是一个非常长的测试字符串，用于检查是否遵循指令。这个字符串的长度应该超过300个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串将继续增长，直到它超过300个字。我们可以添加一些随机的句子来填充内容。例如：这是一个随机的句子。再例如：这是另一个随机的句子。继续添加内容，直到字符串足够长。现在，我们应该已经接近300个字了。再添加一些内容，以确保字符串超过300个字。现在，这个字符串应该已经超过300个字了。", true], ["这是一个测试字符串，用于检查是否遵循指令。这个字符串的长度应该小于300个字。", true], ["这是一个测试案例，字数不超过300个字。", true], ["这是一个测试字符串，用于检查函数是否正确评估输入字符串的长度。", true], ["这是一个接近300个字的字符串。为了确保它接近300个字，我们需要添加一些内容。这个字符串将继续增长，直到它接近300个字。我们可以添加一些随机的句子来填充内容。例如：这是一个随机的句子。再例如：这是另一个随机的句子。继续添加内容，直到字符串接近300个字。现在，我们应该已经接近300个字了。再添加一些内容，以确保字符串接近300个字。现在，这个字符串应该接近300个字了。", true], ["短字符串。", true], ["这是另一个测试案例，字数也不超过300个字。我们可以继续添加一些内容，但要确保总字数不超过300个字。Python是一种非常强大的编程语言，适用于各种应用场景。无论是数据分析、Web开发还是自动化脚本，Python都能胜任。这个测试案例的目的是确保我们的评估函数能够正确判断字数是否超过300个字。", true]]}
{"instruction": "- 回答字数不多于400个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 检查长度是否不超过400个字\n    if length <= 400:\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 检查长度是否超过400个字\n    if length <= 400:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个中等长度的字符串，用于测试函数是否能够正确评估输入字符串的长度是否不超过400个字。这个字符串的长度应该在合理范围内，不会超过400个字。", true], ["这是一个非常长的测试字符串，用于检查是否遵循指令。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串的长度应该超过400个字。为了确保字符串足够长，我们需要添加更多的内容。", true], ["这是一个非常长的测试字符串，用于检查函数是否能够正确评估输入字符串的长度是否不超过400个字。为了确保字符串足够长，我们需要添加更多的内容。这个字符串将继续增长，直到它超过400个字。我们可以添加一些随机的句子来填充这个字符串。比如说，今天的天气非常好，阳光明媚，适合出去散步。再比如说，Python是一种非常流行的编程语言，广泛用于数据科学、人工智能和Web开发。继续添加更多的内容，直到我们确定字符串已经超过了400个字。现在，我们可以再添加一些无意义的字符来确保字符串足够长。abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", true], ["短字符串", true], ["这是一个测试字符串，用于检查是否遵循指令。这个字符串的长度应该小于400个字。", true], ["这是一个测试字符串，用于检查函数是否能够正确评估输入字符串的长度是否不超过400个字。", true], ["这是一个非常长的测试案例，长度超过400个字。为了确保这个字符串确实超过了400个字，我们需要添加更多的内容。这个字符串将继续增长，直到我们确信它已经超过了400个字。为了达到这个目标，我们可以谈论各种话题，比如编程、数据科学、机器学习、人工智能等等。我们还可以讨论Python编程语言的优点和缺点。Python是一种非常流行的编程语言，因其简洁和易读性而受到广泛欢迎。它在数据科学和机器学习领域尤其受欢迎，因为有许多强大的库和框架，如NumPy、Pandas、Scikit-learn和TensorFlow。除了这些技术话题，我们还可以谈论一些日常生活中的事情，比如饮食、运动、娱乐等等。总之，这个字符串的长度已经超过了400个字。", true], ["这是一个接近400个字的字符串，用于测试函数是否能够正确评估输入字符串的长度是否不超过400个字。为了确保字符串接近400个字，我们需要添加更多的内容。这个字符串将继续增长，直到它接近400个字。我们可以添加一些随机的句子来填充这个字符串。比如说，今天的天气非常好，阳光明媚，适合出去散步。再比如说，Python是一种非常流行的编程语言，广泛用于数据科学、人工智能和Web开发。继续添加更多的内容，直到我们确定字符串已经接近了400个字。现在，我们可以再添加一些无意义的字符来确保字符串足够长。abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", true], ["这是一个测试案例，长度不超过400个字。", true]]}
{"instruction": "- 回答字数不多于50个字。", "eval_func": [["def evaluate(response):\n    return len(response) <= 50", 1.0]], "cases": [["这是一个测试案例，字数不超过五十个字。", true], ["这是一个测试案例，字数不超过五十个字。", true], ["这是一个测试字符串，长度刚好五十个字符。", true], ["这个回复的字数刚好是五十个字，不多也不少，应该是符合要求的。", true], ["这是一个非常长的测试字符串，长度远远超过五十个字符。这个字符串应该返回False。", true], ["这个回复的字数超过了五十个字，所以它不符合要求。", true], ["这是一个测试案例，字数超过五十个字。为了确保超过五十个字，我再多写一些内容。", true], ["短字符串。", true], ["简短的回复。", true], ["这是一个测试案例，字数超过五十个字。这个句子会让总字数超过五十个字。", true], ["这个回复的字数超过了五十个字，所以不符合要求。", true], ["五十个字符以内的字符串是可以接受的。", true], ["简短的回复。", true], ["这是一个测试字符串，长度超过五十个字符。这个字符串应该返回False。", true], ["这个回复的字数刚好是五十个字，不多也不少，应该是符合要求的。", true]]}
{"instruction": "- 回答字数不少于50个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于50个字\n    return length >= 50", 1.0], ["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于50个字\n    if length >= 50:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这个句子不足五十个字。", false], ["这是一个短的测试。", false], ["这个句子不够长。", false], ["短句。", false], ["短短的测试。", false], ["这是一个非常长的测试案例，长度远远超过了五十个字。我们需要确保这个字符串的长度足够长，以便通过评估函数的检查。", true], ["这是一个不合格的测试案例。", false]]}
{"instruction": "- 回答字数不少于100个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于100个字\n    if length >= 100:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个符合要求的测试案例。这个案例的内容长度超过了一百个字，因此它应该返回True。我们可以通过添加更多的文字来确保这一点。这样一来，我们就可以验证评估函数是否能够正确地判断输入字符串的长度。再多写一些文字以确保长度。", true], ["这是一个符合要求的测试案例。这个字符串的长度超过了一百个字，所以应该返回True。为了确保字符串的长度足够长，我们可以继续添加一些内容，比如说，Python是一种非常流行的编程语言，广泛应用于数据科学、人工智能、Web开发等领域。", true], ["这是一个符合要求的测试案例。这个字符串的长度超过了一百个字，所以应该返回True。为了确保字符串长度足够长，我们可以继续添加一些内容。比如说，Python是一种非常流行的编程语言，广泛应用于数据科学、人工智能、Web开发等领域。", true], ["这是一个符合要求的测试案例。这个字符串的长度超过了一百个字，所以应该返回True。为了确保字符串的长度足够长，我们可以继续添加一些内容。比如说，Python是一种非常流行的编程语言，广泛应用于数据科学、人工智能、Web开发等领域。", true]]}
{"instruction": "- 回答字数不少于200个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于200个字\n    if length >= 200:\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 检查长度是否不少于200个字\n    if length >= 200:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个符合指令的测试案例。为了确保这个字符串的长度不少于200个字，我们需要添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的功能。Python拥有丰富的标准库和第三方库，极大地扩展了其应用范围。总之，Python是一种非常强大的编程语言，适合各种不同的编程任务。", true], ["这是一个符合要求的测试案例。为了确保这个字符串的长度超过200个字，我们需要添加足够的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码实现更多的功能。Python拥有丰富的标准库和第三方库，极大地扩展了其应用范围。总之，Python是一种非常强大的编程语言，适合各种不同的应用场景。", true], ["这是一个符合指令的测试案例。为了确保这个字符串的长度不少于200个字，我们需要添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码实现更多的功能。Python的标准库非常丰富，提供了许多实用的模块和函数，极大地提高了开发效率。总之，Python是一种非常优秀的编程语言，适合各种类型的开发任务。", true], ["这是一个符合指令的测试案例。为了确保这个字符串的长度不少于200个字，我们需要添加足够的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能、科学计算等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的功能。Python拥有丰富的标准库和第三方库，极大地扩展了其功能。总之，这个字符串的长度已经超过了200个字，因此evaluate函数应该返回True。", true], ["这是一个符合要求的测试案例。为了确保这个字符串的长度超过200个字，我们需要添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码实现更多的功能。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。总之，Python是一种非常优秀的编程语言，适合各种类型的开发任务。", true], ["这是一个符合指令的测试案例。为了确保这个回复的字数不少于200个字，我们需要添加更多的内容。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码表达更多的功能。Python的标准库非常丰富，提供了许多实用的模块和函数，可以大大提高开发效率。此外，Python还有一个庞大的社区，提供了大量的第三方库和工具，进一步扩展了Python的功能。总之，Python是一种非常强大的编程语言，适合各种不同的应用场景。", true]]}
{"instruction": "- 回答字数不少于300个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于300个字\n    if length >= 300:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个符合指令的测试案例。为了确保这个回复的字数不少于三百个字，我们需要添加足够的内容。首先，我们可以介绍一下Python编程语言。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。它由Guido van Rossum于1989年发明，第一个公开发行版发布于1991年。Python的设计哲学强调代码的可读性和简洁的语法，使得程序员能够用更少的代码表达想法。Python支持多种编程范式，包括面向对象、过程化编程和函数式编程。Python拥有丰富的标准库和强大的第三方库，使得它在Web开发、数据分析、人工智能、科学计算等领域得到了广泛应用。Python的社区非常活跃，开发者们不断贡献新的库和工具，进一步扩展了Python的应用范围。总之，Python是一种功能强大且易于学习的编程语言，适合初学者和经验丰富的开发者。", true], ["这是一个符合指令的测试案例。为了确保这个回复的字数不少于三百个字，我们需要添加足够的内容。首先，我们可以介绍一下Python编程语言。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。它由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python的设计哲学强调代码的可读性和简洁的语法，使得程序员能够用更少的代码表达想法。Python支持多种编程范式，包括面向对象、过程化编程和函数式编程。Python拥有丰富的标准库和强大的第三方库，使得它在Web开发、数据分析、人工智能、科学计算等领域得到了广泛应用。总之，Python是一种功能强大且易于学习的编程语言，适合初学者和专业开发者使用。", true], ["这是一个符合指令的测试案例。为了确保这个回复的字数不少于三百个字，我们需要添加足够的内容。首先，我们可以介绍一下Python编程语言。Python是一种广泛使用的高级编程语言，具有简洁易读的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能、科学计算等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码实现更多的功能。其次，我们可以谈谈Python的社区和生态系统。Python拥有一个庞大而活跃的社区，开发者们不断贡献各种库和工具，使得Python的功能不断扩展。无论是数据处理、机器学习还是Web开发，Python都有相应的库和框架可以使用。最后，我们可以总结一下，Python是一种非常强大且易于学习的编程语言，适合各种不同的应用场景。通过这个测试案例，我们可以验证evaluate函数是否能够正确识别符合指令的回复，并返回True。", true], ["这是一个符合指令的测试案例。为了确保这段文字的长度不少于三百个字，我们需要添加足够的内容。首先，我们可以介绍一下Python编程语言。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。它由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python的设计哲学强调代码的可读性和简洁的语法，使得程序员能够用更少的代码表达想法。Python支持多种编程范式，包括面向对象、过程化编程和函数式编程。Python拥有丰富的标准库和强大的第三方库，使得它在Web开发、数据分析、人工智能、科学计算等领域得到了广泛应用。近年来，随着大数据和人工智能的兴起，Python的受欢迎程度不断上升，成为了许多开发者的首选编程语言。总的来说，Python是一种功能强大且易于学习的编程语言，适合初学者和专业开发者使用。通过这段文字，我们可以看到其长度已经超过了三百个字，因此evaluate函数应该返回True。", true], ["这是一个符合指令的测试案例。为了确保这个输入字符串的长度不少于三百个字，我们需要添加足够的内容。首先，我们可以介绍一下Python编程语言。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。它由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python的设计哲学强调代码的可读性和简洁的语法，使得程序员能够用更少的代码表达想法。Python支持多种编程范式，包括面向对象、过程化编程和函数式编程。Python拥有丰富的标准库和强大的第三方库，使得它在Web开发、数据分析、人工智能、科学计算等领域得到了广泛应用。总之，这个输入字符串的长度已经超过了三百个字，因此evaluate函数应该返回True。", true], ["这是一个测试案例，内容长度不足三百个字。这个案例的目的是为了测试evaluate函数是否能够正确识别不符合指令的回复。我们可以通过这个案例来验证函数的准确性和可靠性。", false], ["这是一个测试案例，内容长度超过三百个字。为了确保这个案例能够通过evaluate函数的评估，我们需要确保这段文字的长度确实超过了三百个字。为了达到这个目的，我们可以添加更多的内容。比如，我们可以描述一下Python编程语言的特点。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。它由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。Python的设计哲学强调代码的可读性和简洁的语法，使得程序员能够用更少的代码表达想法。Python支持多种编程范式，包括面向对象、过程化编程和函数式编程。Python拥有丰富的标准库和强大的第三方库，使得它在Web开发、数据分析、人工智能、科学计算等领域得到了广泛应用。总之，这段文字的长度已经超过了三百个字，因此evaluate函数应该返回True。", true]]}
{"instruction": "- 回答字数不少于400个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于400个字\n    if length >= 400:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个测试案例，内容长度不足400个字。这个案例的目的是为了测试evaluate函数是否能够正确识别不符合指令的情况。我们可以通过这个案例来验证函数的准确性和可靠性。", false]]}
{"instruction": "- 回答字数不少于500个字。", "eval_func": [["def evaluate(response):\n    # 计算输入字符串的长度\n    length = len(response)\n    # 判断长度是否不少于500个字\n    if length >= 500:\n        return True\n    else:\n        return False", 1.0]], "cases": [["这是一个符合指令的测试案例。为了确保这个输入字符串的长度不少于500个字，我们需要添加足够的内容。首先，我们可以介绍一下Python编程语言。Python是一种广泛使用的高级编程语言，具有简洁的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码实现更多的功能。接下来，我们可以讨论一下Python的历史。Python由Guido van Rossum于1980年代末期在荷兰的CWI研究所开发，并于1991年首次发布。Python的名字来源于英国喜剧团体“蒙提·派森”的作品《蒙提·派森的飞行马戏团》。Python的设计受到了ABC语言的启发，同时也借鉴了其他编程语言的优点。Python的第一个版本是1.0，随后不断发展，增加了许多新功能和库。2000年，Python 2.0发布，带来了许多重要的改进，如垃圾回收机制和Unicode支持。2008年，Python 3.0发布，这是一个不向后兼容的版本，目的是为了修正Python 2.x中的一些设计缺陷。虽然Python 3.x已经成为主流，但Python 2.x仍然在一些老旧系统中使用。最后，我们可以总结一下Python的优点。首先，Python的语法简洁明了，易于学习和使用。其次，Python拥有丰富的标准库和第三方库，能够满足各种应用需求。最后，Python具有跨平台特性，可以在Windows、macOS、Linux等操作系统上运行。总的来说，Python是一种功能强大且易于使用的编程语言，适合各种编程任务。通过这个测试案例，我们可以验证evaluate函数是否能够正确识别符合指令的情况，并返回True。", true], ["这是一个符合指令的测试案例。为了确保这个案例的内容长度不少于500个字，我们需要添加足够多的文字。首先，我们可以介绍一下Python编程语言。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。由荷兰人吉多·范罗苏姆于1989年发明，第一个公开发行版发行于1991年。Python语法简洁清晰，具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。Python的设计哲学是“优雅”、“明确”、“简单”。Python的创始人为吉多·范罗苏姆（Guido van Rossum），他在1989年圣诞节期间开始编写Python语言的解释器。Python的名字来源于英国喜剧团体“蒙提·派森”的电视节目《蒙提·派森的飞行马戏团》。Python的主要优点包括：1. 简单易学：Python的语法非常清晰，代码结构简单，容易上手。2. 强大的标准库：Python拥有丰富的标准库，涵盖了网络编程、文件操作、数据库访问、图形界面等各个方面。3. 跨平台：Python可以运行在Windows、Mac OS、Linux等多种操作系统上。4. 可扩展性：Python可以与C、C++等语言编写的模块进行集成，提供更高的性能。5. 开源社区：Python拥有一个庞大的开源社区，开发者可以从中获取大量的资源和支持。总之，Python是一种功能强大、易于学习和使用的编程语言，适合初学者和专业开发者使用。通过这个案例，我们可以看到内容长度已经超过了500个字，因此evaluate函数应该返回True。", true], ["这是一个符合指令的测试案例。为了确保这个案例的内容长度不少于500个字，我们需要添加足够的文字。首先，我们可以介绍一下Python编程语言。Python是一种广泛使用的高级编程语言，具有简洁易读的语法和强大的功能。它被广泛应用于Web开发、数据分析、人工智能、自动化脚本等领域。Python的设计哲学强调代码的可读性和简洁性，使得程序员能够用更少的代码实现更多的功能。Python拥有丰富的标准库和第三方库，极大地扩展了其应用范围。接下来，我们可以讨论一下Python的历史。Python由荷兰程序员Guido van Rossum于1980年代末期发明，并于1991年首次发布。Python的名字来源于英国喜剧团体Monty Python，因为Guido van Rossum是该团体的粉丝。Python的设计受到了ABC语言的启发，同时也借鉴了其他编程语言的优点。Python的第一个版本是1.0，随后不断发展和改进，逐渐成为今天的Python 3.x版本。Python的社区非常活跃，开发者们不断为其贡献代码和文档，使得Python生态系统日益壮大。总的来说，Python是一种功能强大且易于学习的编程语言，适合初学者和专业开发者使用。通过这个案例，我们可以看到evaluate函数能够正确识别出符合指令的情况。", true], ["这是一个符合指令的测试案例。为了确保这个输入字符串的长度不少于500个字，我们需要添加足够的内容。首先，我们可以介绍一下Python编程语言。Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。由荷兰人吉多·范罗苏姆于1989年发明，第一个公开发行版发行于1991年。Python语法简洁而清晰，具有丰富和强大的库。Python的设计哲学强调代码的可读性和简洁的语法，使得程序员能够用更少的代码表达想法。Python支持多种编程范式，包括面向对象、过程化编程和函数式编程。Python广泛应用于Web开发、数据分析、人工智能、科学计算、自动化运维等领域。Python的社区非常活跃，拥有大量的第三方库和框架，如Django、Flask、NumPy、Pandas、TensorFlow等。Python的跨平台特性使得它可以运行在几乎所有的操作系统上，包括Windows、Linux、macOS等。总的来说，Python是一种功能强大且易于学习的编程语言，适合初学者和专业开发者使用。通过这个案例，我们可以验证evaluate函数是否能够正确识别符合指令的输入字符串。如果函数返回True，那么说明函数能够正确识别出这个输入字符串符合指令的要求。", true]]}
{"instruction": "- 回答包含日期，格式为YYYY-MM-DD。", "eval_func": [["def evaluate(response):\n    import re\n    # 正则表达式匹配YYYY-MM-DD格式的日期\n    date_pattern = re.compile(r'\\b\\d{4}-\\d{2}-\\d{2}\\b')\n    # 查找所有匹配的日期\n    dates = date_pattern.findall(response)\n    # 如果找到至少一个匹配的日期，返回True，否则返回False\n    return bool(dates)", 1.0], ["import re\n\ndef evaluate(response):\n    # 定义日期格式的正则表达式\n    date_pattern = r'\\b\\d{4}-\\d{2}-\\d{2}\\b'\n    # 搜索是否存在符合格式的日期\n    match = re.search(date_pattern, response)\n    # 如果找到匹配的日期，返回True，否则返回False\n    return bool(match)", 1.0]], "cases": [["日期格式不正确：2023/10/09。", false], ["明天是2023年10月6日。", false], ["昨天是2023年10月4日。", false], ["请在2023/12/01之前提交报告。", false], ["请尽快回复。", false], ["日期格式应该是YYYY-MM-DD。", false], ["日期格式不正确：2023.10.05。", false], ["会议将在2023年10月7日举行。", false], ["日期格式不正确：2023/10/05。", false], ["没有日期信息。", false], ["请确认2023/12/01是否有空。", false], ["请在2023/10/07之前提交报告。", false], ["日期格式应为YYYY-MM-DD。", false]]}
{"instruction": "- 用英文回答，不使用其他语言。", "eval_func": [["def evaluate(response):\n    # Check if the response contains any non-ASCII characters\n    try:\n        response.encode('ascii')\n    except UnicodeEncodeError:\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Check if the response contains any non-English characters\n    for char in response:\n        if not (char.isascii() and char.isprintable()):\n            return False\n    return True", 1.0]], "cases": [["This is an English response.", true], ["This is a test response.", true], ["1234567890", true], ["Test with numbers 123.", true], ["Test with punctuation!?", true], ["Another valid English response.", true]]}
{"instruction": "- 回答时，每个句子的字符数递增。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    sentences = [s for s in sentences if s]\n    prev_length = 0\n    for sentence in sentences:\n        current_length = len(sentence)\n        if current_length <= prev_length:\n            return False\n        prev_length = current_length\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.split('。')\n    sentences = [s for s in sentences if s]\n    prev_len = 0\n    for sentence in sentences:\n        current_len = len(sentence)\n        if current_len <= prev_len:\n            return False\n        prev_len = current_len\n    return True", 1.0]], "cases": [["我。你好。", true], ["我。你好。你好吗。今天天气很好。今天天气非常好。", true], ["我。你好。你好吗。今天天气很好。", true], ["我。你好。你好吗。今天是个好日子。", true], ["我。你好。你好吗。", true], ["今天天气不错。我们去公园玩吧。公园里有很多花和树。", true], ["我。你好。今天天气不错。今天是个好日子。", true], ["今天天气不错。我们去公园玩吧。公园里有很多好玩的东西。", true], ["我。你好。你好吗。今天天气很好。今天是个好日子。", true], ["我。你好。今天是个好日子。", true]]}
{"instruction": "- 回答时，每个句子的字符数递减。", "eval_func": [["def evaluate(response):\n    sentences = response.split('。')\n    sentences = [s for s in sentences if s]\n    lengths = [len(s) for s in sentences]\n    for i in range(len(lengths) - 1):\n        if lengths[i] <= lengths[i + 1]:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sentences = response.split('。')\n    sentences = [s for s in sentences if s]\n    lengths = [len(s) for s in sentences]\n    return all(x > y for x, y in zip(lengths, lengths[1:]))", 1.0]], "cases": [["这是一个非常长的句子。稍微短一点的句子。短句。", true], ["这是一个更长的句子。短句。短。", true], ["你好。世。", true], ["这是一个测试。测试。试。", true], ["这是一段文字。段文字。文字。字。", true], ["这是一个测试。测试用例。例。", true], ["你好。世。", true], ["这是一个复杂的测试。复杂的测试。测试。", true], ["这是一个测试。测试。", true], ["这是一个测试。测试。试。", true], ["这是一个测试。试。", true], ["这是一个测试。测试。", true], ["这是一个测试。测试用例。例子。", true]]}
{"instruction": "- 用数字编号的方式回答，每个段落用逗号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    numbered_pattern = re.compile(r'^(\\d+\\.\\s).*')\n    # 检查是否每个段落用逗号隔开\n    comma_separated_pattern = re.compile(r'\\d+\\.\\s[^,]+(,\\s\\d+\\.\\s[^,]+)*$')\n    if not numbered_pattern.match(response):\n        return False\n    if not comma_separated_pattern.match(response):\n        return False\n    return True", 0.8571428571428571], ["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    if not re.match(r'^\\d+\\.\\s', response):\n        return False\n    # 检查每个段落是否用逗号隔开\n    paragraphs = response.split(',')\n    for paragraph in paragraphs:\n        if not re.match(r'^\\s*\\d+\\.\\s', paragraph.strip()):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    if not re.match(r'^\\d+\\.\\s', response):\n        return False\n    # 检查每个段落是否用逗号隔开\n    paragraphs = response.split(',')\n    for paragraph in paragraphs:\n        if not re.match(r'^\\d+\\.\\s', paragraph.strip()):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # 检查是否以数字编号开头\n    if not re.match(r'^\\d+\\.', response):\n        return False\n    # 检查每个段落是否用逗号隔开\n    paragraphs = response.split(',')\n    for paragraph in paragraphs:\n        if not re.match(r'^\\d+\\.', paragraph.strip()):\n            return False\n    return True", 1.0]], "cases": [["1. 这是第一段, 2. 这是第二段, 3. 这是第三段, 4. 这是第四段", true], ["1. 这是第一段, 2. 这是第二段, 3. 这是第三段", true], ["1. 这是第一段,2. 这是第二段,3. 这是第三段", true], ["1. 这是第一段, 这是第二段, 3. 这是第三段", false], ["这是第一段,2. 这是第二段,3. 这是第三段", false], ["1. 这是第一段, 2. 这是第二段, 这是第三段", false], ["1. 这是第一段,2. 这是第二段,这是第三段", false]]}
{"instruction": "- 用字母编号的方式回答，每个段落用分号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 检查是否以字母编号的方式回答\n    pattern = re.compile(r'^[a-zA-Z]\\. .+?(; [a-zA-Z]\\. .+?)*;$')\n    return bool(pattern.match(response))", 0.8888888888888888]], "cases": [["a. 这是第一段; b. 这是第二段; c. 这是第三段; d. 这是第四段", false], ["a. 这是第一段; b. 这是第二段; c. 这是第三段", false], ["1. 这是第一段; 2. 这是第二段; 3. 这是第三段;", false], ["a. 这是第一段; b. 这是第二段; c. 这是第三段; d. 这是第四段;", true], ["a. 这是第一段; b. 这是第二段;", true], ["a. 这是第一段; b. 这是第二段; c. 这是第三段", true], ["1. 这是第一段; 2. 这是第二段;", false], ["a. 这是第一段; b. 这是第二段", false], ["a. 这是第一段; b. 这是第二段; c. 这是第三段;", true]]}
{"instruction": "- 用大写字母编号的方式回答，每个项目用逗号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 正则表达式匹配模式\n    pattern = r'^[A-Z]+(,[A-Z]+)*$'\n    # 去除首尾空格\n    response = response.strip()\n    # 检查是否匹配模式\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 0.925]], "cases": [["A. 项目一, B. 项目二, C. 项目三", true], ["A,B,C,D,E,F,G", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四, E. 项目五", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T", true], ["A. 项目一, B. 项目二 C. 项目三", false], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P", true], ["A,B,C,D,E,F,G,H,I", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四 E. 项目五", false], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V", true], ["A. 项目一 B. 项目二, C. 项目三", false], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W", true], ["A,B,C,D,E,F,G,H,I,J", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四,", false], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M", true], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O", true], ["A. 项目一, B. 项目二, C. 项目三.", false], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,A,B", true], ["A,B,C", true], ["A,B,C,D,E", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,A,B,C", true], ["A,B,C,D,E,F", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y", true], ["A,B,C,D,E,F,G,H", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,A", true], ["A,B,C,D,E,F,G,H,I,J,K", true], ["A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U", true], ["A. 项目一，B. 项目二，C. 项目三", false], ["A. 项目一, B. 项目二, C. 项目三, D.项目四", false], ["A. 项目一, B. 项目二, C. 项目三, D 项目四", false], ["A,B,C,D", true], ["A. 项目一, B. 项目二, C. 项目三,", false], ["A. 项目一, B. 项目二, C. 项目三, D. 项目四, E. 项目五,", false], ["A,B,C,D,E,F,G,H,I,J,K,L", true]]}
{"instruction": "- 用罗马数字编号的方式回答，每个项目用分号隔开。", "eval_func": [["def evaluate(response):\n    import re\n    # 正则表达式匹配罗马数字编号的项目\n    pattern = r'^(I|II|III|IV|V|VI|VII|VIII|IX|X)(; (I|II|III|IV|V|VI|VII|VIII|IX|X))*$'\n    # 去除前后空格\n    response = response.strip()\n    # 检查是否匹配模式\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配罗马数字编号的项目\n    pattern = r'^(I|II|III|IV|V|VI|VII|VIII|IX|X)(; (I|II|III|IV|V|VI|VII|VIII|IX|X))*$'\n    # 去除前后空格\n    response = response.strip()\n    # 检查是否匹配模式\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    # 正则表达式匹配罗马数字编号的项目\n    pattern = r'^(I|II|III|IV|V|VI|VII|VIII|IX|X)(; (I|II|III|IV|V|VI|VII|VIII|IX|X))*$'\n    # 去除首尾空格\n    response = response.strip()\n    # 检查是否匹配模式\n    if re.match(pattern, response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["I; II; III; IV; V; VI; VII; VIII; IX; X; ", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;X;X", false], ["I; II; III; IV", true], ["I; II; III; IV; V; VI; VII", true], ["I; II; III; IV; V; VI; VII; VIII; IX; XI", false], ["I; II; III; IV; V", true], ["I; II; 3", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; 11", false], ["I; II; III; IV; V; VI; VII; VIII; IX", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X;", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;X;X;X;X", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII; XXIV; XXV; XXVI; XXVII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;X;X;X", false], ["I; II; III; IV; V; VI; VII; VIII", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI", false], [" I; II; III; IV; V; VI; VII; VIII; IX; X", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X ", true], ["I; II; III;", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;XI", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII; XXIV; XXV; XXVI; XXVII; XXVIII; XXIX; XXX", false], ["I; II; III; IV; V; VI", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X;X;X;X;X;X", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;X", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII; XXIV; XXV; XXVI; XXVII; XXVIII; XXIX", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI", false], ["I; II; III", true], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII; XXIV; XXV; XXVI", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII; XXIV", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII; XXIV; XXV", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII", false], ["I; II; III IV", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X; XI; XII; XIII; XIV; XV; XVI; XVII; XVIII; XIX; XX; XXI; XXII; XXIII; XXIV; XXV; XXVI; XXVII; XXVIII", false], ["I; II; III; IV; V; VI; VII; VIII; IX; X;X;X;X;X;X;X", false]]}
{"instruction": "- 回复中的每个句子都以相同的标点符号结尾。", "eval_func": [["def evaluate(response):\n    import re\n    # 使用正则表达式匹配所有句子结尾的标点符号\n    sentence_endings = re.findall(r'[。！？]', response)\n    # 如果没有找到任何句子结尾的标点符号，返回False\n    if not sentence_endings:\n        return False\n    # 检查所有句子结尾的标点符号是否相同\n    first_ending = sentence_endings[0]\n    for ending in sentence_endings:\n        if ending != first_ending:\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # 使用正则表达式匹配所有句子结尾的标点符号\n    sentence_endings = re.findall(r'[。！？]', response)\n    # 如果没有找到任何句子结尾的标点符号，返回False\n    if not sentence_endings:\n        return False\n    # 检查所有句子结尾的标点符号是否相同\n    return all(p == sentence_endings[0] for p in sentence_endings)", 1.0], ["def evaluate(response):\n    import re\n    # 使用正则表达式匹配所有句子\n    sentences = re.findall(r'[^。！？]*[。！？]', response)\n    if not sentences:\n        return False\n    # 获取第一个句子的结尾标点符号\n    first_punctuation = sentences[0][-1]\n    # 检查所有句子是否以相同的标点符号结尾\n    for sentence in sentences:\n        if sentence[-1] != first_punctuation:\n            return False\n    return True", 1.0]], "cases": [["这是一个测试句子。这个句子也以相同的标点符号结尾。", true], ["这是一个测试句子！这个句子也以感叹号结尾！所有句子都以感叹号结尾！", true], ["这是一个测试句子。", true], ["这是一个测试句子！这个句子也以感叹号结尾！", true], ["这是一个测试句子！这个句子也以相同的标点符号结尾！", true], ["这是一个测试句子。这是另一个测试句子。这是第三个测试句子。", true], ["这是一个测试句子。这个句子也以句号结尾。所有句子都以句号结尾。", true], ["这是一个测试句子！这个句子也以感叹号结尾！这个句子也是！", true], ["这是一个测试句子。这是另一个测试句子。", true], ["这是一个测试句子。这个句子也以相同的标点符号结尾。还有一个句子。", true], ["你好！你好！", true], ["这是一个测试句子。这个句子也以句号结尾。", true], ["这是一个测试句子。这个句子也以句号结尾。这个句子也是。", true]]}
{"instruction": "- 以JSON格式输出。", "eval_func": [["def evaluate(response):\n    import json\n    try:\n        json.loads(response)\n        return True\n    except ValueError:\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        import json\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则说明输入字符串不是有效的JSON\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        import json\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则说明不是有效的JSON格式\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        import json\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则返回False\n        return False", 1.0], ["def evaluate(response):\n    try:\n        # 尝试将输入字符串解析为JSON\n        json.loads(response)\n        return True\n    except ValueError:\n        # 如果解析失败，则说明不是有效的JSON格式\n        return False", 1.0]], "cases": [["{\"name\": \"张三\", \"age\": 30}", true], ["{\"list\": [1, 2, 3], \"dict\": {\"key\": \"value\"}}", true], ["{\"name\": \"张三\", \"age\": 25}", true], ["{\"name\": \"李四\", \"age\": \"二十五\"}", true], ["{\"list\": [1, 2, 3], \"dict\": {\"a\": 1}}", true], ["{\"list\": [1, 2, 3], \"boolean\": true}", true], ["{\"key\": \"value\"}", true], ["{\"键\": \"值\"}", true]]}
{"instruction": "- 以XML格式输出。", "eval_func": [["def evaluate(response):\n    import xml.etree.ElementTree as ET\n    try:\n        ET.fromstring(response)\n        return True\n    except ET.ParseError:\n        return False", 1.0]], "cases": [["<root><child>内容</child><child2>更多内容</child2></root>", true], ["这不是XML格式的内容", false], ["<root><child 属性='值'>内容</child></root>", true], ["<root><child>内容</child></root><extra>多余的内容</extra>", false], ["<root><child>内容</child></root>", true], ["<root><child 属性=\"值\">内容</child></root>", true], ["<root><child>内容</child>", false]]}
{"instruction": "- 以YAML格式输出。", "eval_func": [["import yaml\n\ndef evaluate(response: str) -> bool:\n    try:\n        yaml.safe_load(response)\n        return True\n    except yaml.YAMLError:\n        return False", 1.0]], "cases": [["name: 赵六\nage: 35\naddress: 深圳市", true], ["name: 李四\nage: 30\naddress: 上海市", true], ["name: 张三\nage: 30\naddress: 北京市\nhobbies: [篮球, 足球]\n", true], ["name: 张三\nage: 30\naddress: 北京市\nextra: {key: value, key2: value2}", true], ["name: 王五\nage: 28\naddress: 广州市\n- hobby: 篮球", false], ["name: 张三\nage: 30\naddress: 北京市\nhobbies: [篮球, 足球]", true], ["name: 张三\nage: 25\naddress: 北京市", true], ["name: 李四\nage: 25\naddress: 上海市\n", true], ["name: 张三\nage: 25\naddress: 北京市\n", true], ["name: 张三\nage: 30\naddress: 北京市\nhobbies: [篮球, 足球", false], ["name: 李四\nage: 30\naddress: 北京市\n", true], ["name: 张三\nage: 30\naddress: 北京市\nextra: {key: value}", true], ["name: 张三, age: 30, address: 北京市", false], ["name: 张三\nage: 25\n", true], ["name: 张三\nage: 30\naddress: 北京市\nhobbies:\n  - 篮球\n  - 足球", true], ["name: 赵六\nage: 35\naddress: 深圳市\n- item1\n- item2", false], ["name: 张三\nage: 30\naddress: 北京市\nextra: [item1, item2]", true], ["name: 张三\nage: 30\naddress: 北京市\n", true], ["name: 张三\nage: 30\naddress: 北京市", true], ["name: 王五\nage: 40\naddress: 广州市", true], ["name: 张三\nage: 三十\naddress: 北京市", true], ["name: 王五\nage: 28\naddress: 上海市\n", true], ["name: 王五\nage: 40\naddress: 广州市\nextra: value", true], ["name: 张三\nage: 30\naddress: 北京市\n- hobby: 篮球", false], ["name: 赵六\nage: 22\naddress: 深圳市\nhobbies:\n  - 读书\n  - 旅行", true], ["name: 李四\nage: 25\naddress: 上海市", true], ["name: 赵六\nage: 22\naddress: 广州市\n", true]]}
{"instruction": "- 以HTML表格格式输出。", "eval_func": [["def evaluate(response):\n    import re\n    # 定义一个简单的正则表达式来检查HTML表格的基本结构\n    pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 使用正则表达式匹配输入字符串\n    match = pattern.fullmatch(response.strip())\n    # 如果匹配成功，返回True，否则返回False\n    return bool(match)", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # 正则表达式匹配HTML表格的基本结构\n    pattern = re.compile(r'<table>.*?</table>', re.DOTALL)\n    # 检查response是否匹配HTML表格结构\n    match = pattern.fullmatch(response.strip())\n    return match is not None", 0.8333333333333334], ["def evaluate(response):\n    import re\n    # 正则表达式匹配HTML表格\n    pattern = re.compile(r'<table.*?>.*?</table>', re.DOTALL)\n    # 检查是否匹配\n    match = pattern.fullmatch(response.strip())\n    return match is not None", 0.8333333333333334]], "cases": [["<table><tr><td>内容</td></tr>", false], ["<div><tr><td>内容</td></tr></div>", false], [" <table><tr><td>内容</td></tr></table>", true], ["这是一个表格：<table><tr><td>内容</td></tr></table>", true], ["<table><tr><td>内容</td></tr></table><p>其他内容</p>", false], ["随机文本", false], ["<table><tr><td>内容</td></tr></table><p>其他内容</p>", true], ["  <table><tr><td>内容</td></tr></table>", true], ["<table><tr><td>内容</td></tr></table><br>", false], ["<table><tr><td>内容</td></tr></table><!-- 注释 -->", false], ["<table><tr><td>内容</td></tr></table>", true], ["<div>内容</div>", false], ["<table><tr><td>内容</td></tr></table><p>额外内容</p>", false], ["<div>这不是一个表格</div>", false], ["<table><tr><td>内容</td></tr></table>额外内容", false], ["<table><tr><td>内容</td></tr></table><table><tr><td>更多内容</td></tr></table>", false], ["前置内容<table><tr><td>内容</td></tr></table>", false], ["<table><tr><td>内容</td></tr></table>  ", true]]}
{"instruction": "- 以Markdown表格格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 0.8947368421052632], ["def evaluate(response):\n    # 检查是否以Markdown表格格式输出\n    lines = response.strip().split('\\n')\n    if len(lines) < 2:\n        return False\n    # 检查表头和分隔符行\n    header = lines[0]\n    separator = lines[1]\n    if not (header.startswith('|') and header.endswith('|')):\n        return False\n    if not (separator.startswith('|') and separator.endswith('|')):\n        return False\n    # 检查分隔符行是否由'-'和'|'组成\n    for char in separator:\n        if char not in '-| ':\n            return False\n    # 检查每一行是否以'|'分隔\n    for line in lines[2:]:\n        if not (line.startswith('|') and line.endswith('|')):\n            return False\n    return True", 0.8947368421052632]], "cases": [["列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", false], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2 |", false], ["列1 | 列2\n--- | ---\n数据1 | 数据2\n数据3 | 数据4", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2", false], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |\n", true], ["| 头1 | 头2 |\n| --- | --- |\n数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 数据4 |", false], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |", true], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 | 数据3 |", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |\n", true], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4 |", false], ["| 头1 | 头2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4", false], ["| 列1 | 列2 |\n| --- | --- |\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n| 数据3 | 数据4 |", true], ["列1 | 列2\n--- | ---\n数据1 | 数据2", false], ["| 列1 | 列2 |\n| --- | --- |\n| 数据1 | 数据2 |\n数据3 | 数据4", false]]}
{"instruction": "- 以纯文本格式输出。", "eval_func": [["def evaluate(response):\n    # 检查是否包含HTML标签\n    if '<' in response and '>' in response:\n        return False\n    # 检查是否包含Markdown格式\n    markdown_symbols = ['#', '*', '_', '~', '`', '[', ']', '(', ')', '>', '!', '|']\n    if any(symbol in response for symbol in markdown_symbols):\n        return False\n    # 检查是否包含其他非纯文本格式\n    non_text_symbols = ['{', '}', '[', ']', '\\\\', '^', '_', '`', '|', '~']\n    if any(symbol in response for symbol in non_text_symbols):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否包含HTML标签\n    if '<' in response and '>' in response:\n        return False\n    # 检查是否包含Markdown格式\n    markdown_indicators = ['#', '*', '_', '[', ']', '(', ')', '!', '`']\n    if any(indicator in response for indicator in markdown_indicators):\n        return False\n    # 检查是否包含其他非纯文本格式\n    non_text_indicators = ['{', '}', '[', ']', '\\\\', '|', '^', '~', '`']\n    if any(indicator in response for indicator in non_text_indicators):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否包含HTML标签\n    if '<' in response and '>' in response:\n        return False\n    # 检查是否包含Markdown格式\n    markdown_indicators = ['#', '*', '_', '[', ']', '(', ')', '!', '`']\n    if any(indicator in response for indicator in markdown_indicators):\n        return False\n    # 检查是否包含其他非纯文本格式\n    non_text_indicators = ['{', '}', '[', ']', ':', ';', '@', '&', '=', '+', '$', '%', '^', '!', '~', '|', '\\\\', '/', '?', '<', '>', '\"', \"'\"]\n    if any(indicator in response for indicator in non_text_indicators):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # 检查是否包含HTML标签\n    if '<' in response and '>' in response:\n        return False\n    # 检查是否包含Markdown格式\n    markdown_indicators = ['#', '*', '_', '[', ']', '(', ')', '`']\n    if any(indicator in response for indicator in markdown_indicators):\n        return False\n    # 检查是否包含其他非纯文本格式\n    non_plaintext_indicators = ['{', '}', '[', ']', '\\\\', '|', '^', '~']\n    if any(indicator in response for indicator in non_plaintext_indicators):\n        return False\n    return True", 1.0]], "cases": [["这是一个包含*Markdown*格式的回复。", false], ["这是一个包含{特殊字符}的回复。", false], ["这是一个包含{非纯文本}符号的回复。", false], ["这是一个包含特殊字符的回复：{特殊字符}", false], ["纯文本回复，没有任何格式。", true], ["纯文本，没有任何格式。", true], ["这是一个纯文本的回复，没有任何格式。", true], ["<html>这是一个包含HTML标签的回复。</html>", false], ["这是一个纯文本回复。", true], ["# 这是一个Markdown格式的回复", false], ["这是一个包含{非纯文本}格式的回复。", false], ["这是一个纯文本的回复。", true], ["这是一个包含[链接](http://example.com)的回复。", false], ["这是一个包含特殊字符的回复：@#￥%……&*。", false], ["这是一个包含反斜杠的回复：\\", false], ["这是一个*Markdown*格式的回复。", false], ["<html>这是一个HTML格式的回复。</html>", false]]}
{"instruction": "回复中的每个段落必须包含一个数字。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not any(char.isdigit() for char in paragraph):\n            return False\n    return True", 1.0]], "cases": [["段落1有数字6。\n段落2有数字7。\n段落3有数字8。\n段落4有数字9。", true], ["第一段有数字3。\n第二段也有数字4。\n第三段有数字5。", true], ["段落1有数字1。\n段落2有数字2。\n段落3有数字3。", true], ["这是第一段，包含数字1。\n这是第二段，包含数字2。", true], ["第一段有数字3。\n第二段有数字4。\n第三段有数字5。", true]]}
{"instruction": "回复中的每个段落必须包含一个日期。", "eval_func": [["def evaluate(response):\n    import re\n    paragraphs = response.split('\\n')\n    date_pattern = re.compile(r'\\d{4}年\\d{1,2}月\\d{1,2}日')\n    for paragraph in paragraphs:\n        if not date_pattern.search(paragraph):\n            return False\n    return True", 1.0]], "cases": [["今天是2023年10月5日，我们讨论了项目的进展。\n\n明天是2023年10月6日，我们将继续讨论。", false], ["2023年10月5日\n这是一个没有日期的段落。", false], ["2023年10月5日，我们讨论了项目的进展。\n2023年10月6日，我们将继续讨论。", true], ["2023年10月5日，今天是个好日子。\n2023年10月6日，明天也是个好日子。", true], ["今天是2023年10月5日，我们讨论了项目的进展。\n明天是2023年10月6日，我们将继续讨论。\n后天是2023年10月7日，我们将完成讨论。", true], ["今天是2023年10月5日。\n我们讨论了项目的进展。", false], ["2023年10月5日是一个重要的日子。\n2023年10月6日也是一个重要的日子。", true], ["这是一个没有日期的段落。\n这是另一个没有日期的段落。", false], ["今天是2023年10月5日，这是一个测试段落。\n明天是2023年10月6日，这是另一个测试段落。", true], ["2023年10月5日\n2023年10月6日\n2023年10月7日", true], ["今天是2023年10月5日，这是一个测试段落。\n这是另一个测试段落，没有日期。", false], ["今天是2023年10月5日，我们讨论了项目的进展。\n明天是2023年10月6日，我们将继续讨论。", true], ["今天是2023年10月5日，我们讨论了项目的进展。\n明天我们将继续讨论。", false]]}
{"instruction": "回复中的每个段落必须包含一个时间。", "eval_func": [["def evaluate(response):\n    import re\n    # 分割段落\n    paragraphs = response.split('\\n')\n    # 时间的正则表达式模式\n    time_pattern = re.compile(r'\\d{1,2}:\\d{2}')\n    # 检查每个段落是否包含时间\n    for paragraph in paragraphs:\n        if not time_pattern.search(paragraph):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    paragraphs = response.split('\\n')\n    time_pattern = re.compile(r'\\d{1,2}:\\d{2}')\n    for paragraph in paragraphs:\n        if not time_pattern.search(paragraph):\n            return False\n    return True", 1.0]], "cases": [["早上8:30，我去上班。\n中午，我和同事一起吃午饭。\n晚上18:45，我回到家。", false], ["早上8:30，我去公园散步。\n中午12:00，我吃午饭。\n晚上7:00，我在家看电视。", true], ["这是第一段，时间是10:30。\n这是第二段，时间是14:45。", true], ["第一段内容，时间是10:30。\n第二段内容没有时间。", false], ["第一段内容，时间是10:30。\n第二段内容，时间是14:45。", true], ["早上8:30，我去上班。\n中午12:00，我和同事一起吃午饭。\n晚上18:45，我回到家。\n夜里23:00，我准备睡觉。", true], ["今天早上8:30，我去上班。\n中午12:00，我和同事一起吃午饭。\n晚上，我回到家。", false], ["这是第一段，没有时间。\n这是第二段，时间是14:45。", false], ["第一段时间是09:00。\n第二段时间是18:30。\n第三段时间是23:59。", true], ["今天早上，我去公园散步。\n下午3:45，我去超市购物。", false], ["今天早上8:30，我去公园散步。\n下午3:45，我和朋友见面喝咖啡。", true], ["第一段内容没有时间。\n第二段内容，时间是14:45。", false], ["这是第一段，时间是10:30。\n这是第二段，时间是14:45。\n这是第三段，时间是16:00。", true], ["只有一段内容，时间是12:00。", true], ["第一段内容，时间是10:30。\n第二段内容，时间是14:45。\n第三段内容，时间是16:00。", true], ["今天早上8:30，我去上班。\n中午12:00，我和同事一起吃午饭。\n晚上18:45，我回到家。", true], ["早上8:30，我去公园散步。\n晚上7:00，我和朋友吃晚饭。", true], ["早上8:30，我去公园散步。\n晚上7:00，我在家看电视。", true], ["今天是个好日子。\n我们下午见面。", false], ["第一段时间是09:00。\n第二段没有时间。\n第三段时间是23:59。", false], ["今天早上，我去上班。\n中午12:00，我和同事一起吃午饭。\n晚上18:45，我回到家。", false], ["这是第一段，时间是10:30。\n这是第二段，没有时间。", false], ["这是唯一一段，时间是12:00。", true], ["这是第一段，时间是10:30。\n这是第二段，时间是14:45。\n这是第三段。", false], ["今天早上8:30，我去公园散步。\n下午3:45，我去超市购物。", true], ["这是第一段，时间是10:30。\n这是第二段，时间是14:45。\n这是第三段，时间是18:00。", true], ["今天早上，我去公园散步。\n下午3:45，我和朋友见面喝咖啡。", false], ["早上，我去公园散步。\n晚上7:00，我和朋友吃晚饭。", false], ["今天早上8:30，我去公园散步。\n下午，我去超市购物。", false], ["这是第一段，时间是10:30。\n这是第二段，时间是14:45。\n这是第三段，没有时间。", false]]}
{"instruction": "回复中的每个段落必须包含一个网址。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if 'http://' not in paragraph and 'https://' not in paragraph:\n            return False\n    return True", 1.0]], "cases": [["这是唯一一段，包含一个网址：http://example.com", true], ["这是唯一一段文字，包含一个网址：http://example.com", true], ["这是第一段内容，包含一个网址：http://example.com\n这是第二段内容，包含另一个网址：http://example.org\n这是第三段内容，包含第三个网址：https://example.net", true], ["这是第一段文字，没有网址。\n这是第二段文字，包含一个网址：http://example.com", false], ["这是第一段内容，包含一个网址：http://example.com\n这是第二段内容，也包含一个网址：https://example.org", true], ["这是唯一一段内容，包含一个网址：http://example.com", true], ["这是第一段内容，没有网址。\n这是第二段内容，也没有网址。", false], ["这是第一段，没有网址。\n这是第二段，包含一个网址：http://example.com", false], ["这是第一段，包含一个网址：http://example.com\n这是第二段，包含另一个网址：https://example.org\n这是第三段，包含第三个网址：http://example.net", true], ["这是第一段，包含一个网址：http://example.com\n这是第二段，包含另一个网址：https://example.org", true], ["这是第一段内容，没有网址。\n这是第二段内容，包含一个网址：http://example.com", false], ["这是第一段内容，包含一个网址：http://example.com\n这是第二段内容，没有网址。", false], ["这是第一段文字，包含一个网址：http://example.com\n这是第二段文字，没有网址。", false], ["这是第一段文字，包含一个网址：http://example.com\n这是第二段文字，包含另一个网址：https://example.org\n这是第三段文字，包含第三个网址：http://example.net", true], ["这是第一段文字，包含一个网址：http://example.com\n这是第二段文字，包含另一个网址：https://example.org", true], ["这是第一段内容，包含一个网址：http://example.com\n这是第二段内容，包含另一个网址：https://example.org\n这是第三段内容，包含第三个网址：http://example.net", true], ["这是第一段，包含一个网址：http://example.com\n这是第二段，包含另一个网址：https://example.org\n这是第三段，包含一个网址：http://example.net", true], ["这是第一段，包含一个网址：http://example.com\n这是第二段，没有网址。", false], ["这是第一段内容，包含一个网址：http://example.com\n这是第二段内容，包含另一个网址：https://example.org", true]]}
{"instruction": "回答需要包含至少三个用中文括号包裹的数字序列号，如（一）、（二）、（三）。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the regular expression pattern to match sequences of Chinese numerals in parentheses\n    pattern = re.compile('（[一二三四五六七八九十百千万]+）')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'（[一二三四五六七八九十百千万]+）')\n    matches = pattern.findall(response)\n    return len(matches) >= 3", 1.0], ["def evaluate(response):\n    import re\n    # 匹配至少三个用中文括号包裹的数字序列号\n    pattern = re.compile(r'（[一-龥]）')\n    matches = pattern.findall(response)\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0], ["import re\n\ndef evaluate(response):\n    # Define the pattern to match Chinese-bracketed sequences\n    pattern = re.compile(r'（[一二三四五六七八九十]+）')\n\n    # Find all matches in the response\n    matches = pattern.findall(response)\n\n    # Check if there are at least three matches\n    return len(matches) >= 3", 1.0]], "cases": [["仅有两个序列号（一）和（二），不够。", false], ["这里有四个数字序号（一）、（二）、（三）、（四），超出要求。", true], ["这是一个例子（一）、（二）和（三），它符合要求。", true]], "back_instruction": ["回答中必须包含至少三组用中文括号括起来的中文数字。", "回答中必须包含至少三组用中文括号括起来的中文数字。", "回答中必须包含至少三个用中文括号包裹的中文字符。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答回答中的URL必须用尖括号包裹，如<http://example.com>。", "eval_func": [["def evaluate(response):\n    import re\n    # This regular expression matches URLs enclosed in angle brackets\n    # The pattern will match a string that starts with <http:// or <https://\n    # followed by any characters (non-greedy), and then ends with >\n    pattern = re.compile(r'<https?://.*?>')\n    # Find all the matches in the input string\n    matches = pattern.findall(response)\n    # Removing all matches from the response to see if any URLs are left without brackets\n    for match in matches:\n        response = response.replace(match, '')\n    # Check if there are any URLs left in the response\n    # This pattern checks for URLs not enclosed in angle brackets\n    leftover_urls = re.compile(r'https?://')\n    if leftover_urls.search(response):\n        return False\n    return all(match.startswith('<http') and match.endswith('>') for match in matches)", 1.0]], "cases": [["全部正确的范例：<http://example.com>和<https://example.org>。", true], ["这个回答中的URL没有用尖括号包裹 http://example.com 应该返回False。", false], ["这是一个规范的回答<http://example.com>，完全符合要求。", true]], "back_instruction": ["答案中包含的URL必须用尖括号括起来。例如，应该是<http://example.com>这样的格式，而且保证文本中不包含未用尖括号括起来的URL。"], "nli_scores": ["entailment"]}
{"instruction": "回答必须包含至少一个用等号 = 表示的数学表达式。", "eval_func": [["def evaluate(response):\n    return '=' in response and any(char.isdigit() for char in response.split('=')[0]) and any(char.isdigit() for char in response.split('=')[1])", 1.0], ["def evaluate(response: str) -> bool:\n    return '=' in response and any(char.isdigit() for char in response.split('=')[0]) and any(char.isdigit() for char in response.split('=')[1])", 1.0]], "cases": [["这并不含等号的表达式。", false], ["这是一个数学表达式 5 = 5。", true], ["等号在这里=，但是两边没有数字。", false]], "back_instruction": ["在您的回答中至少包含一个等号'='，且等号两边各至少有一个数字。", "在您的答案中，请确保至少有一个等号'='，并且等号前后各至少有一个数字。"], "nli_scores": ["neutral", "entailment"]}
{"instruction": "回答的最后需要附上一个以“致谢：”开头的段落。", "eval_func": [["def evaluate(response):\n    if not response.endswith('\\n'):\n        response += '\\n'\n    sections = response.split('\\n')\n    for i in range(len(sections)-1, -1, -1):\n        if sections[i].strip():\n            return sections[i].startswith('致谢：')\n    return False", 1.0]], "cases": [["花了一个小时才找到这个终于得到了解决方案。\n致谢：感恩大家", true], ["您好，请您查看我的回复。\n致谢：", true], ["感谢您的回复，我已经修改了那个错误。致谢：这里没有换行", false]], "back_instruction": ["请以'致谢：'开头的方式，回答问题，并确保这是回答中的最后一部分内容。"], "nli_scores": ["entailment"]}
{"instruction": "回答中的每个段落开头必须使用四个空格进行缩进。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(paragraph.startswith('    ') for paragraph in paragraphs if paragraph.strip())", 1.0]], "cases": [["    这是正文第一段。\n这是正文第二段，但是没有进行缩进。", false], ["    这是正文第一段。\n    这是正文第二段，也遵循了规则。", true], ["这是正文第一段没有缩进。\n    这是正文第二段，但未全部遵循规则。", false]], "back_instruction": ["请确保您的回答中，每个段落都以四个空格开头。", "请确保您的回答中，只要段落包含非空白字符，它就应以四个空格开头。"], "nli_scores": ["entailment", "entailment"]}
{"instruction": "在回答的结尾列出“参考资料：”并用星号 * 表示列表项。", "eval_func": [["def evaluate(response):\n    if not response.endswith('参考资料：'):\n        return False\n\n    lines = response.split('\\n')\n    references_index = -1\n    for i, line in enumerate(lines):\n        if '参考资料：' in line:\n            references_index = i\n            break\n\n    if references_index == -1:\n        return False\n\n    for line in lines[references_index+1:]:\n        if not line.startswith('* '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if '参考资料：' in response and response.strip().endswith('参考资料：'):\n        lines = response.split('\\n')\n        if len(lines) > 1 and all(line.strip().startswith('*') for line in lines if '参考资料：' not in line):\n            return True\n        else:\n            return False\n    return False", 1.0], ["def evaluate(response):\n    # Check if the response ends with a reference list following the pattern\n    if response.endswith('\\n'):\n        response = response[:-1]\n    ref_section = response.split('\\n')[-1]\n    # Check if the reference section starts with the correct prefix\n    if not ref_section.startswith('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):\n        return False\n    # Check if each item in the reference list starts with an asterisk followed by a space\n    ref_items = ref_section[len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):].split('\\n')\n    for item in ref_items:\n        if not item.startswith('* '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    if not response.strip().endswith('参考资料：'):\n        return False\n    last_line_index = response.rfind('\\n')\n    if last_line_index == -1:\n        return False\n    reference_header = response[last_line_index + 1:].strip()\n    if reference_header != '参考资料：':\n        return False\n    list_items = response[:last_line_index].strip().split('\\n')\n    list_items = [item for item in list_items if item.strip() != '']\n    if not all(item.strip().startswith('*') for item in list_items):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Check if '参考资料：' exists at the end of the string before any lists\n    reference_index = response.rfind('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A')\n    if reference_index == -1 or reference_index + len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A') != len(response.strip()) - 1:\n        return False\n\n    # Verify if the lines after '参考资料：' are formatted as list items with asterisks\n    list_items = response[reference_index + len('\\u53C2\\u8003\\u8D44\\u6599\\uFF1A'):].strip().split('\\n')\n    for item in list_items:\n        if not item.startswith('* '):\n            return False\n    return True", 1.0]], "cases": [["正确的回答但没有参考资料。", false], ["这是另一个回答。\n参考资料：\n* 参考文献1\n错误格式的参考文献", false]], "back_instruction": ["在回答的末尾包含参考资料列表，并确保参考资料每一项都以'* '开头。", "在回答中如果包含参考资料，请确保在文本末尾，并且除了'参考资料：'本身外，每一行都以'*'开头。", "确保回答的最后部分是参考资料列表，并且每一条参考资料都以'* '开头。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答必须用圆括号包含所有出现的英文单词，例如（example）。", "eval_func": [["import re\n\ndef evaluate(response):\n    # Check if all English words are enclosed in parentheses\n    words = re.findall(r'[a-zA-Z]+', response)\n    for word in words:\n        if f'（{word}）' not in response:\n            return False\n    return True", 1.0]], "cases": [["这个函数都会（return）（True）如果所有的单词都被正确地（enclosed）。", true], ["每一个（English）（word）（is）（bracketed）。", true], ["如果这个句子有 words not in parentheses, 返回（False）。", false]], "back_instruction": ["请确保回答中所有英文单词都用圆括号括起来。"], "nli_scores": ["entailment"]}
{"instruction": "以箭头符号“→”开始每个回答的段落。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    return all(paragraph.startswith('→') for paragraph in paragraphs if paragraph.strip())", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('→'):\n            return False\n    return True if paragraphs else False", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('→'):\n            return False\n    return True", 1.0]], "cases": [["→ 这是遵循指示的一个段落。\n→ 这是另一个遵循指示的段落。", true], ["这个段落不以箭头开始。\n→ 但这个段落是。", false], ["→ 所有的段落都应该以箭头开始。", true]], "back_instruction": ["请用'→'作为每一段的开头。", "请以'→'作为开头，确保所有段落都遵守这个规则。", "请确保每一段都以'→'开头。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "回答中应包含至少两个用反引号\"`\"包裹的词语。", "eval_func": [["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i].strip():\n            count += 1\n    return count >= 2", 1.0], ["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i]:  # Check if the term is not just empty string\n            count += 1\n    return count >= 2", 1.0], ["def evaluate(response):\n    terms = response.split('`')\n    count = 0\n    for i in range(1, len(terms), 2):\n        if terms[i]:\n            count += 1\n        if count >= 2:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    count = 0\n    tokens = response.split('`')\n    for i in range(1, len(tokens), 2):\n        if tokens[i]:\n            count += 1\n    return count >= 2", 1.0]], "cases": [["在Python中，`list`和`dict`是常用的数据结构。", true], ["在Python中，list和dict是常用的数据结构。", false], ["正确的回答应该有两个术语, 像这样: `术语一`和`术语二`。", true], ["这个应答包含`术语一`但是只有一个。", false], ["使用`map()`函数可以对`iterables`进行操作。", true], ["这是一个包含`术语一`和`术语二`的合格回答。", true]], "back_instruction": ["请在回答中至少使用两个非空的由反引号 (`) 分隔的项。", "请确保您的回答中有至少两个由反引号 (`) 分隔开，且非空的项。", "请在您的回答中包含至少两个非空的项，这些项需要使用反引号 (`) 分隔。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答中的每个列表项都必须以一个顺序数字和点“1.”开头。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for idx, line in enumerate(lines, 1):\n        if not line.startswith(f'{idx}.'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    for i, line in enumerate(response_lines, 1):\n        prefix = '{}.'.format(i)\n        if not line.startswith(prefix):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # first, split the response into lines\n    items = response.strip().split('\\n')\n    # check if each item follows the pattern\n    for i, item in enumerate(items):\n        # trim leading and trailing whitespace\n        item = item.strip()\n        # generate expected prefix e.g., '1.', '2.', '3.', ...\n        expected_prefix = f'{i+1}.'\n        # check if the item starts with the expected prefix\n        if not item.startswith(expected_prefix):\n            return False\n    # if all items start with the correct prefix, return True\n    return True if items else False", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    items = response.strip().split('\\n')\n\n    # Define a variable to keep track of the expected starting number\n    number = 1\n\n    # Iterate over each line in the items\n    for item in items:\n        # Check if the line starts with the expected number and a dot\n        if not item.startswith(f'{number}.'):\n            return False\n\n        # Increment the number for the next expected item\n        number += 1\n\n    return True", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for index, item in enumerate(items, start=1):\n        if not item.startswith(f\"{index}.\"):\n            return False\n    return True", 1.0]], "cases": [["1.这是第一个列表项\n2.这是第二个列表项\n3.这是第三个列表项", true], ["1. 第一项\n2. 第二项\n4.跳过数字3", false], ["1. 第一项\n2. 第二项\n3. 第三项", true], ["第一个项目没有编号\n2.这是第二个项目，但第一个没有编号", false], ["1.第一个项目开始得对\n2.第二个项目也对\n4.但是这个项目的编号错了", false], ["0. 开始错误\n1. 第一项\n2. 第二项", false]], "back_instruction": ["请以数字和句号（例如'1.'）开始每一行，行号应该从1连续递增。", "请确保每一段文字都是以一个数字加句号开头的，比如'1.'，并且这些数字是从1开始连续的。", "请以连续的数字和句号作为开头（比如'1.'，接着是'2.'，等等），请输入每行文字，并确保每行的开头都符合这个格式。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答包含一组步骤，每个步骤用 markdown 的引用格式表示，每步用“>”开头。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    for line in lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    response_lines = response.strip().split('\\n')\n    if not response_lines:\n        return False\n    for line in response_lines:\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    steps = response.strip().split('\\n')\n    for step in steps:\n        # Check if each step starts with > and is not just the > character\n        if not step.startswith('> ') or step == '> ':\n            return False\n    return True if steps else False", 1.0]], "cases": [["> Step 1\n> Step 2\n> Step 3", true], ["> Step 1\n> Step 2\n\n> Step 3", false], ["Step 1\n> Step 2\n> Step 3", false]], "back_instruction": ["回答时，请确保每行都以'> '开始，不得不带有此前缀的行。", "回答时，请确保每行都以'> '作为开头，不得出现不带这个前缀的行，并且不得只包含空格或者为空。", "回答时，请确保每一行均以'> '作为行首，不得有行不带此前缀，且回答不得为空。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "必须在回答中至少使用 3 个不同颜色的文字，用 html 标签表示，例如 `<span style=\"color:red;\">红色文字</span>`。", "eval_func": [["def evaluate(response):\n    from html.parser import HTMLParser\n\n    class ColorCounterHTMLParser(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style' and 'color:' in attr[1]:\n                        color_value = attr[1].split(':')[1].strip().replace(';', '')\n                        self.colors.add(color_value)\n\n    parser = ColorCounterHTMLParser()\n    parser.feed(response)\n    return len(parser.colors) >= 3", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n    class ColorCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n\n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style':\n                        color_info = attr[1].split(':')\n                        if len(color_info) == 2 and color_info[0].strip() == 'color':\n                            self.colors.add(color_info[1].strip())\n\n    # Create an instance of the ColorCounter\n    parser = ColorCounter()\n    parser.feed(response)\n\n    # Check if there are at least 3 distinct colors\n    return len(parser.colors) >= 3", 1.0], ["def evaluate(response):\n    from html.parser import HTMLParser\n    \n    class ColorCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.colors = set()\n            \n        def handle_starttag(self, tag, attrs):\n            if tag == 'span':\n                for attr in attrs:\n                    if attr[0] == 'style' and 'color:' in attr[1]:\n                        color_value = attr[1].split('color:')[-1].split(';')[0].strip()\n                        self.colors.add(color_value)\n                        \n    parser = ColorCounter()\n    parser.feed(response)\n    return len(parser.colors) >= 3", 1.0]], "cases": [["<span style=\"color:red;\">红色文字</span>普通文字<span style=\"color:red;\">红色文字</span>", false], ["<p><span style=\"color:red;\">Red text</span> and a <span style=\"color:green;\">green one</span> without tags</p>", false], ["<p><span style=\"color:red;\">红色文字</span><span style=\"color:red;\">还是红色</span><span style=\"color:blue;\">蓝色文字</span></p>", false], ["<span style=\"color:red;\">红色文字</span><span style=\"color:green;\">绿色文字</span><span style=\"color:blue;\">蓝色文字</span>", true], ["只有普通文字没有颜色标签", false], ["<p><span style=\"color:red;\">红色文字</span><span style=\"color:green;\">绿色文字</span><span style=\"color:blue;\">蓝色文字</span></p>", true]], "back_instruction": ["提供含有至少三种颜色的 HTML span标签样式信息。", "提供含有至少三种颜色的 HTML span标签样式信息。", "提供含有至少三种颜色的 HTML span标签样式信息。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答必须以“回答内容如下：”作为正文开始的第一句话。", "eval_func": [["def evaluate(response):\n    return response.startswith(u'回答内容如下：')", 1.0], ["def evaluate(response):\n    prefix = '回答内容如下：'\n    return response.startswith(prefix)", 1.0], ["def evaluate(response):\n    return response.startswith('\\u56de\\u7b54\\u5185\\u5bb9\\u5982\\u4e0b\\uff1a')", 1.0]], "cases": [["回答内容如下：\n详细内容在这个部分。", true], ["我的回答是：回答内容如下：这里有一些消息。", false], ["回答内容如下：这是正确赋予的回答。", true]], "back_instruction": ["您的答案应该以'回答内容如下：'作为开头。", "您的答案应该以'回答内容如下：'作为开头。", "您的答案应该以'回答内容如下：'作为开头。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中必须包含 3 个以 markdown 删除线格式表示的单词或短语，例如“~~删除线文本~~”。", "eval_func": [["def evaluate(response):\n    # Check for markdown strikethroughs\n    strikethroughs = response.count('~~')\n\n    # Each strikethrough phrase has two '~~', so we expect strikethroughs to be 6\n    if strikethroughs != 6:\n        return False\n\n    # Splitting the response to find individual strikethrough phrases\n    parts = response.split('~~')\n\n    # Counting how many valid strikethrough phrases are there\n    count_strikethrough_phrases = sum(1 for i, part in enumerate(parts) if i % 2 == 1 and part.strip())\n\n    # Return True if exactly 3 strikethrough phrases are present\n    return count_strikethrough_phrases == 3", 1.0], ["def evaluate(response):\n    import re\n    \n    # Define a regex pattern to find markdown strikethrough text\n    pattern = r'~~(.*?)~~'\n    \n    # Find all strikethrough texts in the response\n    strikethrough_texts = re.findall(pattern, response)\n    \n    # Check if there are exactly 3 strikethrough texts\n    if len(strikethrough_texts) == 3:\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    # Import regex module\n    import re\n    \n    # Define pattern to find markdown strikethrough text\n    pattern = r'~~(.*?)~~'\n    \n    # Find all strikethrough occurrences\n    strikethrough_texts = re.findall(pattern, response)\n    \n    # Check if there are exactly three strikethrough phrases\n    return len(strikethrough_texts) == 3", 1.0], ["def evaluate(response):\n    import re\n    # Count the number of markdown strikethroughs using a regular expression\n    strikethroughs = re.findall(r'~~(.*?)~~', response)\n    # Check if there are exactly three strikethrough phrases\n    return len(strikethroughs) == 3", 1.0], ["def evaluate(response):\n    import re\n\n    # Regex pattern to find markdown strikethrough text (~~text~~)\n    pattern = r'~~[^~]+~~'\n\n    # Find all occurrences of markdown strikethrough in the response\n    strikethrough_matches = re.findall(pattern, response)\n\n    # Check if there are exactly three strikethrough phrases\n    return len(strikethrough_matches) == 3", 1.0]], "cases": [["这个回答有超过三个的删除线文本：~~一~~, ~~二~~, ~~三~~, ~~四~~。", false], ["此~~回答应包含~~三个删除线格式,但它只有两个~~例子~~。", false], ["这是一个包含~~删除线文本~~的回答, 这里还有一个~~第二个例子~~以及~~第三个例子~~。", true]], "back_instruction": ["使用三个带有删除线的短语回答，每个短语需使用'~~'标记且不应包含多余的空格或其他字符。", "使用正好三个被删除线标记的短语回答，每个短语之间用'~~'符号包围。", "回答中需包含恰好三段使用'~~'标记的删除线文本。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答责备必须每个句子结束后跟一个不同的特殊字符，如“†”、“‡”、“•”等。", "eval_func": [["def evaluate(response):\n    special_chars = set(['†', '‡', '•'])\n    sentences = response.split()\n    prev_char = ''\n    for sentence in sentences:\n        if len(sentence) < 2 or sentence[-1] not in special_chars:\n            return False\n        if sentence[-1] == prev_char:\n            return False\n        prev_char = sentence[-1]\n    return True", 1.0]], "cases": [["没有特殊符号结束。这是不符合要求。", false], ["这是一个句子。†另一个句子。‡最后的句子。•", true], ["符号不正确结束句子。*", false]], "back_instruction": ["回答中的每个单词应当使用特殊字符结束，这些特殊字符包括'†', '‡', '•'，并且相邻单词不能使用相同的结束字符。"], "nli_scores": ["entailment"]}
{"instruction": "回答中的日期必须按照“YYYY-MM-DD”的格式书写。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\b(\\d{4})-(\\d{2})-(\\d{2})\\b'\n    match = re.search(pattern, response)\n\n    if match:\n        year, month, day = match.groups()\n        if int(year) > 0 and 1 <= int(month) <= 12 and 1 <= int(day) <= 31:\n            return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = '^\\d{4}-\\d{2}-\\d{2}$'\n    return bool(re.match(pattern, response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile('^(\\d{4}-\\d{2}-\\d{2})$')\n    return bool(pattern.match(response))", 1.0], ["def evaluate(response):\n    import re\n    pattern = re.compile(r'^\\d{4}-\\d{2}-\\d{2}$')\n    if pattern.match(response):\n        return True\n    else:\n        return False", 1.0]], "cases": [["March 25, 2023", false], ["2023/03/25", false], ["2023-03-25", true]], "back_instruction": ["回答中包含一个符合格式的日期（格式为YYYY-MM-DD，年份必须大于0，月份在1到12之间，日期在1到31之间）。", "回答必须严格符合日期格式YYYY-MM-DD，不能包含其他字符。", "回答必须严格是一个符合格式的日期（YYYY-MM-DD）。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "每个要点需用圆括号括起来并加粗，如**(要点)**。", "eval_func": [["def evaluate(response: str) -> bool:\n    import re\n    # Regular expression to match bold parentheses pattern\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Split the response by the bold parentheses, if the split result doesn't\n    # have empty strings (or only contains the bold parentheses patterns),\n    # then the response didn't strictly follow the instruction.\n    split_response = pattern.split(response)\n    if any(not pattern.match(part) and len(part.strip()) > 0 for part in split_response):\n        return False\n    # Check if all the bold patterns are strictly (要点)\n    for match in pattern.findall(response):\n        if match != '**(要点)**':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern to find all instances that match the instruction\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Replace the matches to see if any text remains unformatted\n    unformatted_parts = pattern.sub('', response).strip()\n    # The response follows the instruction if all text is wrapped as specified and nothing remains unformatted\n    return all('(' in match and ')' in match for match in matches) and not unformatted_parts", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to check the instruction\n    pattern = r'\\*\\*\\([^\\)]+\\)\\*\\*'\n    items = re.findall(pattern, response)\n\n    # Split the string by the found items\n    split_parts = re.split(pattern, response)\n\n    # Check if all parts that are split out do not contain any unformatted key point\n    # This assumes that key points are all in Chinese characters, though it may match other characters in a similar range.\n    all_parts_valid = all(not re.search(r'[\\u4e00-\\u9fff]+', part) for part in split_parts)\n\n    # True if all the found items are strictly following the instructions and all other parts are valid\n    return bool(items) and all_parts_valid", 1.0], ["def evaluate(response):\n    import re\n    # Regex pattern to match the instruction\n    pattern = re.compile(r'\\*\\*\\(.*?\\)\\*\\*')\n    # Find all occurrences that match the pattern\n    matches = pattern.findall(response)\n    # Extract text between '**(' and ')**'\n    contents = [m[3:-3] for m in matches]\n    # Check for any non-matching parts of the response\n    split_response = pattern.split(response)\n    for part in split_response:\n        if part.strip():  # Checks if there is any text outside the bold parenthesis\n            return False\n    # Check if all required parts are within the bold parenthesis\n    return all('**(' in response and ')**' in response for point in contents)", 1.0]], "cases": [["**(要点)** 及另一点", false], ["**(要点)** 和 **( )**", false]], "back_instruction": ["在答案中只使用用双星号加括号强调的要点。举例来说，您的回答应该只包含这样的内容：**（要点）**。", "在答案中全部使用双星号加括号的方式来强调您的要点。举例：回答里的文字都应该被这样格式化**（要点）**，而且之外不能有其他未按此方式格式化的文本。", "确保您的回答中，所有的要点都使用了双星号加括号的格式来强调，比如**（要点）**。此外，文本中不包含任何未经格式化的要点。"], "nli_scores": ["entailment", "neutral", "neutral"]}
{"instruction": "回答必须在结尾包含签名“敬上”，最后一行。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    return lines[-1].strip() == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    return lines[-1] == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    last_line = lines[-1].strip()\n    return last_line == '敬上'", 1.0], ["def evaluate(response):\n    lines = response.strip().split('\\n')\n    if not lines:\n        return False\n    return lines[-1].strip() == '敬上'", 1.0]], "cases": [["这里是我的回答。\n敬上", true], ["这是另一个回答但不符合要求。", false], ["敬上\n本来应该在最后一行，但规则未被遵循。", false]], "back_instruction": ["请确保您的回答以'敬上'结尾，且'敬上'前没有多余的空格。", "请确保您的回答以'敬上'结尾。", "请在回答中包括至少一行内容，并确保最后一行是'敬上'，且'敬上'前没有多余的空格。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中需要包含至少2个内链，格式为[链接文字](URL)。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find markdown links\n    pattern = re.compile(r'\\[[^\\]]+\\]\\([^)]+\\)')\n    # Find all matches in the response\n    matches = pattern.findall(response)\n    # Check if there are at least two links\n    return len(matches) >= 2", 1.0], ["def evaluate(response):\n    import re\n    # Define a regex pattern to find markdown links\n    pattern = r'\\[([^\\]]+)\\]\\((https?:\\/\\/[a-zA-Z0-9./]+)\\)'\n    # Use re.findall to get all the links in a list\n    links = re.findall(pattern, response)\n    # Check if there are at least 2 links\n    return len(links) >= 2", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\[([^\\]]+)\\]\\((https?://[^\\)]+)\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 2", 1.0], ["import re\n\ndef evaluate(response):\n    pattern = r'\\[.*?\\]\\(http?s://.*?\\)'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 2", 1.0]], "cases": [["只有一个内链[链接文字](https://example.com)是不足够的", false], ["这是第一个内链[链接文字](https://example.com)和第二个内链[另一个链接](https://example.org)", true], ["多个内链但不符合格式如此: 链接文字(https://example.com), [链接文字]https://example.com", false]], "back_instruction": ["在答案中至少包含两个Markdown格式的链接。", "在答案中至少包含两个Markdown格式的链接。", "在答案中至少包含两个Markdown格式的链接。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答的每个要点前必须使用单破折号，如“- 要点内容”。", "eval_func": [["def evaluate(response):\n    points = response.strip().split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True if points else False", 1.0], ["def evaluate(response):\n    points = response.split('\\n')\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    points = [point.strip() for point in response.split('\\n') if point]\n    for point in points:\n        if not point.startswith('- '):\n            return False\n    return True", 0.8333333333333334]], "cases": [["- 要点一\n- 要点二\n-要点三", false], ["-要点一\n- 要点二\n - 要点三", false], ["第一个要点\n- 第二个要点\n- 第三个要点", false], ["- 要点一\n- 要点二\n- 要点三", true], ["- 第一个要点\n - 第二个要点\n- 第三个要点", false], ["- 第一个要点\n- 第二个要点\n- 第三个要点", true]], "back_instruction": ["回答时请使用项目列表格式，每个观点用短横线“-”开头。", "请使用项目列表格式回答，如果没有内容则视为错误。", "请确保你的回答是项目列表格式，每个项目都要以短横线“-”开头。"], "nli_scores": ["neutral", "neutral", "neutral"]}
{"instruction": "回答中的每段开头需要使用四个空格缩进。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    return all(line.startswith('    ') or line == '' for line in lines)", 1.0], ["def evaluate(response):\n    # Split the response by newlines to handle each paragraph\n    paragraphs = response.split('\\n')\n    # Check if each paragraph begins with four spaces\n    for paragraph in paragraphs:\n        if not paragraph.startswith('    '): # Checks for four spaces\n            return False\n    return True", 1.0]], "cases": [["This is not correctly indented.\n    This one is correct.", false], ["    Only the first line is correct.\nNot this one.", false], ["    This is a correctly indented paragraph.\n    This one is correct as well.", true]], "back_instruction": ["回答时，请确保每一段的开头都是四个空格。", "回答时，请确保每一行要么以四个空格开头，要么为空行。", "回答时，请确保每一段的开头都是四个空格。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "回答的每个主要部分下面都必须有一个以半角分号结尾的小结，如“这是小结；”。", "eval_func": [["def evaluate(response):\n    # split the response into major parts using a full-stop followed by a newline character\n    parts = response.split('\\n')\n    # check that each major part has a semicolon-terminated summary\n    for part in parts:\n        if not part.strip().endswith(';'):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    sections = response.split('\\n')\n    for section in sections:\n        parts = section.split('；')\n        if len(parts) < 2 or parts[-1].strip() != '':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into sections\n    sections = response.split('、') # U+3001 is the codepoint for the Chinese comma used to separate sections\n    for section in sections:\n        # Check if the section ends with a semicolon\n        if not section.strip().endswith(';'):\n            return False\n\n    # If all sections have a semicolon at the end, the instruction is followed\n    return True", 1.0], ["def evaluate(response):\n    sections = response.split('、')\n    if not sections or '' in sections:\n        return False\n    return all(section.strip().endswith(';') for section in sections)", 1.0]], "cases": [["这是第一部分的内容。\n这是小结；\n这是第二部分的内容\n这是小结；", false], ["这是第一部分的内容。\n这是小结。\n这是第二部分的内容。\n这是小结；", false]], "back_instruction": ["请以句号加换行符分隔回答的各个主要部分，并确保每个部分的末尾都有分号终结。", "请用中文顿号分隔您的回答，每个部分后应没有多余的内容。", "请用中文顿号分隔您的回答的各个部分，并确保每个部分的末尾都有分号终结。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中不得包含任何形式的加粗格式。", "eval_func": [["def evaluate(response):\n    if '**' in response or '__' in response:\n        return False\n    return True", 1.0], ["def evaluate(response):\n    return '**' not in response and '__' not in response", 1.0]], "cases": [["这是一个没有加粗文字的回答", true], ["这是一个有__加粗__格式的例子", false], ["这是一个有**加粗**文字的回答", false]], "back_instruction": ["在回答中不要使用包含两个连续星号或两个连续下划线的词语。", "确保你的回答中没有含有连续两个星号或连续两个下划线的词语。"], "nli_scores": ["neutral", "neutral"]}
{"instruction": "回答必须以问句结束，且用斜体书写，例如“*这是否解决了您的问题？*”。", "eval_func": [["def evaluate(response):\n    if not response.endswith('？*'):\n        return False\n    if not response.startswith('*'):\n        return False\n    if not ('*' in response[1:-2]) and not response[-3].isdigit():\n        return True\n    return False", 1.0]], "cases": [["*这真的能够帮到您吗？*", true], ["这是否解决了您的问题？", false], ["*这是否解决了您的问题？*", true]], "back_instruction": ["回答必須以星號開頭和以'？*'結尾，且在開頭的星號與結尾的'？*'之間不含有星號並且倒數第三個字符不是數字。"], "nli_scores": ["entailment"]}
{"instruction": "每段回答中必须包含并突出显示一个主要名词，使用 markdown 加粗语法，例如“**主要名词**”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define a regular expression pattern for markdown bold syntax\n    pattern = re.compile(r'\\*\\*(.*?)\\*\\*')\n    # Find all occurrences of the markdown bold syntax in the response\n    bold_phrases = pattern.findall(response)\n    # Check if there is exactly one bold phrase and it is a noun\n    if len(bold_phrases) == 1:\n        # Simplified check: Assume any single word in bold is a noun\n        return True if re.match(r'^[一-龥]+$', bold_phrases[0]) else False\n    return False", 1.0]], "cases": [["重要的概念需要用粗体标注，例如我们可以使用**Concept**来突出。", false], ["一般来说，我们可以在句子中找到名词。", false], ["在这篇文章中，我们重点关注了**名词**的使用。", true]], "back_instruction": ["在回答中使用粗体标记（用两个星号包裹）准确标出一个名词。"], "nli_scores": ["entailment"]}
{"instruction": "回答中包括三个二级标题，使用 markdown 语法编写，格式为 `## 标题`。", "eval_func": [["def evaluate(response):\n    try:\n        # Split the response into lines\n        lines = response.strip().split('\\n')\n        # Check if there are three lines that start with '## ' (markdown for secondary heading)\n        secondary_headings = [line for line in lines if line.startswith('## ')]\n        # Return True if there are exactly three secondary headings; Otherwise return False\n        return len(secondary_headings) == 3\n    except Exception as e:\n        return False", 1.0], ["def evaluate(response):\n    # Count the number of level-2 headings in the response using markdown syntax\n    count_headings = response.count('## ')\n\n    # Check if there are exactly three level-2 headings\n    return count_headings == 3", 1.0], ["def evaluate(response):\n    subheading_lines = [line.strip() for line in response.split('\\n') if line.strip().startswith('## ')]\n    if len(subheading_lines) != 3:\n        return False\n    for line in subheading_lines:\n        if len(line) < 4 or line[2] != ' ':\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # This will match two hashtags followed by a space and then any character except a newline\n    pattern = r'## .+'\n    # Find all occurrences of the pattern\n    matches = re.findall(pattern, response)\n    # Check if there are exactly three matches\n    return len(matches) == 3\n\nimport re", 1.0], ["def evaluate(response):\n    subheadings = response.split('\\n')\n    subheading_count = 0\n    for line in subheadings:\n        if line.startswith('## '):\n            subheading_count += 1\n    return subheading_count == 3", 1.0]], "cases": [["Here is some text.\n\n## First Heading\nMore text.\n## Second Heading\nEven more text.\n## Third Heading\nEnd of text.", true], ["## First Heading\nSome text.\n## Second Heading\nSome more text.\nLast text without heading.", false], ["## 1. First Heading\nContent under the first heading.\n\n## 2. Second Heading\nContent under the second heading.\n\n## 3. Third Heading\nContent under the third heading.", true]], "back_instruction": ["请在您的回答中正确使用 Markdown 语法添加三个二级标题。", "请确保您的回答中恰好包含三个使用 Markdown 语法格式化的二级标题。", "请在您的回答中使用 Markdown 语法格式化，并确保有三个格式正确的二级标题。"], "nli_scores": ["neutral", "neutral", "entailment"]}
{"instruction": "回答中每个段落的首字母必须为大写。", "eval_func": [["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # Skip empty paragraphs\n            continue\n        if not paragraph[0].isupper():  # Check the first character\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph:  # empty paragraph, skip or consider it valid\n            continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0], ["def evaluate(response):\n    paragraphs = response.split('\\n')\n    for paragraph in paragraphs:\n        if not paragraph: continue\n        if not paragraph[0].isupper():\n            return False\n    return True", 1.0]], "cases": [["this should fail.\nBecause the first paragraph does not start with an uppercase letter.", false], ["First paragraph is fine.\nsecond paragraph starts with lowercase.", false], ["this starts with a lowercase letter.\\nThis one starts with uppercase.", false], ["this is the first paragraph without uppercase.\nThis is the second paragraph.", false], ["This is a test.\nEvery paragraph starts with an uppercase letter.\nDoes it follow the rule?", true], ["This is the first paragraph.\nAnd this is the second one.\nFinally, this is the third paragraph.", true], ["This is a test.\\nEach paragraph starts with a capital letter.\\nAll rules followed.", true]], "back_instruction": ["回答时，请确保每个段落的首字母都是大写的。", "回答时，请确保每个段落的首字母都是大写的。", "回答时，请确保每个段落的首字母都是大写的。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "如果回答含有代码，每一行代码需要有相应的缩进，采用四个空格表示。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        # Skip empty lines or lines not starting with code\n        if not line or line.lstrip() == line:\n            continue\n        # Check if the line starts with four spaces for indentation\n        if not line.startswith('    '):\n            return False\n        # Check if rest of the code (if any) after the initial indent doesn't have any bad indentation\n        code_after_indent = line[4:]\n        if code_after_indent.startswith(' '):\n            return False\n    return True", 0.8]], "cases": [["这里有非法的缩进：\n  只有两个空格", false], ["这是一行代码。\n这是没有缩进的代码行，应该返回False。", false], ["这是一段文本。\n    这是一行代码。\n    还有一行代码。", true], ["    这行正确，但下面的不行：\n\t使用了Tab而非空格", false], ["这是一条指令：\n    正确的缩进代码行\n    又一行正确缩进的代码", true]], "back_instruction": ["回答时，请确保每一行代码都应该使用四个空格缩进，而且在缩进之后的代码不应该有不正确的缩进。"], "nli_scores": ["entailment"]}
{"instruction": "回答中引用的所有链接必须采用 markdown 内联链接的格式 `[链接文本](链接地址)`。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find markdown links\n    pattern = r'\\[.*?\\]\\(http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\\)'\n    # Find all markdown links in the response\n    markdown_links = re.findall(pattern, response)\n\n    # Split response into segments outside of markdown links\n    segments = re.split(pattern, response)\n\n    # Check segments that are not markdown links for the presence of URLs\n    url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n    for segment in segments:\n        if re.search(url_pattern, segment):\n            # If a URL is found outside a markdown link, return False\n            return False\n\n    # If no URLs found outside markdown links, return True\n    return True", 1.0], ["import re\n\ndef evaluate(response):\n    # Regular expression for markdown links\n    markdown_link_pattern = re.compile(r'\\[([^\\]]+)\\]\\((http[s]?://[^\\)]+)\\)')\n\n    # Find all markdown links in the response\n    markdown_links = markdown_link_pattern.findall(response)\n\n    # Find all href links in the response\n    href_links_pattern = re.compile(r'<a href=\"[^\"]+\">[^<]+</a>')\n    href_links = href_links_pattern.findall(response)\n\n    # The response is valid only if there are no href links\n    # and if all links are in markdown format\n    return not href_links and len(markdown_links) == response.count('http')", 1.0]], "cases": [["沒有使用任何链接的文本。", true], ["這是一個正確格式的範例：[Google](http://www.google.com)。", true], ["This is a correct link: [Google](http://google.com).", true], ["This is an incorrect link format: <a href=\"http://google.com\">Google</a>.", false], ["Multiple links can be included like [Bing](http://bing.com) and [Yahoo](http://yahoo.com), as long as they are correct.", true], ["這是一個錯誤格式的範例：[Google]http://www.google.com。", false]], "back_instruction": ["在回答中可以插入Markdown链接，但请确保文本中没有Markdown链接格式之外的URL。", "您的回答只应当包含Markdown格式的链接，并且不应当包含任何HTML的超链接标签（a标签）。"], "nli_scores": ["entailment", "neutral"]}
{"instruction": "每个数据点或实例在回答中必须有单独的一段解释，解释前用 `>>` 标明。", "eval_func": [["def evaluate(response):\n    segments = response.strip().split('\\n')\n    if not all(segment.startswith('>>') for segment in segments):\n        return False\n    explanation_segments = [seg[2:].strip() for seg in segments if seg.startswith('>>')]\n    if not all(explanation_segments):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by newlines\n    parts = response.strip().split('\\n')\n    \n    for part in parts:\n        # Check if each part starts with '>>'\n        if not part.startswith('>>'):\n            return False\n        # Check if there's an explanation after '>>'\n        explanation = part[2:].strip()\n        if not explanation:\n            return False\n    \n    # Check if there's at least one data point or instance with an explanation\n    return bool(parts)", 1.0]], "cases": [[">> 第一个数据点的解释\n>> 第二个数据点的解释\n第三个数据点的解释", false], [">>第一个数据点的解释\n\n>> 第二个数据点的解释\n\n>> 第三个数据点的解释", false], [">> 第一个数据点的解释\n>> 第二个数据点的解释\n>> 第三个数据点的解释", true]], "back_instruction": ["回答时请以双大于号 '>>' 开头，并确保每一行都以 '>>' 开始，且 '>>' 之后应紧跟解释文字，不能只有 '>>' 而没有解释内容。", "回答时每一部分的开头都需要是两个大于号 '>>'，并确保在 '>>' 后有相应的解释内容，且整个回答至少包含一组带有解释的数据点或实例。"], "nli_scores": ["entailment", "entailment"]}
{"instruction": "回答需要用markdown的分割线表示法在两处区分不同内容，即使用三个或以上连续的减号(---)。", "eval_func": [["def evaluate(response):\n    parts = response.split('---')\n    clean_parts = [part for part in parts if part.strip() != '']\n    return len(clean_parts) >= 3", 1.0]], "cases": [["We have two separators here, but one is not proper.\\n------\\nThis is okay.\\n- - -\\nThis is not.", false], ["Only one separator is not enough.\\n---\\nBut we need two separators.", false], ["This is the first part.\\n---\\nThis is the second part.\\n---\\nThis is the third part.", true]], "back_instruction": ["请在回答中至少使用三个由 '---' 分隔的部分，并且每个部分之间不应该只包含空格。"], "nli_scores": ["entailment"]}
{"instruction": "回答中引用语言需要用markdown的引用格式，即在每行引用的前面加上“> ”。", "eval_func": [["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line and not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line.strip() == '':\n            continue\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if line.strip() and not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response into lines\n    lines = response.split('\\n')\n    # Check each line for markdown quote format\n    for line in lines:\n        # Skip empty lines\n        if not line.strip():\n            continue\n        # Check if the line starts with '> '\n        if not line.startswith('> '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Check each line to see if it starts with \"> \" if it is non-empty\n    for line in response.split('\\n'):\n        if line and not line.startswith('> '):\n            return False\n    return True", 1.0]], "cases": [["> This is a quoted line.\n> This is another quoted line.\n\n> This is yet another quoted line.", true], ["> 引用格式正确的第一行\n\n> 引用格式正确的第二行，前面有空行", true], ["> 这是一行引用的文本。\n> 这是另一行引用的文本。", true], ["这是一行未使用正确引用格式的文本。\n> 这是一行正确引用的文本。", false], ["This line does not have the markdown.\n> This line does.", false], ["> This is a quoted line.\nThis should be quoted but is not.", false], ["> All lines are quoted correctly.\n> Even this one.\n> And this one.", true], ["> This is a line with proper markdown quote.\n> This is another properly formatted line.", true]], "back_instruction": ["请以引用块的格式（每行以'> '开头）回答，不含纯文本行。", "请以引用块的格式回答（每行以'> '开头），空行除外。", "请用引用块格式回答（每行以'> '开头），忽略空行和未加引用的行。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答应包含至少三个带下划线的单词或短语，如“_例子_”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\b_+[^_]+_\\b'\n    matches = re.findall(pattern, response)\n    return len(matches) >= 3", 1.0]], "cases": [["这只有两个带下划线的词，比如_示例_和_测试_。", false], ["我的答案是：_1_，_2_，_3_。", true], ["这个回答只有_two_个带下划线的词。", false], ["在句子中使用下划线，例如 _这个_、_示例_ 以及 _单词_ 是正确的。", true]], "back_instruction": ["在回答中至少使用三个由下划线（_）包围的词。"], "nli_scores": ["entailment"]}
{"instruction": "回答要求末尾加上版权声明，格式：“版权所有，未经许可不得转载。”。", "eval_func": [["def evaluate(response):\n    copyright_statement = \"版权所有，未经许可不得转载。\"\n    return response.endswith(copyright_statement)", 1.0], ["def evaluate(response):\n    copyright_notice = '版权所有，未经许可不得转载。'\n    return response.endswith(copyright_notice)", 1.0], ["def evaluate(response):\n    copyright_statement = '\\u7248\\u6743\\u6240\\u6709\\uff0c\\u672a\\u7ecf\\u8bb8\\u53ef\\u4e0d\\u5f97\\u8f6c\\u8f7d\\u3002'\n    return response.endswith(copyright_statement)", 1.0]], "cases": [["版权所有，未经许可不得转载。这是我的回答。", false], ["这是我的回答。版权所有，未经许可不得转载。", true]], "back_instruction": ["回答必须以'版权所有，未经许可不得转载。'结尾。", "回答必须以'版权所有，未经许可不得转载。'结尾。", "回答必须以'版权所有，未经许可不得转载。'结尾。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "在回答的末尾添加一个带有日期和时间戳的行，格式为“回答生成时间：YYYY-MM-DD HH:MM”。", "eval_func": [["def evaluate(response):\n    import re\n    # Define the pattern for the timestamp at the end of the response\n    pattern = r'\\u56DE\\u7B54\\u751F\\u6210\\u65F6\\u95F4\\uFF1A\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern at the end of the response\n    match = re.search(pattern, response)\n    if match and match.end() == len(response):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\n\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    if re.search(pattern, response):\n        return True\n    else:\n        return False", 0.8888888888888888], ["def evaluate(response):\n    import re\n    # Define the regex pattern to match the date-time stamp at the end of the response\n    pattern = r'\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern in the response\n    match = re.search(pattern, response)\n    # Check if there is a match and if it is placed at the end\n    if match and match.span()[1] == len(response):\n        return True\n    return False", 1.0], ["def evaluate(response):\n    import re\n    # Define the regular expression pattern to check for the timestamp\n    pattern = r'\\u56de\\u7b54\\u751f\\u6210\\u65f6\\u95f4\\uff1a\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}$'\n    # Search for the pattern at the end of the response\n    if re.search(pattern, response):\n        # Split the response into lines\n        lines = response.split('\\n')\n        # Check if the last line matches the pattern\n        if re.match(pattern, lines[-1]):\n            return True\n    return False", 0.8888888888888888]], "cases": [["这是一个回答的例子。回答生成时间：2023-03-30 12:45", true], ["这是一个回答示例。\n回答生成时间：2023-03-15 12:45", true], ["这是另一个回答样本，但没有时间戳。", false], ["这个答案没有包含正确的日期时间戳。回答生成时间：2022/03/30 12:45", false], ["这是不符合要求的回答，因为它没有时间戳。", false], ["这是一个回答示例。\n回答生成时间：2023-03-25 14:50", true], ["正确格式的答案末尾需要有一个时间戳。\n回答生成时间：2023/03/25 14:50", false], ["这是一个回答示例，但是它的时间戳不在末尾。\n回答生成时间：2023-03-15 12:45\n这是多余的文字。", false], ["答案和时间戳都正确，但是时间戳不是在最末尾。回答生成时间：2023-03-30 12:45 在这里还有文本。", false]], "back_instruction": ["请确保您的回答结尾包含格式正确的时间戳，格式为：“回答生成时间：YYYY-MM-DD HH:MM”。", "请在您的回答结尾附上时间戳，并确保其格式为：“回答生成时间：YYYY-MM-DD HH:MM”。", "请在回答末尾附上时间戳，确保它的格式正确无误，应为：“回答生成时间：YYYY-MM-DD HH:MM”，并且位于回答的最后。"], "nli_scores": ["entailment", "entailment", "neutral"]}
{"instruction": "若回答中出现专有名词或缩写，必须首次出现时在括号内标明全称，如“CPU（Central Processing Unit）”。", "eval_func": [["def evaluate(response):\n    import re\n\n    # Regular expression pattern to find acronyms and their expansions\n    pattern = re.compile(r'([A-Za-z]+)\\s*\\(([^)]+)\\)')\n\n    # This dictionary will map acronyms to their full forms\n    acronym_dict = {}\n\n    # Find all matches of the pattern\n    matches = pattern.findall(response)\n    for acronym, full_form in matches:\n        acronym_dict[acronym] = full_form\n\n    # Split the response into words\n    words = response.split()\n\n    # Check for acronyms and their expansions\n    for word in words:\n        # Strip punctuation\n        clean_word = re.sub(r'\\W', '', word)\n        # If the word is an acronym\n        if clean_word in acronym_dict:\n            # Find the acronym's index\n            index = response.find(clean_word)\n            prev_text = response[:index]\n            # Check if the acronym has appeared before without its full form\n            if clean_word in prev_text and not acronym_dict[clean_word] in prev_text:\n                return False\n    return True", 1.0]], "cases": [["现代计算机通常包括CPU、RAM（Random Access Memory）和HDD（Hard Disk Drive）。", true], ["操作系统（OS，Operating System）是控制计算机硬件与软件资源的程序。", true], ["在CPU和GPU（Graphics Processing Unit）之间进行选择时，你需要考虑你的计算需求。", true], ["在讨论CPU时，我们应该指出CPU（Central Processing Unit）是计算机的核心。", true], ["在计算机中，CPU（Central Processing Unit）是负责解释计算机指令以及处理计算机软件中的数据。", true], ["我们需要一个有强大CPU（Central Processing Unit）的计算机。", true]], "back_instruction": ["在回答中使用缩写词时，请确保每个缩写词在首次出现时都已提供完整形式，并且缩写词不在其完整形式出现之前使用。"], "nli_scores": ["entailment"]}
{"instruction": "回答中的每一个段落前都需要使用圆点符号“• ”开始。", "eval_func": [["def evaluate(response):\n    lines = response.strip().split('\\n')\n    for line in lines:\n        if not line.startswith('• '):\n            return False\n    return True if lines else False", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for item in items:\n        if not item.startswith('• '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    # Split the response by newline to get individual lines\n    lines = response.strip().split('\\n')\n    # Check if each line starts with the bullet point\n    for line in lines:\n        if not line.startswith('• '):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    items = response.split('\\n')\n    for item in items:\n        if not item.startswith('• '):\n            return False\n    return True if items else False", 1.0], ["def evaluate(response):\n    lines = response.split('\\n')\n    for line in lines:\n        if not line.strip().startswith('• '):\n            return False\n    return True", 1.0]], "cases": [["• 第一项\n第二项开始没有圆点符号\n• 第三项", false], ["• Item 1\nItem 2\n• Item 3", false], ["• Item 1\n•Item 2\n• Item 3", false], ["• First item\n•Second item\n• Third item", false], ["• 第一项\n• 第二项\n• 第三项", true], ["Item 1\n• Item 2\n• Item 3", false], ["", false], ["• Item 1\n• Item 2\n• Item 3", true], ["第一项\n• 第二项\n• 第三项", false], ["First item\n• Second item\n• Third item", false], ["• First item\n• Second item\n• Third item", true], ["• 第一项\n• 第二项\n- 第三项", false]], "back_instruction": ["回答时每一行都应该以圆点符号“• ”开头。", "用列表回答，每一个条目都要以圆点符号“• ”开头。", "回答时，请确保每一行文本都以圆点符号“• ”作为开头。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答的结尾必须加上一句话“本回答已完毕。”。", "eval_func": [["def evaluate(response):\n    return response.endswith('\\u672c\\u56de\\u7b54\\u5df2\\u5b8c\\u6bd5\\u3002')", 1.0], ["def evaluate(response):\n    return response.strip().endswith('本回答已完毕。')", 1.0], ["def evaluate(response: str) -> bool:\n    # This is the required ending sentence according to the instruction\n    required_ending = '本回答已完毕。'\n    # Check if response ends with the required sentence\n    return response.endswith(required_ending)", 1.0], ["def evaluate(response):\n    return response.endswith('本回答已完毕。')", 1.0]], "cases": [["这是一个符合规定的回答。本回答已完毕。", true], ["看似遵守了，但实际上最后一句话并不符合。本回答已经完毕。", false], ["这个回答没有加上指定的结尾", false], ["本回答已完毕。但是我还有其他话要说。", false], ["本回答已完毕。但是这句话在开头。", false], ["这是一个回答的例子。本回答已完毕。", true], ["这是一个回答。本回答已完毕。", true], ["没有经过任何灰庄，那也成不上真正的勇士。本回答已完毕。", true], ["这是一个遵循指导的回答。本回答已完毕。", true], ["这个回答没有遵守指令", false], ["这个回答没有按照要求结束。", false], ["本回答已完毕。确实这样结束了。", false]], "back_instruction": ["回答必须以'本回答已完毕。'结尾。", "回答需要在去除前后空白字符后以'本回答已完毕。'结尾。", "请确保你的回答以'本回答已完毕。'作为结尾。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答中必须包含至少一个由大括号{}包裹的表达式，比如{表达式}。", "eval_func": [["def evaluate(response):\n    import re\n    # Regular expression to find at least one occurrence of expression within {}\n    pattern = re.compile(r'{[^{}]*}')\n    # Search the pattern in the response\n    match = pattern.search(response)\n    # Return True if a match is found, else return False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'{[^{}]*}'\n    matches = re.findall(pattern, response)\n    return bool(matches)", 1.0], ["def evaluate(response):\n    import re\n    # Use regex to find expressions within {}\n    pattern = re.compile(r'{[^{}]*}')\n    # Search for the pattern in the response\n    match = pattern.search(response)\n    # Check if at least one expression is found\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    # The pattern checks for at least one occurrence of {expression}\n    # where 'expression' is any sequence of characters except for {} itself\n    pattern = re.compile(r'{[^{}]*}')\n    # Search for the pattern in the response\n    match = pattern.search(response)\n    # Return True if a match is found, otherwise return False\n    return bool(match)", 1.0], ["def evaluate(response):\n    import re\n    pattern = r'\\{.*?\\}'\n    return bool(re.search(pattern, response))", 1.0]], "cases": [["这是一个包含{特定表达式}的答案。", true], ["这个回答{包含一部分}符合要求。", true]], "back_instruction": ["使用花括号{}包含的表达式至少出现一次。", "回答中必须至少出现一次使用花括号{}包裹的表达式。", "确保你的回答至少包含一个用花括号{}包裹的表达式。"], "nli_scores": ["entailment", "entailment", "entailment"]}
{"instruction": "回答需要包括具体的日期，日期格式为“YYYY年MM月DD日”。", "eval_func": [["def evaluate(response):\n    import re\n    pattern = r'\\d{4}年\\d{2}月\\d{2}日'\n    match = re.search(pattern, response)\n    if match:\n        return True\n    else:\n        return False", 1.0]], "cases": [["今天是2023年03月25日。", true], ["记得2023年12月01日那天的大雨。", true], ["日期为03/25/2023。", false]], "back_instruction": ["回答中必须包含符合格式的日期，格式为'年(四位数字)月(两位数字)日(两位数字)'。"], "nli_scores": ["entailment"]}
{"instruction": "在回答的开头和结尾，分别加上 “<回答开始>” 和 “<回答结束>” 标记。", "eval_func": [["def evaluate(response):\n    return response.startswith('<回答开始>') and response.endswith('<回答结束>')", 1.0], ["def evaluate(response):\n    if not response.startswith('<回答开始>') or not response.endswith('<回答结束>'):\n        return False\n    return True", 1.0], ["def evaluate(response):\n    start_tag = \"<回答开始>\"\n    end_tag = \"<回答结束>\"\n    if response.startswith(start_tag) and response.endswith(end_tag):\n        return True\n    else:\n        return False", 1.0], ["def evaluate(response):\n    if response.startswith('<回答开始>') and response.endswith('<回答结束>'):\n        return True\n    else:\n        return False", 1.0]], "cases": [["<回答开始>这是符合指示的回答。<回答结束>", true], ["这是不符合指示的回答。<回答结束>", false], ["<回答开始>这是不符合指示的回答。", false]], "back_instruction": ["请以'<回答开始>'开头，并以'<回答结束>'结尾回答。", "回答时请确保以'<回答开始>'作为开始，并以'<回答结束>'作为结束。", "回答必须以'<回答开始>'为起始标签，并以'<回答结束>'为结束标签。"], "nli_scores": ["entailment", "entailment", "neutral"]}
{"instruction": "回答中提及的数字必须用中文数字表示，而不能用阿拉伯数字。", "eval_func": [["def evaluate(response):\n    import re\n    # Define a function to check if there are Arabic numerals in the response\n    def has_arabic_numerals(input_string):\n        return bool(re.search(r'\\d', input_string))\n    # Define a function to check if a text includes Chinese numerals\n    def has_chinese_numerals(input_string):\n        # List of Chinese numerals for 0 to 9\n        chinese_numerals = '零一二三四五六七八九'\n        return any(char in chinese_numerals for char in input_string)\n    # Check response for Arabic numerals, which are not allowed\n    if has_arabic_numerals(response):\n        return False\n\n    # While an absence of any numerals is fine, presence of Chinese numerals would mean\n    # the instruction is satisfied, so no explicit check for their presence is needed.\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Check if the response contains Arabic numerals\n    if re.search(r'\\d', response):\n        return False\n    # Define the list of Chinese numerals\n    chinese_numerals = '零一二三四五六七八九十百千万亿兆'\n    # Check if all the numerals in the response are Chinese\n    for char in re.findall(r'\\b\\d+\\b', response):\n        if not all(num in chinese_numerals for num in char):\n            return False\n    return True", 1.0], ["def evaluate(response):\n    import re\n\n    # Define a pattern that matches Arabic numerals (0-9)\n    # If an Arabic numeral is found, it violates the instruction\n    arabic_numeral_pattern = re.compile(r'\\d')\n\n    # Search for Arabic numerals within the response\n    if arabic_numeral_pattern.search(response):\n        # There are Arabic numerals, so it violates the instruction\n        return False\n\n    # No Arabic numerals found, it follows the instruction\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to find Arabic numbers\n    arabic_numbers_pattern = r'\\d+'\n    # Check if there are any Arabic numbers in response\n    return re.search(arabic_numbers_pattern, response) is None", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression to match any Arabic numerals\n    arabic_numerals = r'\\d+'\n    # Search for Arabic numerals in the response\n    if re.search(arabic_numerals, response):\n        return False\n    # It is assumed that all Chinese numerals in the response are correct\n    # as the function only checks for the presence of Arabic numerals\n    return True", 1.0]], "cases": [["八百八十八是一个幸运数字", true], ["这个问题的答案是三", true], ["结果为42", false]], "back_instruction": ["请用不含阿拉伯数字的方式作答。", "请使用中文数字而不是阿拉伯数字回答问题，但如果回答中完全没有数字，也是可以的。", "作答时请不要使用包含阿拉伯数字的内容。"], "nli_scores": ["entailment", "neutral", "entailment"]}
{"instruction": "如果回答中提到某个数字，数字必须用括号包围，例如“(123)”。", "eval_func": [["def evaluate(response):\n    import re\n    # Check if there are numbers not enclosed in parentheses\n    pattern = r'([^()]\\d+[^()])|(^\\d+[^()])|([^()]\\d+$)'\n    if re.search(pattern, response):\n        return False\n\n    # Confirm that all numbers are enclosed correctly\n    enclosed_numbers = re.findall(r'\\((\\d+)\\)', response)\n    for num in enclosed_numbers:\n        if not num.isdigit():\n            return False\n\n    return True", 1.0], ["def evaluate(response):\n    import re\n    # Compiles a regular expression to find numeric characters not enclosed in parentheses\n    non_enclosed_numbers = re.compile(r'(?<!\\()\\d+(?!\\))')\n    # Find all instances where a number isn't enclosed properly\n    non_enclosed = non_enclosed_numbers.findall(response)\n    # If there are any instances, the input does not follow the instructions\n    if non_enclosed:\n        return False\n    # To ensure that numbers are correctly enclosed, all numbers must be within parentheses\n    # The following regular expression matches numbers enclosed in parentheses\n    properly_enclosed_numbers = re.compile(r'\\(\\d+\\)')\n    # Finds all properly enclosed numbers\n    properly_enclosed = properly_enclosed_numbers.findall(response)\n    # Having other characters within parentheses containing number is not allowed\n    improperly_enclosed_characters = re.compile(r'\\([^\\d]+\\d+[^\\d]+\\)')\n    improperly_enclosed = improperly_enclosed_characters.findall(response)\n    # No improperly enclosed sequences should be found\n    return len(improperly_enclosed) == 0", 1.0], ["def evaluate(response):\n    import re\n    # Regular expression pattern to match a properly bracketed number\n    pattern = r'\\([^\\d]*(\\d+)[^\\d]*\\)'\n    # Find all occurrences of pattern\n    matches = re.findall(pattern, response)\n    # Split the response to analyze parts between matches\n    split_response = re.split(pattern, response)\n    for part in split_response:\n        # Check if any digits are found outside the matches\n        if any(char.isdigit() for char in part):\n            return False\n    return True", 0.8]], "cases": [["没有使用数字时，它(应该)返回True。", true], ["这是一个合法的回答(42)，它正确地遵守了指示。", true], ["这个回答违反了规则因为123没有被括号包围。", false], ["这个例子(123是错误的。", false], ["(1234)是被正确包围的，但这个没有(5678是错的。", false]], "back_instruction": ["回答时，请确保文中的所有数字都被正确地用一对圆括号括起来，而括号之外不得有数字。", "回答时，所有数字必须被一对圆括号所封闭。请确保圆括号中只包含数字，不要有其他字符与数字一起被圆括号所封闭。", "在回答时，所有数字符号必须位于正确的括号内。请确保回答中的每一部分，如果不是括号内的内容，则不包含任何数字。"], "nli_scores": ["entailment", "neutral", "neutral"]}
